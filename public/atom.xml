<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>AFlyingSheep&#39;s Blog</title>
  
  <subtitle>Keep coding, keep thinking.</subtitle>
  <link href="http://aflyingsheep.github.io/atom.xml" rel="self"/>
  
  <link href="http://aflyingsheep.github.io/"/>
  <updated>2023-07-21T16:27:40.455Z</updated>
  <id>http://aflyingsheep.github.io/</id>
  
  <author>
    <name>Johnson Shuangjian</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>神威混合编译</title>
    <link href="http://aflyingsheep.github.io/2023/07/21/sunway/SWmhybrid/"/>
    <id>http://aflyingsheep.github.io/2023/07/21/sunway/SWmhybrid/</id>
    <published>2023-07-21T15:56:06.000Z</published>
    <updated>2023-07-21T16:27:40.455Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>近期师兄让我学习了神威的混合编译部分，发现这真是个神奇的东西，可以不用再分两个文件写从核代码，也可以灵活运用宏来分别编译主从核部分、自动推断函数类型，甚至可以把对象从主核传送到从核（这真的很方便）。</p><h1 id="神威主从核编译概述"><a class="markdownIt-Anchor" href="#神威主从核编译概述"></a> 神威主从核编译概述</h1><ol><li>编译器增加-mhybrid-coding选项，支持C++主从核代码在同文件内混合编写，默认为主核代码，从核入口函数增加attribute kernel属性。在编译时，分别使用-mslave和-mhost生成主从核对应的.o文件，最后将其链接起来。</li><li>没有被显示调用的主从核函数要增加arribute slave和arribute hostslave属性，具体见文档。</li><li>更多的细节见文档，本文主要就主从核crtp进行分享。</li></ol><h1 id="神威crtp"><a class="markdownIt-Anchor" href="#神威crtp"></a> 神威CRTP</h1><p>本文中，首先编写了task基类，其中有<code>Initialize()</code>，<code>Finalize() </code>和 <code>Self()</code> 三个方法，基类中均是使用CRTP方式进行调用；接着编写了两个派生类，其<code>Self() </code>方法分别对每个数组的数值加一或减一。主要代码如下所示：</p><h2 id="taskh"><a class="markdownIt-Anchor" href="#taskh"></a> task.h</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> SWSPH_TASK_H_</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SWSPH_TASK_H_</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> swsph &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Task</span> &#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">Task</span>(std::vector&lt;<span class="keyword">int</span>&gt;&amp; arr) : arr_&#123;arr&#125; &#123;&#125;;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">Initialize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static_cast</span>&lt;T*&gt;(<span class="keyword">this</span>)-&gt;<span class="built_in">Initialize</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">Finalize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static_cast</span>&lt;T*&gt;(<span class="keyword">this</span>)-&gt;<span class="built_in">Finalize</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">Self</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static_cast</span>&lt;T*&gt;(<span class="keyword">this</span>)-&gt;<span class="built_in">Self</span>(index);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  std::vector&lt;<span class="keyword">int</span>&gt;&amp; arr_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#125;;  <span class="comment">// namespace swsph</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><h2 id="task_acch"><a class="markdownIt-Anchor" href="#task_acch"></a> task_acc.h</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> SWSPH_TASK_ACC_BF_H_</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SWSPH_TASK_ACC_BF_H_</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;task.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> swsph &#123;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CalcAccBf</span> :</span> <span class="keyword">public</span> Task&lt;CalcAccBf&gt; &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">CalcAccBf</span>(std::vector&lt;<span class="keyword">int</span>&gt;&amp; arr) : Task&lt;CalcAccBf&gt;(arr), <span class="built_in">ref_arr</span>(arr) &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">Initialize</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">Self</span><span class="params">(<span class="keyword">int</span> index)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">Finalize</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function">std::vector&lt;<span class="keyword">int</span>&gt;&amp; <span class="title">get_buf</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> acc_buf_; &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  std::vector&lt;<span class="keyword">int</span>&gt; acc_buf_;</span><br><span class="line">  std::vector&lt;<span class="keyword">int</span>&gt;&amp; ref_arr;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CalcAccMinus</span> :</span> <span class="keyword">public</span> Task&lt;CalcAccMinus&gt; &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">CalcAccMinus</span>(std::vector&lt;<span class="keyword">int</span>&gt;&amp; arr) : Task&lt;CalcAccMinus&gt;(arr), <span class="built_in">ref_arr</span>(arr)&#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">Initialize</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">Self</span><span class="params">(<span class="keyword">int</span> index)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">Finalize</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function">std::vector&lt;<span class="keyword">int</span>&gt;&amp; <span class="title">get_buf</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> acc_buf_; &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  std::vector&lt;<span class="keyword">int</span>&gt; acc_buf_;</span><br><span class="line">  std::vector&lt;<span class="keyword">int</span>&gt;&amp; ref_arr;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#125;  <span class="comment">// namespace swsph</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> </span></span><br></pre></td></tr></table></figure><h2 id="task_acccc"><a class="markdownIt-Anchor" href="#task_acccc"></a> task_acc.cc</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;task_acc_bf.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;crts.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;utility&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> swsph &#123;</span><br><span class="line">    [[gnu::slave]] <span class="function"><span class="keyword">void</span> <span class="title">CalcAccBf::Initialize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;Slave %d, plus init.\n&quot;</span>, _PEN);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    [[gnu::slave]] <span class="function"><span class="keyword">void</span> <span class="title">CalcAccBf::Finalize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;Slave %d, plus final.\n&quot;</span>, _PEN);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    [[gnu::slave]] <span class="function"><span class="keyword">void</span> <span class="title">CalcAccBf::Self</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">      ref_arr[index]++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    [[gnu::slave]] <span class="function"><span class="keyword">void</span> <span class="title">CalcAccMinus::Initialize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;Slave %d, minus init.\n&quot;</span>, _PEN);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    [[gnu::slave]] <span class="function"><span class="keyword">void</span> <span class="title">CalcAccMinus::Finalize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;Slave %d, minus final.\n&quot;</span>, _PEN);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    [[gnu::slave]] <span class="function"><span class="keyword">void</span> <span class="title">CalcAccMinus::Self</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">      ref_arr[index]--;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="maincc"><a class="markdownIt-Anchor" href="#maincc"></a> <a href="http://main.cc">main.cc</a></h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;crts.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;task.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;task_acc_bf.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;main.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SW64_SPAWN(fn, args) athread_spawn_cgs((fn), (args))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SW64_JOIN() athread_join_cgs()</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> VECTOR_LENGTH 128</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; [[gnu::slave]] </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TimeIntegration::for_each_compute</span><span class="params">(swsph::Task&lt;T&gt;&amp; task)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> nr_cells = num_size_;</span><br><span class="line">  <span class="keyword">int</span> cell_start = _PEN * nr_cells / <span class="number">64</span>;</span><br><span class="line">  <span class="keyword">int</span> cell_end = (_PEN + <span class="number">1</span>) * nr_cells / <span class="number">64</span>;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Slave %d says: run! Start: %d, end: %d.\n&quot;</span>, _PEN, cell_start, cell_end);</span><br><span class="line">  task.<span class="built_in">Initialize</span>();</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> index = cell_start; index != cell_end; index++) &#123;</span><br><span class="line">    task.<span class="built_in">Self</span>(index);</span><br><span class="line">  &#125;</span><br><span class="line">  task.<span class="built_in">Finalize</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">[[gnu::kernel]] </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TimeIntegration::calculate_plus_test</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __sw_slave__</span></span><br><span class="line">    <span class="function">swsph::CalcAccBf <span class="title">cal</span><span class="params">(arr_)</span></span>;</span><br><span class="line">    for_each_compute(cal);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">[[gnu::kernel]] </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TimeIntegration::calculate_minus_test</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __sw_slave__</span></span><br><span class="line">    <span class="function">swsph::CalcAccMinus <span class="title">cal</span><span class="params">(arr_)</span></span>;</span><br><span class="line">    for_each_compute(cal);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">[[gnu::host]] </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TimeIntegration::run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">set_num_size</span>(VECTOR_LENGTH);</span><br><span class="line">    arr_.<span class="built_in">resize</span>(num_size_, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">calculate_plus_test</span>();</span><br><span class="line">    <span class="built_in">athread_join</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; VECTOR_LENGTH; i++) &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, arr_[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    <span class="built_in">calculate_minus_test</span>();</span><br><span class="line">    <span class="built_in">athread_join</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; VECTOR_LENGTH; i++) &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, arr_[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">athread_init</span>();</span><br><span class="line">    TimeIntegration tm;</span><br><span class="line">    tm.<span class="built_in">run</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>函数前面使用<code>[[gnu::kernel]]</code>修饰一下，编译器自动识别并分别编译。这样可以实现混合编译，不需要单独写一个从核.c文件。更重要的是支持C++，这个确实方便了很多。</p><h2 id="编译选项"><a class="markdownIt-Anchor" href="#编译选项"></a> 编译选项</h2><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">fake_path/swg++ -mhybrid-coding task_acc_bf.cc -c -mslave -o build/task-slave.o</span><br><span class="line">fake_path/swg++ -mhybrid-coding main.cc -c -o build/host.o</span><br><span class="line">fake_path/swg++ -mhybrid-coding main.cc -c -mslave -o build/slave.o -msimd</span><br><span class="line">fake_path/swg++ -mhybrid build/task.o build/host.o build/slave.o build/task-slave.o -o build/for-each</span><br></pre></td></tr></table></figure><h1 id="总结-reference"><a class="markdownIt-Anchor" href="#总结-reference"></a> 总结 &amp; Reference</h1><p>本次是对于混合编译的初体验，对于lambda表达式的传递、对象传递等很多内容还需要继续学习体验，后续再更。</p><p>Reference: 神威混合编译手册。</p>]]></content>
    
    
    <summary type="html">神威支持混合编译，支持从核部分C++等新特性。非常好玩。</summary>
    
    
    
    <category term="C++" scheme="http://aflyingsheep.github.io/categories/C/"/>
    
    <category term="Sunway" scheme="http://aflyingsheep.github.io/categories/Sunway/"/>
    
    
    <category term="C++" scheme="http://aflyingsheep.github.io/tags/C/"/>
    
    <category term="Sunway" scheme="http://aflyingsheep.github.io/tags/Sunway/"/>
    
  </entry>
  
  <entry>
    <title>喜大普奔！</title>
    <link href="http://aflyingsheep.github.io/2023/07/21/xdpb/"/>
    <id>http://aflyingsheep.github.io/2023/07/21/xdpb/</id>
    <published>2023-07-21T03:08:06.000Z</published>
    <updated>2023-07-21T03:12:52.352Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>本次数据丢失给我带来的教训：网站源程序要传到github分支中，重要数据要备份0.0</p><p>可惜有些学习版软件无法直接拷贝过来，还是需要重新弄一个:-(</p>]]></content>
    
    
    <summary type="html">喜大普奔！固态硬盘数据被我弄出来了，博客又恢复更新了！</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>多路归并</title>
    <link href="http://aflyingsheep.github.io/2023/05/29/algorithm/multiway-merging/"/>
    <id>http://aflyingsheep.github.io/2023/05/29/algorithm/multiway-merging/</id>
    <published>2023-05-29T02:33:02.000Z</published>
    <updated>2023-05-29T03:00:15.760Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="leetcode-264-丑数"><a class="markdownIt-Anchor" href="#leetcode-264-丑数"></a> Leetcode 264 丑数</h1><h2 id="题目描述"><a class="markdownIt-Anchor" href="#题目描述"></a> 题目描述</h2><p>给你一个整数 n ，请你找出并返回第 n 个 丑数 。</p><p>丑数 就是只包含质因数 2、3 和 5 的正整数。</p><h2 id="示例"><a class="markdownIt-Anchor" href="#示例"></a> 示例</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 输入：n = 10</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出：12</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 解释：[1, 2, 3, 4, 5, 6, 8, 9, 10, 12] 是由前 10 个丑数组成的序列。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 1 &lt;= n &lt;= 1690</span></span><br></pre></td></tr></table></figure><h2 id="思路"><a class="markdownIt-Anchor" href="#思路"></a> 思路</h2><p>最朴素的思路便是顺序对每个数字进行检测是否为丑数，时间复杂度为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>。</p><p>我们可以发现，对于每个丑数<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">x</span></span></span></span>，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>2</mn><mi>x</mi><mo separator="true">,</mo><mn>3</mn><mi>x</mi><mo separator="true">,</mo><mn>5</mn><mi>x</mi></mrow><annotation encoding="application/x-tex">2x, 3x, 5x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8388800000000001em;vertical-align:-0.19444em;"></span><span class="mord">2</span><span class="mord mathnormal">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">3</span><span class="mord mathnormal">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">5</span><span class="mord mathnormal">x</span></span></span></span>均为丑数。</p><p>其中，倍数为2的丑数分别为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>∗</mo><mn>2</mn><mo separator="true">,</mo><mn>2</mn><mo>∗</mo><mn>2</mn><mo separator="true">,</mo><mn>3</mn><mo>∗</mo><mn>2</mn><mo separator="true">,</mo><mo>…</mo></mrow><annotation encoding="application/x-tex">1*2,2*2,3*2,\dots</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8388800000000001em;vertical-align:-0.19444em;"></span><span class="mord">2</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8388800000000001em;vertical-align:-0.19444em;"></span><span class="mord">2</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">3</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8388800000000001em;vertical-align:-0.19444em;"></span><span class="mord">2</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner">…</span></span></span></span>，即<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>2</mn><mo separator="true">,</mo><mn>4</mn><mo separator="true">,</mo><mn>6</mn><mo separator="true">,</mo><mn>8</mn><mo separator="true">,</mo><mo>…</mo></mrow><annotation encoding="application/x-tex">2, 4, 6, 8,\dots</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8388800000000001em;vertical-align:-0.19444em;"></span><span class="mord">2</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">4</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">6</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">8</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner">…</span></span></span></span>，倍数为3的丑数分别为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>∗</mo><mn>3</mn><mo separator="true">,</mo><mn>2</mn><mo>∗</mo><mn>3</mn><mo separator="true">,</mo><mn>3</mn><mo>∗</mo><mn>3</mn><mo separator="true">,</mo><mo>…</mo></mrow><annotation encoding="application/x-tex">1*3,2*3,3*3,\dots</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8388800000000001em;vertical-align:-0.19444em;"></span><span class="mord">3</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8388800000000001em;vertical-align:-0.19444em;"></span><span class="mord">3</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">3</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8388800000000001em;vertical-align:-0.19444em;"></span><span class="mord">3</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner">…</span></span></span></span>，即<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>3</mn><mo separator="true">,</mo><mn>6</mn><mo separator="true">,</mo><mn>9</mn><mo separator="true">,</mo><mn>12</mn><mo separator="true">,</mo><mo>…</mo></mrow><annotation encoding="application/x-tex">3, 6, 9, 12,\dots</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8388800000000001em;vertical-align:-0.19444em;"></span><span class="mord">3</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">6</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">9</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mord">2</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner">…</span></span></span></span>，倍数为5的丑数分别为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>∗</mo><mn>5</mn><mo separator="true">,</mo><mn>2</mn><mo>∗</mo><mn>5</mn><mo separator="true">,</mo><mn>3</mn><mo>∗</mo><mn>5</mn><mo separator="true">,</mo><mo>…</mo></mrow><annotation encoding="application/x-tex">1*5,2*5,3*5,\dots</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8388800000000001em;vertical-align:-0.19444em;"></span><span class="mord">5</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8388800000000001em;vertical-align:-0.19444em;"></span><span class="mord">5</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">3</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8388800000000001em;vertical-align:-0.19444em;"></span><span class="mord">5</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner">…</span></span></span></span>，即<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>5</mn><mo separator="true">,</mo><mn>10</mn><mo separator="true">,</mo><mn>15</mn><mo separator="true">,</mo><mo>…</mo></mrow><annotation encoding="application/x-tex">5,10,15,\dots</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8388800000000001em;vertical-align:-0.19444em;"></span><span class="mord">5</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mord">5</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner">…</span></span></span></span>。</p><p>最终的目的便是将这三个数列归并，找到第n个数即可。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">nthUglyNumber</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        array&lt;<span class="keyword">long</span>, 1690&gt; arr;</span><br><span class="line">        arr[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> p2 = <span class="number">0</span>, p3 = <span class="number">0</span>, p5 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">long</span> now_value = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">            now_value = <span class="built_in">min</span>(arr[p2] * <span class="number">2</span>, <span class="built_in">min</span>(arr[p3] * <span class="number">3</span>, arr[p5] * <span class="number">5</span>));</span><br><span class="line">            <span class="keyword">if</span> (arr[p2] * <span class="number">2</span> == now_value) p2++;</span><br><span class="line">            <span class="keyword">if</span> (arr[p3] * <span class="number">3</span> == now_value) p3++;</span><br><span class="line">            <span class="keyword">if</span> (arr[p5] * <span class="number">5</span> == now_value) p5++;</span><br><span class="line">            arr[i] = now_value;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> now_value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="leetcode-373-786-多路归并"><a class="markdownIt-Anchor" href="#leetcode-373-786-多路归并"></a> Leetcode 373 786 多路归并</h1><p>这两道题都是多路归并的题，题目特点均为存在两个<strong>有序</strong>数组，分别从每个数组中取一个元素计算一个值，求出第k大的值与其对应数组中的位置。</p><p>解题思路均为采用优先队列，以786为例，问题等价于我们从n−1 个（下标 0 作为分母的话，不存在任何分数）有序序列中找到第 k 小的数值。这 n−1 个序列分别为：</p><p><img src="/image/merge/1.png" alt="1" /></p><p>起始将第一列入队，然后弹出k次，每次弹出后将同一行的下一个元素入队。时间复杂度为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(nlogn)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>(初始插入)+<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>k</mi><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(klogn)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>(查找k次)，即<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi><mi>a</mi><mi>x</mi><mo stretchy="false">(</mo><mi>n</mi><mo separator="true">,</mo><mi>k</mi><mo stretchy="false">)</mo><mo>∗</mo><mi>l</mi><mi>o</mi><mi>g</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">max(n, k)*log(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">m</span><span class="mord mathnormal">a</span><span class="mord mathnormal">x</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>。</p><h1 id="leetcode-1439-有序矩阵中的第-k-个最小数组和"><a class="markdownIt-Anchor" href="#leetcode-1439-有序矩阵中的第-k-个最小数组和"></a> Leetcode 1439 有序矩阵中的第 k 个最小数组和</h1><h2 id="题目描述-2"><a class="markdownIt-Anchor" href="#题目描述-2"></a> 题目描述</h2><p>给你一个 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi><mo>∗</mo><mi>n</mi></mrow><annotation encoding="application/x-tex">m * n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.46528em;vertical-align:0em;"></span><span class="mord mathnormal">m</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">n</span></span></span></span> 的矩阵 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi><mi>a</mi><mi>t</mi></mrow><annotation encoding="application/x-tex">mat</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.61508em;vertical-align:0em;"></span><span class="mord mathnormal">m</span><span class="mord mathnormal">a</span><span class="mord mathnormal">t</span></span></span></span>，以及一个整数 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span></span></span></span> ，矩阵中的每一行都以非递减的顺序排列。</p><p>你可以从每一行中选出 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> 个元素形成一个数组。返回所有可能数组中的第 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span></span></span></span> 个 最小数组和。</p><h2 id="示例-2"><a class="markdownIt-Anchor" href="#示例-2"></a> 示例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：mat = [[1,3,11],[2,4,6]], k = 5</span><br><span class="line">输出：7</span><br><span class="line">解释：从每一行中选出一个元素，前 k 个和最小的数组分别是：</span><br><span class="line">[1,2], [1,4], [3,2], [3,4], [1,6]。其中第 5 个的和是 7 。  </span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：mat = [[1,3,11],[2,4,6]], k = 9</span><br><span class="line">输出：17</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：mat = [[1,10,10],[1,4,5],[2,3,6]], k = 7</span><br><span class="line">输出：9</span><br><span class="line">解释：从每一行中选出一个元素，前 k 个和最小的数组分别是：</span><br><span class="line">[1,1,2], [1,1,3], [1,4,2], [1,4,3], [1,1,6], [1,5,2], [1,5,3]。其中第 7 个的和是 9 。</span><br></pre></td></tr></table></figure><p>数据范围:</p><ul><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi><mo>=</mo><mo>=</mo><mi>m</mi><mi>a</mi><mi>t</mi><mi mathvariant="normal">.</mi><mi>l</mi><mi>e</mi><mi>n</mi><mi>g</mi><mi>t</mi><mi>h</mi></mrow><annotation encoding="application/x-tex">m == mat.length</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">m</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span></span><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathnormal">m</span><span class="mord mathnormal">a</span><span class="mord mathnormal">t</span><span class="mord">.</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">e</span><span class="mord mathnormal">n</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal">t</span><span class="mord mathnormal">h</span></span></span></span></li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo>=</mo><mo>=</mo><mi>m</mi><mi>a</mi><mi>t</mi><mi mathvariant="normal">.</mi><mi>l</mi><mi>e</mi><mi>n</mi><mi>g</mi><mi>t</mi><mi>h</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">n == mat.length[i]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span></span><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">m</span><span class="mord mathnormal">a</span><span class="mord mathnormal">t</span><span class="mord">.</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">e</span><span class="mord mathnormal">n</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal">t</span><span class="mord mathnormal">h</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">]</span></span></span></span></li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>&lt;</mo><mo>=</mo><mi>m</mi><mo separator="true">,</mo><mi>n</mi><mo>&lt;</mo><mo>=</mo><mn>40</mn></mrow><annotation encoding="application/x-tex">1 &lt;= m, n &lt;= 40</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68354em;vertical-align:-0.0391em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span></span><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.7335400000000001em;vertical-align:-0.19444em;"></span><span class="mord mathnormal">m</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span></span><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">4</span><span class="mord">0</span></span></span></span></li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>&lt;</mo><mo>=</mo><mi>k</mi><mo>&lt;</mo><mo>=</mo><mi>m</mi><mi>i</mi><mi>n</mi><mo stretchy="false">(</mo><mn>200</mn><mo separator="true">,</mo><msup><mi>n</mi><mi>m</mi></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">1 &lt;= k &lt;= min(200, n ^ m)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68354em;vertical-align:-0.0391em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span></span><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.73354em;vertical-align:-0.0391em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span></span><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">m</span><span class="mord mathnormal">i</span><span class="mord mathnormal">n</span><span class="mopen">(</span><span class="mord">2</span><span class="mord">0</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">m</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>&lt;</mo><mo>=</mo><mi>m</mi><mi>a</mi><mi>t</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>j</mi><mo stretchy="false">]</mo><mo>&lt;</mo><mo>=</mo><mn>5000</mn></mrow><annotation encoding="application/x-tex">1 &lt;= mat[i][j] &lt;= 5000</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68354em;vertical-align:-0.0391em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span></span><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">m</span><span class="mord mathnormal">a</span><span class="mord mathnormal">t</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span></span><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">5</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span></span></span></span></li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi><mi>a</mi><mi>t</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">mat[i]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">m</span><span class="mord mathnormal">a</span><span class="mord mathnormal">t</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">]</span></span></span></span> 是一个非递减数组</li></ul><h2 id="思路-2"><a class="markdownIt-Anchor" href="#思路-2"></a> 思路</h2><p>同样是多路归并问题，该题进行了多次多路归并，首先将前两行进行归并，得到长度小于等于k的最大和序列，即为前两行相加以后前k大的元素，接着将和序列与下一行继续归并，直到矩阵的最后一行，归并后第k个元素即为所求。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Sum</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line">    <span class="keyword">int</span> y;</span><br><span class="line">    <span class="keyword">int</span> sum;</span><br><span class="line">    <span class="built_in">Sum</span>(<span class="keyword">int</span> ix, <span class="keyword">int</span> iy, <span class="keyword">int</span> isum) : <span class="built_in">x</span>(ix), <span class="built_in">y</span>(iy), <span class="built_in">sum</span>(isum) &#123;&#125;;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(<span class="keyword">const</span> Sum&amp; rhs) <span class="keyword">const</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sum &gt; rhs.sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">merge</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt; vec1, vector&lt;<span class="keyword">int</span>&gt; vec2, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        priority_queue&lt;Sum&gt; q;</span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt; ans;</span><br><span class="line">        <span class="keyword">int</span> l = vec1.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">min</span>(k, l); i++) &#123;</span><br><span class="line">            q.<span class="built_in">emplace</span>(i, <span class="number">0</span>, vec1[i] + vec2[<span class="number">0</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (k-- &amp;&amp; (!q.<span class="built_in">empty</span>())) &#123;</span><br><span class="line">            <span class="keyword">auto</span> t = q.<span class="built_in">top</span>();</span><br><span class="line">            q.<span class="built_in">pop</span>();</span><br><span class="line">            ans.<span class="built_in">push_back</span>(t.sum);</span><br><span class="line">            <span class="keyword">if</span> (t.y + <span class="number">1</span> &lt; vec2.<span class="built_in">size</span>()) q.<span class="built_in">push</span>(<span class="built_in">Sum</span>(t.x, t.y + <span class="number">1</span>, vec1[t.x] + vec2[t.y + <span class="number">1</span>]));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">kthSmallest</span><span class="params">(vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; &amp;mat, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (mat.<span class="built_in">size</span>() == <span class="number">1</span>) <span class="keyword">return</span> mat[<span class="number">0</span>][k - <span class="number">1</span>];</span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">prev</span><span class="params">(mat[<span class="number">0</span>])</span></span>;</span><br><span class="line">        <span class="keyword">int</span> now = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (now &lt; mat.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            prev = <span class="built_in">move</span>(<span class="built_in">merge</span>(prev, mat[now], k));</span><br><span class="line">            now++;</span><br><span class="line">            <span class="comment">// for (int i = 0; i &lt; prev.size(); i++) printf(&quot;%d &quot;, prev[i]);</span></span><br><span class="line">            <span class="comment">// printf(&quot;\n&quot;);</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// for (int i = 0; i &lt; v.size(); i++) printf(&quot;%d &quot;, v[i]);</span></span><br><span class="line">        <span class="keyword">if</span> (prev.<span class="built_in">size</span>() &lt; k) <span class="keyword">return</span> prev[prev.<span class="built_in">size</span>() - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">return</span> prev[k - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">多路归并问题，leetcode 264, 373, 1439。</summary>
    
    
    
    <category term="Algorithm" scheme="http://aflyingsheep.github.io/categories/Algorithm/"/>
    
    
    <category term="Algorithm" scheme="http://aflyingsheep.github.io/tags/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>理解CUDA并行机制--以Reduce为例</title>
    <link href="http://aflyingsheep.github.io/2023/05/23/cpp/CUDA-reduce/"/>
    <id>http://aflyingsheep.github.io/2023/05/23/cpp/CUDA-reduce/</id>
    <published>2023-05-23T15:06:08.000Z</published>
    <updated>2023-05-24T15:31:34.067Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="cuda-reduce-optimization"><a class="markdownIt-Anchor" href="#cuda-reduce-optimization"></a> CUDA Reduce Optimization</h1><p>Start from Kernal 3: Sequential Addressing</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">__global__ <span class="keyword">void</span> <span class="title">reduce</span><span class="params">(<span class="keyword">int</span>* g_idata, <span class="keyword">int</span>* g_odata)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">extern</span> __shared__ <span class="keyword">int</span> sdata[];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> tid = threadIdx.x;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> i = blockIdx.x * blockDim.x + threadIdx.x;</span><br><span class="line">    sdata[tid] = g_idata[i];</span><br><span class="line">    __syncthreads();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">unsigned</span> <span class="keyword">int</span> s = blockDim.x / <span class="number">2</span>; s &gt; <span class="number">0</span>; s &gt;&gt; <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (tid &lt; s) &#123;</span><br><span class="line">            sdata[tid] += sdata[tid + s];</span><br><span class="line">        &#125;</span><br><span class="line">        __syncthreads();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/image/CUDA/reduce.png" alt="reduce" /></p><p>Half of threads is idle during reduce, so we want to halve the number of blocks and replace single load like this(kernal 4):</p><p><img src="/image/CUDA/first-add.png" alt="reduce" /></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> tid = threadIdx.x;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> i = blockIdx.x * blockDim.x * <span class="number">2</span> + threadIdx.x;</span><br><span class="line">sdata[tid] = g_idata[i] + g_idata[i + blockDim.x];</span><br><span class="line">__syncthreads();</span><br></pre></td></tr></table></figure><p>Instructions are SIMD synchronous within a warp, so when s &lt;= 32, we can unroll the last warp(kernal 5):</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">__device__ <span class="keyword">void</span> <span class="title">warpReduce</span><span class="params">(<span class="keyword">volatile</span> <span class="keyword">int</span>* sdata, <span class="keyword">int</span> tid)</span> </span>&#123;</span><br><span class="line">    sdata[tid] += sdata[tid + <span class="number">32</span>]; </span><br><span class="line">    sdata[tid] += sdata[tid + <span class="number">16</span>]; </span><br><span class="line">    sdata[tid] += sdata[tid + <span class="number">8</span>]; </span><br><span class="line">    sdata[tid] += sdata[tid + <span class="number">4</span>]; </span><br><span class="line">    sdata[tid] += sdata[tid + <span class="number">2</span>]; </span><br><span class="line">    sdata[tid] += sdata[tid + <span class="number">1</span>]; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">unsigned</span> <span class="keyword">int</span> s=blockDim.x/<span class="number">2</span>; s&gt;<span class="number">32</span>; s&gt;&gt;=<span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (tid &lt; s)</span><br><span class="line">    sdata[tid] += sdata[tid + s];</span><br><span class="line">    __syncthreads();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (tid &lt; <span class="number">32</span>) <span class="built_in">warpReduce</span>(sdata, tid);</span><br></pre></td></tr></table></figure><p>it uses the mechanism of warp, we will talk about it in the next chapter.</p><p>When we consider the blockSize, we know that the max number of threads is 1024. So we can completely unroll the loop when compiling. (Using template is a trick to ensure the num of threads.)(kernel 6)</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">unsigned</span> <span class="keyword">int</span> blockSize&gt;</span><br><span class="line"><span class="function">__global__ <span class="keyword">void</span> <span class="title">reduce</span><span class="params">(<span class="keyword">int</span>* g_idata, <span class="keyword">int</span>* g_odata)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">extern</span> __shared__ <span class="keyword">int</span> sdata[];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> tid = threadIdx.x;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> i = blockIdx.x * blockDim.x * <span class="number">2</span> + threadIdx.x;</span><br><span class="line">    sdata[tid] = g_idata[i] + g_idata[i + blockDim.x];</span><br><span class="line">    __syncthreads();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (blockSize &gt;= <span class="number">1024</span>)  &#123;</span><br><span class="line">        <span class="keyword">if</span> (tid &lt; <span class="number">512</span>) &#123;</span><br><span class="line">            sdata[tid] += sdata[tid + <span class="number">512</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        __syncthreads();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (blockSize &gt;= <span class="number">512</span>)  &#123;</span><br><span class="line">        <span class="keyword">if</span> (tid &lt; <span class="number">256</span>) &#123;</span><br><span class="line">            sdata[tid] += sdata[tid + <span class="number">256</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        __syncthreads();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (blockSize &gt;= <span class="number">256</span>)  &#123;</span><br><span class="line">        <span class="keyword">if</span> (tid &lt; <span class="number">128</span>) &#123;</span><br><span class="line">            sdata[tid] += sdata[tid + <span class="number">128</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        __syncthreads();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (blockSize &gt;= <span class="number">128</span>)  &#123;</span><br><span class="line">        <span class="keyword">if</span> (tid &lt; <span class="number">64</span>) &#123;</span><br><span class="line">            sdata[tid] += sdata[tid + <span class="number">64</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        __syncthreads();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// if blockSize == 64 or less, we can use warp to reduce computation.</span></span><br><span class="line">    <span class="keyword">if</span> (tid &lt; <span class="number">32</span>) &#123;</span><br><span class="line">        warpRuduce&lt;blockSize&gt;(sdata, tid);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (tid == <span class="number">0</span>) g_odata[blockIdx.x] = sdata[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="grid-block-thread-and-warp-in-cuda"><a class="markdownIt-Anchor" href="#grid-block-thread-and-warp-in-cuda"></a> Grid, block, thread and warp in CUDA</h1><p>From a hardware perspective:</p><ol><li>SP(streaming processor): CUDA core. A thread executes on a SP.</li><li>SM(streaming multiprocessor): One SM has multiple SPs and has SFU, shared memory, register file and <strong>warp scheduler</strong>.</li></ol><p>Form a software perspective:</p><ol><li><p>thread: a CUDA program has been executed with many threads.</p></li><li><p>block: many threads are grouped into a block. Threads in the same block can call __syncthreads() to synchronize, also, they can use shared_memory to communicate.</p></li><li><p>grid: many blocks are grouped into a grid.</p><p><img src="/image/CUDA/1.png" alt="example" /></p></li></ol><h2 id="warp"><a class="markdownIt-Anchor" href="#warp"></a> Warp:</h2><p>SPs in SM are divided into many groups(warps), every warp has 32 threads(SP), and SPs in the same warp work together, execute the same instuctions.</p><p>Every thread has its own register and local memory.</p><h1 id="reference"><a class="markdownIt-Anchor" href="#reference"></a> Reference</h1><p><a href="https://zhuanlan.zhihu.com/p/455866677">CUDA编程：深入理解GPU中的并行机制（八） - 知乎 (zhihu.com)</a></p><p><a href="https://zhuanlan.zhihu.com/p/123170285">理解CUDA中的thread,block,grid和warp - 知乎 (zhihu.com)</a></p><p><a href="https://zhuanlan.zhihu.com/p/365581043">CUDA 学习（一）Reduction - 知乎 (zhihu.com)</a></p><p><a href="https://blog.csdn.net/Kevyn7/article/details/115899559">GPU概念：Thread, Block, Grid, Warp, SP, SM_gpu wrap_Kevyn7的博客-CSDN博客</a></p>]]></content>
    
    
    <summary type="html">CUDA Sample给出优化Reduce的七步方法，其中通过循环展开理解Warp与SIMD概念。</summary>
    
    
    
    <category term="CS" scheme="http://aflyingsheep.github.io/categories/CS/"/>
    
    <category term="C/C++" scheme="http://aflyingsheep.github.io/categories/C-C/"/>
    
    <category term="CUDA" scheme="http://aflyingsheep.github.io/categories/CUDA/"/>
    
    
    <category term="CS" scheme="http://aflyingsheep.github.io/tags/CS/"/>
    
    <category term="C/C++" scheme="http://aflyingsheep.github.io/tags/C-C/"/>
    
    <category term="CUDA" scheme="http://aflyingsheep.github.io/tags/CUDA/"/>
    
  </entry>
  
  <entry>
    <title>CUDA快速入门</title>
    <link href="http://aflyingsheep.github.io/2023/05/23/cpp/CUDA/"/>
    <id>http://aflyingsheep.github.io/2023/05/23/cpp/CUDA/</id>
    <published>2023-05-23T14:06:06.000Z</published>
    <updated>2023-05-23T14:19:11.023Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="example-about-vector-multiplication-and-reduce"><a class="markdownIt-Anchor" href="#example-about-vector-multiplication-and-reduce"></a> Example about vector multiplication and reduce</h1><img src="/image/CUDA/1.png" alt="image-20230523221635232" style="zoom:50%;" /><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// main.cu</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;kernel.cuh&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">cudaError_t <span class="title">addWithCuda</span><span class="params">(<span class="keyword">int</span> *c, <span class="keyword">const</span> <span class="keyword">int</span> *a, <span class="keyword">const</span> <span class="keyword">int</span> *b, <span class="keyword">unsigned</span> <span class="keyword">int</span> size)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">__global__ <span class="keyword">void</span> <span class="title">addKernel</span><span class="params">(<span class="keyword">int</span> *c, <span class="keyword">const</span> <span class="keyword">int</span> *a, <span class="keyword">const</span> <span class="keyword">int</span> *b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = threadIdx.x;</span><br><span class="line">    c[i] = a[i] + b[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> blocksPerGrid = <span class="built_in">imin</span>(<span class="number">32</span>, (N + threadsPerBlock - <span class="number">1</span>) / threadsPerBlock);</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">float_equal</span><span class="params">(<span class="keyword">float</span> a, <span class="keyword">float</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (std::<span class="built_in">abs</span>(a - b) &lt; <span class="number">1e1</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">float</span>* a, * b, c = <span class="number">0</span>, * partial_c;</span><br><span class="line">    <span class="keyword">float</span>* dev_a, * dev_b, * dev_partial_c;</span><br><span class="line"></span><br><span class="line">    a = <span class="keyword">new</span> <span class="keyword">float</span>[N];</span><br><span class="line">    b = <span class="keyword">new</span> <span class="keyword">float</span>[N];</span><br><span class="line">    partial_c = <span class="keyword">new</span> <span class="keyword">float</span>[blocksPerGrid];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cudaMalloc</span>((<span class="keyword">void</span>**)&amp;dev_a, N * <span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">float</span>));</span><br><span class="line">    <span class="built_in">cudaMalloc</span>((<span class="keyword">void</span>**)&amp;dev_b, N * <span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">float</span>));</span><br><span class="line">    <span class="built_in">cudaMalloc</span>((<span class="keyword">void</span>**)&amp;dev_partial_c, blocksPerGrid * <span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">float</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">        a[i] = i;</span><br><span class="line">        b[i] = i * <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cudaMemcpy</span>(dev_a, a, N * <span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">float</span>), cudaMemcpyHostToDevice);</span><br><span class="line">    <span class="built_in">cudaMemcpy</span>(dev_b, b, N * <span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">float</span>), cudaMemcpyHostToDevice);</span><br><span class="line">    </span><br><span class="line">    vector_add &lt;&lt; &lt;blocksPerGrid, threadsPerBlock &gt;&gt; &gt; (dev_a, dev_b, dev_partial_c);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cudaMemcpy</span>(partial_c, dev_partial_c, blocksPerGrid * <span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">float</span>), cudaMemcpyDeviceToHost);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; blocksPerGrid; i++) &#123;</span><br><span class="line">        c += partial_c[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// CPU serial</span></span><br><span class="line">    <span class="keyword">double</span> result = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">float</span>* res_p = <span class="keyword">new</span> <span class="keyword">float</span>[blocksPerGrid];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i == <span class="number">368</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">float</span> temp = a[i] * b[i];</span><br><span class="line">        result = result + temp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; blocksPerGrid; i++) &#123;</span><br><span class="line">        res_p[i] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; threadsPerBlock; j++) &#123;</span><br><span class="line">            res_p[i] += a[i * threadsPerBlock + j] * b[i * threadsPerBlock + j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">float_equal</span>(result, c)) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Test pass.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Test error. CPU: &quot;</span> &lt;&lt; result &lt;&lt; <span class="string">&quot;, GPU: &quot;</span> &lt;&lt; c &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cudaFree</span>(dev_a);</span><br><span class="line">    <span class="built_in">cudaFree</span>(dev_b);</span><br><span class="line">    <span class="built_in">cudaFree</span>(dev_partial_c);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">free</span>(a);</span><br><span class="line">    <span class="built_in">free</span>(b);</span><br><span class="line">    <span class="built_in">free</span>(partial_c);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// kernel.cuh</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> _KERNEL_CUH_</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _KERNEL_CUH_</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;cuda_runtime.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;device_launch_parameters.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> imin(a,b) (a&lt;b?a:b)</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> threadsPerBlock = <span class="number">256</span>;</span><br><span class="line"><span class="comment">//const int N = 1 * 1024;</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">33</span> * <span class="number">1024</span>;</span><br><span class="line"></span><br><span class="line"><span class="function">__global__ <span class="keyword">void</span> <span class="title">vector_add</span><span class="params">(<span class="keyword">float</span>* a, <span class="keyword">float</span>* b, <span class="keyword">float</span>* c)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// !_KERNEL_CUH_</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// vector.cu</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;kernel.cuh&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">void</span> __syncthreads();</span><br><span class="line"></span><br><span class="line"><span class="function">__global__ <span class="keyword">void</span> <span class="title">vector_add</span><span class="params">(<span class="keyword">float</span>* a, <span class="keyword">float</span>* b, <span class="keyword">float</span>* c)</span> </span>&#123;</span><br><span class="line">__shared__ <span class="keyword">float</span> res[threadsPerBlock];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> tid = threadIdx.x + blockIdx.x * blockDim.x;</span><br><span class="line"><span class="keyword">int</span> res_idx = threadIdx.x;</span><br><span class="line"></span><br><span class="line"><span class="keyword">float</span> temp = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (tid &lt; N) &#123;</span><br><span class="line">temp += a[tid] * b[tid];</span><br><span class="line">tid += blockDim.x * gridDim.x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">res[res_idx] = temp;</span><br><span class="line">__syncthreads();</span><br><span class="line"></span><br><span class="line"><span class="comment">// reduce</span></span><br><span class="line"><span class="keyword">int</span> i = blockDim.x / <span class="number">2</span>;</span><br><span class="line"><span class="keyword">while</span> (i != <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (res_idx &lt; i) &#123;</span><br><span class="line">res[res_idx] += res[res_idx + i];</span><br><span class="line">&#125;</span><br><span class="line">__syncthreads();</span><br><span class="line">i = i / <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (res_idx == <span class="number">0</span>) &#123;</span><br><span class="line">c[blockIdx.x] = res[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">通过&quot;CUDA BY EXAMPLE&quot;快速入门CUDA</summary>
    
    
    
    <category term="CS" scheme="http://aflyingsheep.github.io/categories/CS/"/>
    
    <category term="C/C++" scheme="http://aflyingsheep.github.io/categories/C-C/"/>
    
    <category term="CUDA" scheme="http://aflyingsheep.github.io/categories/CUDA/"/>
    
    
    <category term="CS" scheme="http://aflyingsheep.github.io/tags/CS/"/>
    
    <category term="C/C++" scheme="http://aflyingsheep.github.io/tags/C-C/"/>
    
    <category term="CUDA" scheme="http://aflyingsheep.github.io/tags/CUDA/"/>
    
  </entry>
  
  <entry>
    <title>effective-c++阅读笔记</title>
    <link href="http://aflyingsheep.github.io/2023/05/23/cpp/effctive_cpp/"/>
    <id>http://aflyingsheep.github.io/2023/05/23/cpp/effctive_cpp/</id>
    <published>2023-05-23T14:06:06.000Z</published>
    <updated>2023-05-25T02:54:05.965Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="让自己习惯c"><a class="markdownIt-Anchor" href="#让自己习惯c"></a> 让自己习惯C++</h1><h2 id="条款1视-c-为一个语言联邦"><a class="markdownIt-Anchor" href="#条款1视-c-为一个语言联邦"></a> 条款1：视 C++ 为一个语言联邦</h2><ol><li>C<ins>高效编程守则视状况而变化，取决于使用C</ins>的哪个部分：<ol><li>C</li><li>Object-Oriented C++: 包括class, 封装, 继承, 多态, 虚函数动态绑定等等。</li><li>Template C++: 泛型编程，TMP(模板元编程)。</li><li>STL</li></ol></li></ol><h2 id="条款2尽量以-const-enum-inline-替换-define"><a class="markdownIt-Anchor" href="#条款2尽量以-const-enum-inline-替换-define"></a> 条款2：尽量以 const、enum、inline 替换 #define</h2><ol><li><p>当使用<code>#define PI 3.14</code> 声明一个常量(<code>#define</code>并不属于程序的一部分)时，可能未被编译器看到。解决方法便是使用<code>const  double PI = 3.14.</code>存在两种特殊情况：</p><ol><li><p>定义常量指针：常量定义式通常被放在头文件中，有必要将指针声明为<code>const</code>(而不是指针所指内容)，如：</p><p><code>const char* const authorName = &quot;Kerbal;&quot;</code></p><p>然而<code>string</code>通常比<code>char*-based</code>更合适：</p><p><code>const std::string authorName = &quot;Kerbal&quot;;</code></p></li><li><p><code>class</code>专属常量：将常量的作用域限制于class内，则必须让其成为类的成员，同时确保常量最多存在一份实体，则让其成为static成员：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GamePlayer</span>&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> NumTerns = <span class="number">5</span>; <span class="comment">// 常量声明式</span></span><br><span class="line"><span class="keyword">int</span> score[NumTerns];</span><br><span class="line">...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>只要不取地址则无需提供NumTerns的定义式。如果坚持取地址或编译器坚持看到一个定义式，则需要在<strong>实现文件</strong>中提供：<code>const int GamePlayer::NumTerns;</code>,并且定义时无需赋初值。</p></li><li><p>如果编译器不允许在声明时赋初值，则需要将初值放在定义式中。然而编译器又需要在编译期间确定数组的长度，则需要enum-hack：</p><p>还有一点好处：enum-hack不会被取地址，不会导致非必要的内存分配。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GamePlayer</span>&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="class"><span class="keyword">enum</span>&#123;</span></span><br><span class="line">NumTerns = <span class="number">5</span> <span class="comment">// 令 NumTerns 成为 5 的记号名称</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">int</span> score[NumTerns];</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></li><li><p>对于形似函数的宏，最好改用inline函数替换掉<code>#define</code></p></li></ol><h2 id="条款3尽可能使用const"><a class="markdownIt-Anchor" href="#条款3尽可能使用const"></a> 条款3：尽可能使用const</h2><ol><li><p><code>const</code>可以修饰很多东西。而对于指针的修饰，详见_____文章</p></li><li><p>对于STL的迭代器，<code>const</code>同样能够进行修饰：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> std::vector&lt;<span class="keyword">int</span>&gt;::iterator iter = vec.<span class="built_in">begin</span>();<span class="comment">// 指针不可以变化</span></span><br><span class="line">std::vector&lt;<span class="keyword">int</span>&gt;::const_iterator cIter = vec.<span class="built_in">begin</span>();<span class="comment">// 所指内容不变</span></span><br></pre></td></tr></table></figure></li><li><p>编译器强制bitwise constness，但编写程序应该使用概念上的常量性，可以使用<code>mutable</code>打破编译器的bitwise constness。</p></li><li><p>当const和non-const成员函数都有着实质等价的实现时，可以复用：</p><ol><li>先对non-const进行static_cast转换为const。</li><li>调用后使用const_cast去除const性。</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TextBlock</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>&amp; <span class="keyword">operator</span>[] (std::<span class="keyword">size_t</span> position) <span class="keyword">const</span> &#123; </span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">return</span> text[position];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">char</span>&amp; <span class="keyword">operator</span>[] (std::<span class="keyword">size_t</span> position) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">const_cast</span>&lt;<span class="keyword">char</span>&amp;&gt;(</span><br><span class="line">        <span class="keyword">static_cast</span>&lt;<span class="keyword">const</span> TextBlock&amp;&gt;(*<span class="keyword">this</span>)[position]</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol><h2 id="条款4确定对象使用前初始化"><a class="markdownIt-Anchor" href="#条款4确定对象使用前初始化"></a> 条款4：确定对象使用前初始化</h2><ol><li><p>static对象分为local static(在函数内部的static对象)与non-local static对象(其他的static)，问题是如果某个编译单元内的某个non-local static对象依赖于其他编译单元的non-local static对象，然而这个对象可能尚未初始化。</p><p>解决办法：将每个non-local static对象替换为local static对象(单例设计模式)：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// In file 1</span></span><br><span class="line"><span class="comment">// 服务器建立</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FileSystem</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="function">std::<span class="keyword">size_t</span> <span class="title">numDisk</span><span class="params">()</span><span class="keyword">const</span></span>; <span class="comment">// 成员函数</span></span><br><span class="line"><span class="comment">// ....</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">extern</span> FileSystem tfs; <span class="comment">// 准备给客户使用的对象</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// In file 2</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Directory</span> &#123;</span></span><br><span class="line">  ...  </span><br><span class="line">&#125;;</span><br><span class="line">Directory::<span class="built_in">Directory</span>(params) &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 出现问题：万一这个文件先编译，则会出现以下错误：无法解析的外部符号：class FileSystem tfs</span></span><br><span class="line">    std::<span class="keyword">size_t</span> disks = tfs.<span class="built_in">numDisk</span>();</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用local static对象替换(单例设计模式)</span></span><br><span class="line"><span class="function">FileSystem&amp; <span class="title">tfs</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> FileSystem fs;</span><br><span class="line">    <span class="keyword">return</span> fs;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Directory::<span class="built_in">Directory</span>(params) &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 保证reference指向了已经初始化的对象</span></span><br><span class="line">    std::<span class="keyword">size_t</span> disks = <span class="built_in">tfs</span>().<span class="built_in">numDisk</span>();</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>静态数据成员初始化与一般数据成员初始化不同。初始化时可以不加 static，但必须要有数据类型。被 private、protected、public 修饰的 static 成员变量都可以用这种方式初始化。静态数据成员初始化的格式为：＜数据类型＞＜类名＞::＜静态数据成员名＞=＜值＞</p><p>出现在类体外的函数定义不能指定关键字static；</p><p>一般程序的由new产生的动态数据存放在堆区，函数内部的自动变量存放在栈区，静态数据（即使是函数内部的静态局部变量）存放在全局数据区。自动变量一般会随着函数的退出而释放空间，而全局数据区的数据并不会因为函数的退出而释放空间。</p></li></ol><h1 id="构造析构赋值运算"><a class="markdownIt-Anchor" href="#构造析构赋值运算"></a> 构造/析构/赋值运算</h1><h2 id="条款5了解-c-默认编写调用的函数"><a class="markdownIt-Anchor" href="#条款5了解-c-默认编写调用的函数"></a> 条款5：了解 C++ 默认编写调用的函数</h2><ol><li>编译器产出的析构函数是个non-virtual，除非这个class的base class自身声明有virtual的析构函数。</li><li>内含reference或内含const的成员若想实现赋值动作则必须自己定义copy assignment操作符。因为C++不允许引用改指不同的对象，更改const成员同样不合法。</li><li>如果某个base classes将copy assignment操作符声明为private，则编译器拒绝为其derived classes生成copy assignment。</li></ol><h2 id="条款6若不想使用编译器自动生成的函数就该明确拒绝"><a class="markdownIt-Anchor" href="#条款6若不想使用编译器自动生成的函数就该明确拒绝"></a> 条款6：若不想使用编译器自动生成的函数，就该明确拒绝</h2><p>书中根据条款5.3编写了禁止拷贝基类，不过有点多余，用下面代码其实就可以：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DontCopyMe</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">DontCopyMe</span>();</span><br><span class="line">    <span class="built_in">DontCopyMe</span>(<span class="keyword">const</span> DontCopyMe&amp; dcm) = <span class="keyword">delete</span>;</span><br><span class="line">    DontCopyMe&amp; <span class="keyword">operator</span>= (<span class="keyword">const</span> DontCopyMe&amp; a) = <span class="keyword">delete</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="条款7为多态基类声明virtual析构函数"><a class="markdownIt-Anchor" href="#条款7为多态基类声明virtual析构函数"></a> 条款7：为多态基类声明virtual析构函数</h2><ol><li>给base classes一个virtual析构函数只适用于polymorphic base classes，这种类设计目的便是通过基类接口处理derived classes对象。</li><li>并非所有base classes设计目的是为了多态用途，这些classes不需要virtual析构函数。</li><li>polymorphic base classes应该声明一个析构函数，如果class带有任何virtual函数，它就应该拥有一个virtual析构函数。</li><li>classes的设计目的如果不是作为base class使用，或者不是为了具备polymorphically，就不该声明virtual析构函数。</li></ol><h2 id="条款8别让异常逃离析构函数"><a class="markdownIt-Anchor" href="#条款8别让异常逃离析构函数"></a> 条款8：别让异常逃离析构函数</h2><ol><li>析构函数绝对不要吐出异常，如果一个被析构函数调用的函数可能抛出异常，析构函数应该捕捉任何异常然后吞下他们 or 结束程序。</li><li>如果客户需要对某个操作函数运行期间抛出的异常作出反应，那么class需要提供一个普通函数供用户使用处理异常。</li></ol><h2 id="条款9绝不在构造和析构过程中调用virtual函数"><a class="markdownIt-Anchor" href="#条款9绝不在构造和析构过程中调用virtual函数"></a> 条款9：绝不在构造和析构过程中调用virtual函数</h2><ol><li>在derived class对象的base class构造期间，对象的类型是base class而不是derived class。于是构造过程中调用的是基类的virtual函数。</li><li>无法使用virtual函数从base classes向下调用，构造期间可以令derived classes将必要的构造信息向上传递给base class的构造函数。</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Transaction</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Transaction</span><span class="params">(<span class="keyword">const</span> std::string&amp; logInfo)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">LogTransaction</span><span class="params">(<span class="keyword">const</span> std::string&amp; logInfo)</span> <span class="keyword">const</span></span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Transaction::<span class="built_in">Transaction</span>(<span class="keyword">const</span> std::string&amp; logInfo) &#123;</span><br><span class="line">    <span class="built_in">LogTransaction</span>(logInfo);                           <span class="comment">// 更改为了非虚函数调用</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BuyTransaction</span> :</span> <span class="keyword">public</span> Transaction &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">BuyTransaction</span>(...)</span><br><span class="line">        : <span class="built_in">Transaction</span>(<span class="built_in">CreateLogString</span>(...)) &#123; ... &#125;    <span class="comment">// 将信息传递给基类构造函数</span></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">static</span> std::string <span class="title">CreateLogString</span><span class="params">(...)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="条款10令operator-返回一个reference-to-this"><a class="markdownIt-Anchor" href="#条款10令operator-返回一个reference-to-this"></a> 条款10：令operator= 返回一个reference to *this</h2><p>令赋值操作符返回一个<code>reference to *this</code>，虽然并不强制执行此条款，但为了实现连锁赋值，大部分时候应该这样做。</p><h2 id="条款11在-operator-中处理自我赋值"><a class="markdownIt-Anchor" href="#条款11在-operator-中处理自我赋值"></a> 条款11：在 operator= 中处理“自我赋值”</h2><p>自我赋值是合法的操作，但在一些情况下可能会导致意外的错误，例如在复制堆上的资源时：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Widget&amp; <span class="keyword">operator</span>+=(<span class="keyword">const</span> Widget&amp; rhs) &#123;</span><br><span class="line">    <span class="keyword">delete</span> pRes;                          <span class="comment">// 删除当前持有的资源</span></span><br><span class="line">    pRes = <span class="keyword">new</span> <span class="built_in">Resource</span>(*rhs.pRes);       <span class="comment">// 复制传入的资源</span></span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 导致访问到已删除的数据</span></span><br></pre></td></tr></table></figure><p>最简单的解决方法是在执行后续语句前先进行<strong>证同测试（Identity test）</strong>：<code>if (this == &amp;rhs) return *this;</code></p><p>还有一种取巧的做法是使用 copy and swap 技术，这种技术聪明地利用了栈空间会自动释放的特性，这样就可以通过析构函数来实现资源的释放：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Widget&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> Widget&amp; rhs) &#123;</span><br><span class="line">    Widget <span class="built_in">temp</span>(rhs);</span><br><span class="line">    std::<span class="built_in">swap</span>(*<span class="keyword">this</span>, temp);</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 或者是按值传参</span></span><br><span class="line">Widget&amp; <span class="keyword">operator</span>=(Widget rhs) &#123;</span><br><span class="line">    std::<span class="built_in">swap</span>(*<span class="keyword">this</span>, rhs);</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="条款-12复制对象时勿忘其每一个成分"><a class="markdownIt-Anchor" href="#条款-12复制对象时勿忘其每一个成分"></a> 条款 12：复制对象时勿忘其每一个成分</h2><p>决定手动实现拷贝构造函数或拷贝赋值运算符时，忘记复制任何一个成员都可能会导致意外的错误。</p><p>当使用继承时，<strong>继承自基类的成员往往容易忘记在派生类中完成复制</strong>，如果你的基类拥有拷贝构造函数和拷贝赋值运算符，应该记得调用它们：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PriorityCustomer</span> :</span> <span class="keyword">public</span> Customer &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">PriorityCustomer</span>(<span class="keyword">const</span> PriorityCustomer&amp; rhs);</span><br><span class="line">    PriorityCustomer&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> PriorityCustomer&amp; rhs);</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> priority;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">PriorityCustomer::<span class="built_in">PriorityCustomer</span>(<span class="keyword">const</span> PriorityCustomer&amp; rhs)</span><br><span class="line">    : <span class="built_in">Customer</span>(rhs),                <span class="comment">// 调用基类的拷贝构造函数</span></span><br><span class="line">      <span class="built_in">priority</span>(rhs.priority) &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">PriorityCustomer::PriorityCustomer&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> PriorityCustomer&amp; rhs) &#123;</span><br><span class="line">    Customer::<span class="keyword">operator</span>=(rhs);       <span class="comment">// 调用基类的拷贝赋值运算符</span></span><br><span class="line">    priority = rhs.priority;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意，<strong>不要尝试在拷贝构造函数中调用拷贝赋值运算符</strong>，或在拷贝赋值运算符的实现中调用拷贝构造函数，一个在初始化时，一个在初始化后，它们的功用是不同的。</p><h1 id="资源管理"><a class="markdownIt-Anchor" href="#资源管理"></a> 资源管理</h1><h2 id="条款13以对象管理资源"><a class="markdownIt-Anchor" href="#条款13以对象管理资源"></a> 条款13：以对象管理资源</h2><p>对于传统的堆资源管理，我们需要使用成对的<code>new</code>和<code>delete</code>，这样若忘记<code>delete</code>就会造成内存泄露。因此，我们应尽可能以对象管理资源，并采用<strong>RAII（Resource Acquisition Is Initialize，资源取得时机便是初始化时机）</strong>，让析构函数负责资源的释放。</p><p>注：RAII——对资源申请、释放这种成对的操作的封装，通过这种方式实现在局部作用域内申请资源然后销毁资源。</p><p>可以使用<code>std::unique_tpr</code>等智能指针。</p><h2 id="条款14在资源管理类中小心拷贝行为"><a class="markdownIt-Anchor" href="#条款14在资源管理类中小心拷贝行为"></a> 条款14：在资源管理类中小心拷贝行为</h2><p>当RAII对象被复制，会发生什么事情？</p><ol><li><p>禁止复制：见条款6。</p></li><li><p>对底层资源祭出“引用计数法”：正如<code>std::shared_ptr</code>所做的那样，每一次复制对象就使引用计数+1，每一个对象离开定义域就调用析构函数使引用计数-1，直到引用计数为0就彻底销毁资源。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Lock</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Lock</span><span class="params">(Mutex* pm)</span> : mutexPtr(pm, unlock) &#123;</span></span><br><span class="line">        <span class="built_in">lock</span>(mutexPtr.<span class="built_in">get</span>());</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::shared_ptr&lt;Mutex&gt; mutexPtr;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p>复制底层资源：在复制对象的同时复制底层资源的行为又被称作<strong>深拷贝（Deep copying）</strong>，例如在一个对象中有一个指针，那么在复制这个对象时就不能只复制指针，也要复制指针所指向的数据。</p></li><li><p>转移底层资源的所有权：和<code>std::unique_ptr</code>的行为类似，永远保持只有一个对象拥有对资源的管理权，当需要复制对象时转移资源的管理权。</p></li></ol><h2 id="条款15在资源管理类中提供对原始资源的访问"><a class="markdownIt-Anchor" href="#条款15在资源管理类中提供对原始资源的访问"></a> 条款15：在资源管理类中提供对原始资源的访问</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::unique_ptr&lt;Investment&gt; <span class="title">pInv</span><span class="params">(createInvestment())</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">daysHeld</span><span class="params">(<span class="keyword">const</span> Investment* pi)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">daysHeld</span>(pInv);<span class="comment">//COMPILE ERROR</span></span><br><span class="line"><span class="built_in">daysHeld</span>(pInv.<span class="built_in">get</span>()); <span class="comment">//OK</span></span><br></pre></td></tr></table></figure><p>当我们在设计自己的资源管理类时，也要考虑在提供对原始资源的访问时，是使用显式访问还是隐式访问的方法，还是两者皆可。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Font</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">FontHandle <span class="title">get</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> handle; &#125;       <span class="comment">// 显式转换函数</span></span><br><span class="line">    <span class="function"><span class="keyword">operator</span> <span class="title">FontHandle</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> handle; &#125;  <span class="comment">// 隐式转换函数</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    FontHandle handle;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">daysHeld</span><span class="params">(<span class="keyword">const</span> FontHandle fh)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Font font;</span><br><span class="line">    font.<span class="built_in">get</span>();<span class="comment">// 显式get</span></span><br><span class="line">    <span class="built_in">daysHeld</span>(font);<span class="comment">// 隐式get</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="条款16成对使用-new-和-delete-时要采用相同形式"><a class="markdownIt-Anchor" href="#条款16成对使用-new-和-delete-时要采用相同形式"></a> 条款16：成对使用 new 和 delete 时要采用相同形式</h2><p>使用<code>new</code>来分配单一对象，使用<code>new[]</code>来分配对象数组，必须明确它们的行为并不一致，分配对象数组时会额外在内存中记录“数组大小”，而使用<code>delete[]</code>会根据记录的数组大小多次调用析构函数，使用<code>delete</code>则仅仅只会调用一次析构函数。对于单一对象使用<code>delete[]</code>其结果也是未定义的，程序可能会读取若干内存并将其错误地解释为数组大小。</p><h2 id="条款17以独立语句将-newed-对象置入智能指针"><a class="markdownIt-Anchor" href="#条款17以独立语句将-newed-对象置入智能指针"></a> 条款17：以独立语句将 newed 对象置入智能指针</h2><p>现在使用<code>std::make_unique&lt;Class&gt;()</code>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> pUniqueInv = std::make_unique&lt;Investment&gt;();    <span class="comment">// since C++ 14</span></span><br><span class="line"><span class="keyword">auto</span> pSharedInv = std::make_shared&lt;Investment&gt;();    <span class="comment">// since C++ 11</span></span><br></pre></td></tr></table></figure><h1 id="设计与声明"><a class="markdownIt-Anchor" href="#设计与声明"></a> 设计与声明</h1><h2 id="条款18让接口容易被正确使用不易被误用"><a class="markdownIt-Anchor" href="#条款18让接口容易被正确使用不易被误用"></a> 条款18：让接口容易被正确使用，不易被误用</h2><ol><li><p>好的接口很容易被正确使用，不易被误用。你应在在你的所有接口中努力达成这些性质。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 三个参数类型相同的函数容易造成误用</span></span><br><span class="line">Data::<span class="built_in">Data</span>(<span class="keyword">int</span> month, <span class="keyword">int</span> day, <span class="keyword">int</span> year) &#123; ... &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过适当定义新的类型加以限制，降低误用的可能性</span></span><br><span class="line">Data::<span class="built_in">Data</span>(<span class="keyword">const</span> Month&amp; m, <span class="keyword">const</span> Day&amp; d, <span class="keyword">const</span> Year&amp; y) &#123; ... &#125;</span><br></pre></td></tr></table></figure></li><li><p>“促进正确使用”的办法包括接口的一致性，以及与<strong>内置类型的行为兼容</strong>。</p></li><li><p>“阻止误用”的办法包括建立新类型、限制类型上的操作，束缚对象值，以及消除客户的资源管理责任(智能指针)。</p></li><li><p>尽量使用智能指针，避免跨DLL的 new 和 delete，使用智能指针自定义删除器来解除互斥锁（mutexes）。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 实现createInvestment并使它返回一个tr1::shared_ptr，并带有删除器</span></span><br><span class="line">std::<span class="function">tr1::shared_ptr&lt;Investment&gt; <span class="title">createInvestment</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::<span class="function">tr1::shared_ptr&lt;Investment&gt; <span class="title">retVal</span><span class="params">(<span class="keyword">static_cast</span>&lt;Investment*&gt;(<span class="number">0</span>), getRidOfInvestment)</span></span>;</span><br><span class="line">    retVal = ...;<span class="comment">// 指向正确对象</span></span><br><span class="line">    <span class="keyword">return</span> retVal;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除器是一个单参数，接受类型指针，无返回值</span></span><br><span class="line"><span class="comment">// 函数式删除器</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Deleter</span><span class="params">(Connection *connection)</span></span>&#123;</span><br><span class="line">    <span class="built_in">close</span>(connection);</span><br><span class="line">    <span class="keyword">delete</span> connection;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// 新建管理连接Connection的智能指针</span></span><br><span class="line">    <span class="function">shared_ptr&lt;Connection&gt; <span class="title">sp</span><span class="params">(<span class="keyword">new</span> Connection(<span class="string">&quot;shared_ptr&quot;</span>), Deleter)</span></span>;</span><br><span class="line">    <span class="function">unique_ptr&lt;Connection, <span class="title">decltype</span><span class="params">(Deleter)</span>*&gt; <span class="title">up</span><span class="params">(<span class="keyword">new</span> Connection(<span class="string">&quot;unique_ptr&quot;</span>), Deleter)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// shared_ptr在使用的时候，只需要把函数式删除器的指针传给构造函数就行；</span></span><br><span class="line"><span class="comment">// 而unique_ptr还用增加一个模板参数decltype(Deleter)*，这是shared_ptr和shared_ptr的不同点之一</span></span><br><span class="line"><span class="comment">// （注意：unique_ptr的第二个模板参数是指针）。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 或是lambda表达式</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> DeleterLambda=[](Connection *connection)&#123;</span><br><span class="line">        <span class="built_in">close</span>(connection);</span><br><span class="line">        <span class="keyword">delete</span> connection;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">// 新建管理连接Connection的智能指针</span></span><br><span class="line">    <span class="function">shared_ptr&lt;Connection&gt; <span class="title">sp</span><span class="params">(<span class="keyword">new</span> Connection(<span class="string">&quot;shared_ptr&quot;</span>), DeleterLambda)</span></span>;</span><br><span class="line">    <span class="function">unique_ptr&lt;Connection, <span class="title">decltype</span><span class="params">(DeleterLambda)</span>&gt; <span class="title">up</span><span class="params">(<span class="keyword">new</span> Connection(<span class="string">&quot;unique_ptr&quot;</span>), DeleterLambda)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="条款19设计-class-犹如设计-type"><a class="markdownIt-Anchor" href="#条款19设计-class-犹如设计-type"></a> 条款19：设计 class 犹如设计 type</h2><p>几乎在设计每一个 class 时，都要面对如下问题：</p><ol><li><p><strong>新 type 对象应该如何被创建和销毁？</strong> 这会影响到类中构造函数、析构函数、内存分配和释放函数（<code>operator new</code>，<code>operator new[]</code>，<code>operator delete</code>，<code>operator delete[]</code>）的设计。</p></li><li><p><strong>对象的初始化和赋值该有什么样的差别？</strong> 这会影响到构造函数和拷贝赋值运算之间行为的差异。</p></li><li><p><strong>新 type 的对象如果被按值传递，意味着什么？</strong> 这会影响到拷贝构造函数的实现。</p></li><li><p><strong>什么是新 type 的合法值？</strong> 你的类中的成员函数必须对类中成员变量的值进行检查，如果不合法就要尽快解决或明确地抛出异常。</p></li><li><p><strong>你的新 type 需要配合某个继承图系吗？</strong> 你的类是否受到基类设计地束缚，是否拥有该覆写地虚函数，是否允许被继承（若不想要被继承，应该声明为<code>final</code>）。</p></li><li><p><strong>什么样的运算符和函数对此新 type 而言是合理的？</strong> 这会影响到你将为你的类声明哪些函数和重载哪些运算符。</p></li><li><p><strong>什么样的标准函数应该被驳回？</strong> 这会影响到你将哪些标准函数声明为<code>= delete</code>。</p></li><li><p><strong>谁该取用新 type 的成员？</strong> 这会影响到你将类中哪些成员设为 public，private 或 protected，也将影响到友元类和友元函数的设置。</p></li><li><p><strong>什么是新 type 的“未声明接口”？</strong> 为未声明接口提供效率、异常安全性以及资源运用上的保证，并在实现代码中加上相应的约束条件。</p></li><li><p><strong>你的新 type 有多么一般化？</strong> 如果你想要一系列新 type 家族，应该优先考虑模板类。</p></li></ol><h2 id="条款20宁以按常引用传参替换按值传参"><a class="markdownIt-Anchor" href="#条款20宁以按常引用传参替换按值传参"></a> 条款20：宁以按常引用传参替换按值传参</h2><p>当使用按值传参时，程序会调用对象的拷贝构造函数构建一个在函数内作用的局部对象，这个过程的开销可能会较为昂贵。对于任何用户自定义类型，使用按常引用传参是较为推荐的：</p><p><code>bool ValidateStudent(const Student&amp; s);</code></p><p>因为没有任何新对象被创建，这种传参方式不会调用任何构造函数或析构函数，所以效率比按值传参高得多。</p><p>使用按引用传参也可以避免<strong>对象切片（Object slicing）</strong> 的问题，参考以下例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Window</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">    <span class="function">std::string <span class="title">GetName</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Display</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WindowWithScrollBars</span> :</span> <span class="keyword">public</span> Window &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Display</span><span class="params">()</span> <span class="keyword">const</span> <span class="keyword">override</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>此处一个<code>WindowWithScrollBars</code>类继承自<code>Window</code>基类。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PrintNameAndDisplay</span><span class="params">(Window w)</span> </span>&#123;    <span class="comment">// 按值传参，会发生对象切片</span></span><br><span class="line">    std::cout &lt;&lt; w.<span class="built_in">GetName</span>();</span><br><span class="line">    w.<span class="built_in">Display</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此处在传参时，调用了基类<code>Window</code>的拷贝构造函数而非派生类的拷贝构造函数，因此在函数种使用的是一个<code>Window</code>对象，调用虚函数时也只能调用到基类的虚函数<code>Window::Display</code>。</p><p>由于按引用传递不会创建新对象，这个问题就能得到避免：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PrintNameAndDisplay</span><span class="params">(<span class="keyword">const</span> Window&amp; w)</span> </span>&#123; <span class="comment">// 参数不会被切片</span></span><br><span class="line">    std::cout &lt;&lt; w.<span class="built_in">GetName</span>();</span><br><span class="line">    w.<span class="built_in">Display</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也并非永远都使用按引用传参，对于内置类型、STL的迭代器和函数对象，我们认为使用按值传参是比较合适的。</p><h2 id="条款-21必须返回对象时别妄想返回其引用"><a class="markdownIt-Anchor" href="#条款-21必须返回对象时别妄想返回其引用"></a> 条款 21：必须返回对象时，别妄想返回其引用</h2><ol><li><p>绝不要返回pointer或reference指向一个local stack对象(会被释放导致指针悬空)，或返回reference指向一个heap-allocated对象(函数体内new，返回reference，无法delete！)，或返回pointer或reference指向一个local static对象而有可能同时需要多个这样的对象(会变成一样的！)。</p></li><li><p>尽管返回对象会调用拷贝构造函数产生开销，但这开销比起出错而言微不足道。</p></li></ol><h2 id="条款-22将成员变量声明为-private"><a class="markdownIt-Anchor" href="#条款-22将成员变量声明为-private"></a> 条款 22：将成员变量声明为 private</h2><p>出于对封装性的考虑，应该尽可能地隐藏类中的成员变量，并通过对外暴露函数接口来实现对成员变量的访问：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AcessLevels</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">GetReadOnly</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> readOnly; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">SetReadWrite</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123; readWrite = value; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">GetReadWrite</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> readWrite; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">SetWriteOnly</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123; writeOnly = value; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> noAccess;</span><br><span class="line">    <span class="keyword">int</span> readOnly;</span><br><span class="line">    <span class="keyword">int</span> readWrite;</span><br><span class="line">    <span class="keyword">int</span> writeOnly;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>通过为成员变量提供 getter 和 setter 函数，我们就能避免客户做出写入只读变量或读取只写变量这样不被允许的操作。</p><p>将成员变量隐藏在函数接口的背后，可以为“所有可能的实现”提供弹性。例如这可使得在成员变量被读或写时轻松通知其它对象，可以验证类的约束条件以及函数的提前和事后状态，可以在多线程环境中执行同步控制……</p><p><code>protected</code>和<code>public</code>一样，都不该被优先考虑。<strong>假设我们有一个public成员变量，最终取消了它，那么所有使用它的客户代码都将被破坏</strong>；假设我们有一个protected成员变量，最终取消了它，那么所有使用它的<strong>派生类都将被破坏</strong>。</p><p>综合以上讨论，在类中应当将成员变量优先声明为 private。</p><h2 id="条款23宁以非成员-非友元函数替换成员函数"><a class="markdownIt-Anchor" href="#条款23宁以非成员-非友元函数替换成员函数"></a> 条款23：宁以非成员、非友元函数替换成员函数</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WebBrowser</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">ClearCache</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">ClearHistory</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">RemoveCookies</span><span class="params">()</span></span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>如果想要一次性调用这三个函数，那么需要额外提供一个新的函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ClearEverything</span><span class="params">(WebBrowser&amp; wb)</span> </span>&#123;</span><br><span class="line">    wb.<span class="built_in">ClearCache</span>();</span><br><span class="line">    wb.<span class="built_in">ClearHistory</span>();</span><br><span class="line">    wb.<span class="built_in">RemoveCookies</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意，虽然成员函数和非成员函数都可以完成我们的目标，但此处更建议使用非成员函数，这是为了遵守一个原则：<strong>越少的代码可以访问数据，数据的封装性就越强</strong>。此处的<code>ClearEverything</code>函数仅仅是调用了<code>WebBrowser</code>的三个public成员函数，而并没有使用到<code>WebBrowser</code>内部的private成员，因此没有必要让其也拥有访问类中private成员的能力。</p><p>这个原则对于友元函数也是相同的，因为友元函数和成员函数拥有相同的权力，所以在能使用非成员函数完成任务的情况下，就不要使用友元函数和成员函数。</p><p>如果你觉得一个全局函数并不自然，也可以考虑将<code>ClearEverything</code>函数放在工具类中充当静态成员函数，或与<code>WebBrowser</code>放在同一个命名空间中：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> WebBrowserStuff &#123;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">WebBrowser</span> &#123;</span> ... &#125;;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">ClearEverything</span><span class="params">(WebBrowser&amp; wb)</span> </span>&#123; ... &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="条款-24若所有参数皆需类型转换请为此采用非成员函数"><a class="markdownIt-Anchor" href="#条款-24若所有参数皆需类型转换请为此采用非成员函数"></a> 条款 24：若所有参数皆需类型转换，请为此采用非成员函数</h2><p>现在我们手头上拥有一个<code>Rational</code>类，并且它可以和<code>int</code>隐式转换：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rational</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Rational</span>(<span class="keyword">int</span> numerator = <span class="number">0</span>, <span class="keyword">int</span> denominator = <span class="number">1</span>);</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>当然，我们需要重载乘法运算符来实现<code>Rational</code>对象之间的乘法：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rational</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">const</span> Rational <span class="keyword">operator</span>*(<span class="keyword">const</span> Rational&amp; rhs) <span class="keyword">const</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>将运算符重载放在类中是行得通的，至少对于<code>Rational</code>对象来说是如此。但当我们考虑混合运算时，就会出现一个问题：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Rational <span class="title">oneEight</span><span class="params">(<span class="number">1</span>, <span class="number">8</span>)</span></span>;</span><br><span class="line"><span class="function">Rational <span class="title">oneHalf</span><span class="params">(<span class="number">1</span>, <span class="number">2</span>)</span></span>;</span><br><span class="line">Rational result = oneHalf / oneEight;</span><br><span class="line"></span><br><span class="line">result = oneHalf * <span class="number">2</span>;    <span class="comment">// 正确</span></span><br><span class="line">result = <span class="number">2</span> * oneHalf;    <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure><p>假如将乘法运算符写成函数形式，错误的原因就一目了然了：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">result = oneHalf.<span class="keyword">operator</span>*(<span class="number">2</span>);    <span class="comment">// 正确</span></span><br><span class="line">result = <span class="number">2.</span><span class="keyword">operator</span>*(oneHalf);    <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure><p>在调用<code>operator*</code>时，<code>int</code>类型的变量会隐式转换为<code>Rational</code>对象，因此用<code>Rational</code>对象乘以<code>int</code>对象是合法的，但反过来则不是如此。</p><p>所以，为了避免这个错误，我们应当将运算符重载放在类外，作为非成员函数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Rational <span class="keyword">operator</span>*(<span class="keyword">const</span> Rational&amp; lhs, <span class="keyword">const</span> Rational&amp; rhs);</span><br></pre></td></tr></table></figure><h2 id="条款-25考虑写出一个不抛异常的swap函数"><a class="markdownIt-Anchor" href="#条款-25考虑写出一个不抛异常的swap函数"></a> 条款 25：考虑写出一个不抛异常的swap函数</h2><p>两个类：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WidgetImpl</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> a, b, c;</span><br><span class="line">    std::vector&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line">    ...;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Widget</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">Widget</span>(<span class="keyword">const</span> Widget&amp; rhs);</span><br><span class="line">    Widget&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> Widget&amp; rhs) &#123;</span><br><span class="line">        ...;</span><br><span class="line">        *pImpl = *(rhs.pImpl);<span class="comment">// 调用拷贝构造函数</span></span><br><span class="line">        ...;</span><br><span class="line">    &#125;</span><br><span class="line">    ...;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    WidgetImpl* pImpl;<span class="comment">// 指向对象内含的Widget数据</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>要置换两个Widget的对象值，我们唯一需要的就是对换pImpl指针，但swap算法并不知道。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 特化版本1：(无法编译)</span></span><br><span class="line"><span class="keyword">namespace</span> std &#123;</span><br><span class="line">    <span class="keyword">template</span>&lt;&gt;</span><br><span class="line">    <span class="keyword">void</span> swap&lt;Widget&gt; (Widget&amp; a, Widget&amp; b) &#123;</span><br><span class="line">        <span class="built_in">swap</span>(a.pImpl, b.pImpl);<span class="comment">// 私有变量无法访问</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 特化版本2：加入成员函数</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Widget</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(Wight&amp; other)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">using</span> std::swap;</span><br><span class="line">        <span class="built_in">swap</span>(pImpl, other.Impl);</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">namespace</span> std &#123;</span><br><span class="line">    <span class="keyword">template</span>&lt;&gt;</span><br><span class="line">    <span class="keyword">void</span> swap&lt;Widget&gt; (Widget&amp; a, Widget&amp; b) &#123;</span><br><span class="line">        a.<span class="built_in">swap</span>(b);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然而若<code>Widget</code>和<code>WidgetImpl</code>是类模板，情况就没有这么简单了，因为 C++ 不支持函数模板偏特化，所以只能使用重载的方式：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> std &#123;</span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function">    <span class="keyword">void</span> <span class="title">swap</span><span class="params">(Widget&lt;T&gt;&amp; a, Widget&lt;T&gt;&amp; b)</span> </span>&#123;</span><br><span class="line">        a.<span class="built_in">swap</span>(b);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但很抱歉，这种做法是被 STL 禁止的，因为这是在试图向 STL 中添加新的内容，所以我们只能退而求其次，在其它命名空间中定义新的swap函数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> WidgetStuff &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Widget</span> &#123;</span> ... &#125;;</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function">    <span class="keyword">void</span> <span class="title">swap</span><span class="params">(Widget&lt;T&gt;&amp; a, Widget&lt;T&gt;&amp; b)</span> </span>&#123;</span><br><span class="line">        a.<span class="built_in">swap</span>(b);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们希望在对自定义对象进行操作时找到正确的swap函数重载版本，这时候如果再写成<code>std::swap</code>，就会强制使用 STL 中的swap函数，无法满足我们的需求，因此需要改写成：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> std::swap;</span><br><span class="line"><span class="built_in">swap</span>(obj1, obj2);</span><br></pre></td></tr></table></figure><p>这样，C++ 名称查找法则能保证我们优先使用的是自定义的swap函数而非 STL 中的swap函数。</p><p><strong>C++名称查找法则</strong>：编译器会从使用名字的地方开始向上查找，由内向外查找各级作用域（命名空间）直到全局作用域（命名空间），找到同名的声明即停止，若最终没找到则报错。 函数匹配优先级：普通函数 &gt; 特化函数 &gt; 模板函数</p>]]></content>
    
    
    <summary type="html">阅读effective c++笔记：55个改善程序的条款。</summary>
    
    
    
    <category term="CS" scheme="http://aflyingsheep.github.io/categories/CS/"/>
    
    <category term="C/C++" scheme="http://aflyingsheep.github.io/categories/C-C/"/>
    
    
    <category term="CS" scheme="http://aflyingsheep.github.io/tags/CS/"/>
    
    <category term="C/C++" scheme="http://aflyingsheep.github.io/tags/C-C/"/>
    
  </entry>
  
  <entry>
    <title>C++：CRTP与侵入式链表的一种实现</title>
    <link href="http://aflyingsheep.github.io/2023/05/13/cpp/CRTP/"/>
    <id>http://aflyingsheep.github.io/2023/05/13/cpp/CRTP/</id>
    <published>2023-05-13T04:06:06.000Z</published>
    <updated>2023-05-24T15:37:49.592Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="介绍"><a class="markdownIt-Anchor" href="#介绍"></a> 介绍</h1><p>CRTP是Curiously Recurring Template Pattern的缩写，中文可以翻成奇异递归模板，它是通过将子类类型作为模板参数传给基类的一种模板的使用技巧。</p><h1 id="静态多态"><a class="markdownIt-Anchor" href="#静态多态"></a> 静态多态</h1><p>最近在做关于神威上基于Codelet模型实现的数据流编程相关项目，以里面的创建<code>Task</code>举例说明：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Task</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">static_cast</span>&lt;T*&gt;(<span class="keyword">this</span>)-&gt;<span class="built_in">execute</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Mytask</span> :</span> <span class="keyword">public</span> Task&lt;Mytask&gt; &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;This is my task.\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 类似于运行时系统执行</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">execute_now</span><span class="params">(Task&lt;T&gt; &amp;task)</span> </span>&#123;</span><br><span class="line">    task.<span class="built_in">execute</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span> </span>&#123;</span><br><span class="line">    Mytask mt;</span><br><span class="line">    <span class="comment">// 运行时系统运行提交的任务</span></span><br><span class="line">    <span class="built_in">execute_now</span>(mt);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>优点：CRTP使得类具有虚函数的效果，同时也没有虚函数的调用开销(查虚函数表)。</p><p>缺点：无法进行动态绑定、代码可读性降低、实例化后的code size可能变大。</p><h1 id="代码复用"><a class="markdownIt-Anchor" href="#代码复用"></a> 代码复用</h1><p>以<code>enable_shared_from_this</code>举例。如果使用智能指针管理类，在类的成员函数中需要返回对外部的<code>this</code>指针，如果直接返回，保存到外部的某个变量中，变量便并不知道什么时候可以使用(可能已经被析构)。故需要返回智能指针，让类继承自<code>enable_shared_from_this</code>并调用父类的<code>shared_from_this()</code>方法。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// source code - enable shared from this </span></span><br><span class="line"><span class="comment">// select key part</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> _<span class="title">Ty</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">enable_shared_from_this</span></span></span><br><span class="line"><span class="class">&#123;</span><span class="comment">// provide member functions that create shared_ptr to this</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function">shared_ptr&lt;_Ty&gt; <span class="title">shared_from_this</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;<span class="comment">// return shared_ptr</span></span><br><span class="line"><span class="keyword">return</span> (shared_ptr&lt;_Ty&gt;(_Wptr));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">shared_ptr&lt;<span class="keyword">const</span> _Ty&gt; <span class="title">shared_from_this</span><span class="params">()</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function"></span>&#123;<span class="comment">// return shared_ptr</span></span><br><span class="line"><span class="keyword">return</span> (shared_ptr&lt;<span class="keyword">const</span> _Ty&gt;(_Wptr));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> _<span class="title">Ty1</span>,</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> _<span class="title">Ty2</span>&gt;</span></span><br><span class="line"><span class="keyword">friend</span> <span class="keyword">void</span> _Do_enable(</span><br><span class="line">_Ty1 *,</span><br><span class="line">enable_shared_from_this&lt;_Ty2&gt;*,</span><br><span class="line">_Ref_count_base *);</span><br><span class="line">weak_ptr&lt;_Ty&gt; _Wptr;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>使用CRTP，使得每个继承它的子类都可以调用<code>shared_from_this</code>方法，并根据传入模板类型返回不同的智能指针。</p><h1 id="实例化多套基类静态变量和方法"><a class="markdownIt-Anchor" href="#实例化多套基类静态变量和方法"></a> 实例化多套基类静态变量和方法</h1><p>对于多个类含有相同的静态变量或方法，可以直接在基类进行，而无需在每个类中均定义一次：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CountClass</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">getCnt</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Cnt count: %d.\n&quot;</span>, cnt);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> cnt;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">int</span> CountClass&lt;T&gt;::cnt = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C1</span> :</span> <span class="keyword">public</span> CountClass&lt;C1&gt; &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">C1</span>() &#123;cnt++;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C2</span> :</span> <span class="keyword">public</span> CountClass&lt;C2&gt; &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">C2</span>() &#123;cnt++;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span> </span>&#123;</span><br><span class="line">    C1 c11, c12;</span><br><span class="line">    C2 c21;</span><br><span class="line">    CountClass&lt;C1&gt;::<span class="built_in">getCnt</span>();</span><br><span class="line">    CountClass&lt;C2&gt;::<span class="built_in">getCnt</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// result:</span></span><br><span class="line"><span class="comment">// Cnt count: 2.</span></span><br><span class="line"><span class="comment">// Cnt count: 1.</span></span><br></pre></td></tr></table></figure><h1 id="基于crtp实现的侵入式链表"><a class="markdownIt-Anchor" href="#基于crtp实现的侵入式链表"></a> 基于CRTP实现的侵入式链表</h1><p>没怎么看明白侵入式链表和非侵入式的区别，需要以后细细琢磨，先把CRTP弄明白了。</p><p>第一版：<code>ListNode</code>作为链表基类，使用CRTP <code>MyList</code>实现链表数据部分，<code>ListPtr</code>作为基类的内部类用于操作指向基类的指针。</p><p>缺点：没有资源释放！</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// CRTP, T -&gt; Node with data</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ListNode</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    T* _next;</span><br><span class="line">    ListNode&lt;T&gt;(T* n = <span class="literal">nullptr</span>) : _next(n) &#123;&#125;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">ListPtr</span> &#123;</span></span><br><span class="line">        T* p;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">ListPtr</span>(T* t = <span class="literal">nullptr</span>) : <span class="built_in">p</span>(t) &#123;&#125;;</span><br><span class="line">        T* <span class="keyword">operator</span>-&gt;() &#123;<span class="keyword">return</span> p;&#125;</span><br><span class="line">        ListPtr &amp;<span class="keyword">operator</span>=(ListPtr &amp;rhs) &#123;p = rhs.p;&#125;</span><br><span class="line">        <span class="keyword">template</span> &lt;<span class="keyword">typename</span> ... Args&gt;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">push_back</span><span class="params">(Args&amp;&amp; ... args)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">auto</span> *ptr = <span class="keyword">new</span> <span class="built_in">T</span>(std::forward&lt;Args&gt;(args)...);</span><br><span class="line">            ptr-&gt;_next = p-&gt;_next;</span><br><span class="line">            p-&gt;_next = ptr;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">next</span><span class="params">()</span> </span>&#123;p = p-&gt;_next;&#125;</span><br><span class="line">        <span class="function"><span class="keyword">bool</span> <span class="title">has_next</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> p-&gt;_next != <span class="literal">nullptr</span>;&#125;</span><br><span class="line">        <span class="function"><span class="keyword">bool</span> <span class="title">is_end</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> p == <span class="literal">nullptr</span>;&#125;</span><br><span class="line">        <span class="keyword">void</span> <span class="keyword">operator</span>++(<span class="keyword">int</span>) &#123;</span><br><span class="line">            <span class="built_in">next</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PairList</span> :</span> <span class="keyword">public</span> ListNode&lt;PairList&gt; &#123;</span><br><span class="line">    <span class="keyword">int</span> val1, val2;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">using</span> ptr = ListNode&lt;PairList&gt;::ListPtr;</span><br><span class="line">    <span class="built_in">PairList</span>(<span class="keyword">int</span> ival1, <span class="keyword">int</span> ival2) : <span class="built_in">val1</span>(ival1), <span class="built_in">val2</span>(ival2) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">getValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; val1 &lt;&lt; <span class="string">&quot;:&quot;</span> &lt;&lt; val2 &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> ... Args&gt;</span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">make_list</span><span class="params">(Args&amp;&amp; ... args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> ptr = <span class="keyword">typename</span> ListNode&lt;T&gt;::<span class="built_in">ListPtr</span>(<span class="keyword">new</span> <span class="built_in">T</span>(std::forward&lt;Args&gt;(args)...)); </span><br><span class="line">    <span class="keyword">return</span> ptr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    PairList::ptr p = make_list&lt;PairList&gt;(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        p.<span class="built_in">push_back</span>(i, i + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> it = p; it.<span class="built_in">has_next</span>(); it++) &#123;</span><br><span class="line">        it-&gt;<span class="built_in">getValue</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第二版：加入Unique_ptr管理内存释放。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// CRTP, T -&gt; Node with data</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ListNode</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    T* _next;</span><br><span class="line">    ListNode&lt;T&gt;(T* n = <span class="literal">nullptr</span>) : _next(n) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Unique_ListPtr</span> &#123;</span></span><br><span class="line">        T* data = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">clean</span><span class="params">(T* rhs)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (rhs-&gt;_next != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                <span class="built_in">clean</span>(rhs-&gt;_next);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">delete</span> rhs;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">Unique_ListPtr</span>(): <span class="built_in">data</span>(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line">        <span class="function"><span class="keyword">explicit</span> <span class="title">Unique_ListPtr</span><span class="params">(T* rhs)</span> : data(rhs) &#123;</span>&#125;</span><br><span class="line">        <span class="built_in">Unique_ListPtr</span>(<span class="keyword">const</span> Unique_ListPtr &amp;) = <span class="keyword">delete</span>;</span><br><span class="line">        <span class="built_in">Unique_ListPtr</span>(Unique_ListPtr &amp;&amp; rhs) &#123;</span><br><span class="line">            data = rhs.data;</span><br><span class="line">            rhs.data = <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ~<span class="built_in">Unique_ListPtr</span>() &#123;</span><br><span class="line">            <span class="keyword">if</span> (data) <span class="built_in">clean</span>(data);</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;Unique ptr clean.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        &#125;</span><br><span class="line">        Unique_ListPtr&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> Unique_ListPtr &amp;) = <span class="keyword">delete</span>;</span><br><span class="line">        <span class="keyword">void</span> <span class="keyword">operator</span>=(Unique_ListPtr &amp;rhs) &#123;</span><br><span class="line">            std::<span class="built_in">swap</span>(rhs, data);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function">T* <span class="title">get</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;<span class="keyword">return</span> data;&#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">ListPtr</span> &#123;</span></span><br><span class="line">        T* p;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">ListPtr</span>(<span class="keyword">const</span> Unique_ListPtr &amp;ul) : <span class="built_in">p</span>(ul.<span class="built_in">get</span>()) &#123;&#125;;</span><br><span class="line">        T* <span class="keyword">operator</span>-&gt;() &#123;<span class="keyword">return</span> p;&#125;</span><br><span class="line">        ListPtr &amp;<span class="keyword">operator</span>=(ListPtr &amp;rhs) &#123;p = rhs.p;&#125;</span><br><span class="line">        ListPtr &amp;<span class="keyword">operator</span>=(<span class="keyword">const</span> Unique_ListPtr &amp;rhs) &#123;p = rhs.<span class="built_in">get</span>();&#125;</span><br><span class="line">        <span class="keyword">template</span> &lt;<span class="keyword">typename</span> ... Args&gt;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">push_back</span><span class="params">(Args&amp;&amp; ... args)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">auto</span> *ptr = <span class="keyword">new</span> <span class="built_in">T</span>(std::forward&lt;Args&gt;(args)...);</span><br><span class="line">            ptr-&gt;_next = p-&gt;_next;</span><br><span class="line">            p-&gt;_next = ptr;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">next</span><span class="params">()</span> </span>&#123;p = p-&gt;_next;&#125;</span><br><span class="line">        <span class="function"><span class="keyword">bool</span> <span class="title">has_next</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> p-&gt;_next != <span class="literal">nullptr</span>;&#125;</span><br><span class="line">        <span class="function"><span class="keyword">bool</span> <span class="title">is_end</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> p == <span class="literal">nullptr</span>;&#125;</span><br><span class="line">        <span class="keyword">void</span> <span class="keyword">operator</span>++(<span class="keyword">int</span>) &#123;</span><br><span class="line">            <span class="built_in">next</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PairList</span> :</span> <span class="keyword">public</span> ListNode&lt;PairList&gt; &#123;</span><br><span class="line">    <span class="keyword">int</span> val1, val2;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">using</span> ptr = ListNode&lt;PairList&gt;::ListPtr;</span><br><span class="line">    <span class="built_in">PairList</span>(<span class="keyword">int</span> ival1, <span class="keyword">int</span> ival2) : <span class="built_in">val1</span>(ival1), <span class="built_in">val2</span>(ival2) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">getValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; val1 &lt;&lt; <span class="string">&quot;:&quot;</span> &lt;&lt; val2 &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> ... Args&gt;</span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">make_list</span><span class="params">(Args&amp;&amp; ... args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> ptr = <span class="keyword">typename</span> ListNode&lt;T&gt;::<span class="built_in">Unique_ListPtr</span>(<span class="keyword">new</span> <span class="built_in">T</span>(std::forward&lt;Args&gt;(args)...)); </span><br><span class="line">    <span class="keyword">return</span> ptr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// error: Unique ptr has been cleaned after make_list called.</span></span><br><span class="line">    <span class="comment">// PairList::ptr p = make_list&lt;PairList&gt;(1, 2);</span></span><br><span class="line">    <span class="keyword">auto</span> uni_begin = make_list&lt;PairList&gt;(<span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">    PairList::ptr p = uni_begin;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">        p.<span class="built_in">push_back</span>(i, i + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> it = p; it.<span class="built_in">has_next</span>(); it++) &#123;</span><br><span class="line">        it-&gt;<span class="built_in">getValue</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">CRTP是Curiously Recurring Template Pattern的缩写，中文可以翻成奇异递归模板，它是通过将子类类型作为模板参数传给基类的一种模板的使用技巧.</summary>
    
    
    
    <category term="CS" scheme="http://aflyingsheep.github.io/categories/CS/"/>
    
    <category term="C/C++" scheme="http://aflyingsheep.github.io/categories/C-C/"/>
    
    
    <category term="CS" scheme="http://aflyingsheep.github.io/tags/CS/"/>
    
    <category term="C/C++" scheme="http://aflyingsheep.github.io/tags/C-C/"/>
    
  </entry>
  
  <entry>
    <title>C++虚函数表的位置--从内存的角度</title>
    <link href="http://aflyingsheep.github.io/2023/04/05/cpp/virtual-table/"/>
    <id>http://aflyingsheep.github.io/2023/04/05/cpp/virtual-table/</id>
    <published>2023-04-05T03:37:06.000Z</published>
    <updated>2023-05-24T15:46:38.723Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="零成本抽象"><a class="markdownIt-Anchor" href="#零成本抽象"></a> 零成本抽象</h1><p>对于如下类，大小为4字节，也就是一个int的大小，跑这个类如同跑一个单独的int</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>类这个概念，只存在于编译时期。</p><p>也就是，我们可以写出修改类中的私有变量的代码（因为，私有这个东西，只在编译时期中存在）：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getx</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> x; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="built_in"><span class="keyword">sizeof</span></span>(A) &lt;&lt; endl;</span><br><span class="line">    A a;</span><br><span class="line">    <span class="keyword">int</span>* p = (<span class="keyword">int</span>*)&amp;a;</span><br><span class="line">    *p = <span class="number">114514</span>;</span><br><span class="line">    cout &lt;&lt; a.<span class="built_in">getx</span>() &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">输出：</span></span><br><span class="line"><span class="comment">4</span></span><br><span class="line"><span class="comment">114514</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>这个时候我们发现，<strong>函数是不占空间的</strong>。</p><p>我们写出一个继承：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> x, y;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;show&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> :</span><span class="keyword">public</span> A &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> z;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="built_in"><span class="keyword">sizeof</span></span>(A) &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="built_in"><span class="keyword">sizeof</span></span>(B) &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%p\n&quot;</span>, &amp;A::show);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%p\n&quot;</span>, &amp;B::show);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">输出：</span></span><br><span class="line"><span class="comment">8</span></span><br><span class="line"><span class="comment">12</span></span><br><span class="line"><span class="comment">00007FF75D8A152D</span></span><br><span class="line"><span class="comment">00007FF75D8A152D</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p><img src="/image/vt/1.png" alt="1" /></p><p>两个类共享一个show，这个show不会占用类的空间(全局数据区存放全局变量，静态数据和常量；所有<strong>类成员函数和非成员函数代码存放在代码区</strong>；为运行函数而分配的局部变量、函数参数、返回数据、返回地址等存放在栈区；余下的空间都被称为堆区)</p><h1 id="带有虚函数的类"><a class="markdownIt-Anchor" href="#带有虚函数的类"></a> 带有虚函数的类</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A1</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">a</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;A1 a()&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">b</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;A1 b()&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">c</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;A1 c()&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A2</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">a</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;A2 a()&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">b</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;A2 b()&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">c</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;A2 c()&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">    <span class="keyword">int</span> x, y;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>输出发现A1大小为8字节，A2大小为16字节。也就是，只要有虚函数，无论多少个，都会增加8的大小(64位系统)，说明增加了指针。</p><p>此时内存模型：</p><p><img src="/image/vt/2.png" alt="1" /></p><p>探索一下虚函数表：</p><p><img src="/image/vt/3.png" alt="1" /></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">a</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;A a()&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">b</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;A b()&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">c</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;A c()&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">    <span class="keyword">int</span> x, y;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> u64;</span><br><span class="line">    <span class="function"><span class="keyword">typedef</span> <span class="title">void</span><span class="params">(*func)</span><span class="params">()</span></span>;</span><br><span class="line">    </span><br><span class="line">    A a;</span><br><span class="line">    <span class="comment">// 指向虚函数指针</span></span><br><span class="line">    u64* p = (u64*)&amp;a;</span><br><span class="line">    <span class="comment">// 指向虚函数表</span></span><br><span class="line">    u64* arr = (u64*)*p;</span><br><span class="line">   </span><br><span class="line">    <span class="comment">// 调用虚函数</span></span><br><span class="line">    func fa = (func)arr[<span class="number">0</span>];</span><br><span class="line">    func fb = (func)arr[<span class="number">1</span>];</span><br><span class="line">    func fc = (func)arr[<span class="number">2</span>];</span><br><span class="line">    <span class="built_in">fa</span>(); <span class="built_in">fb</span>(); <span class="built_in">fc</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">输出：</span></span><br><span class="line"><span class="comment">A a()</span></span><br><span class="line"><span class="comment">A b()</span></span><br><span class="line"><span class="comment">A c()</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>对于A的实例化，虚函数指针都是指向同一块的(指向虚函数表)。</p><p>派生一个B：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> :</span><span class="keyword">public</span> A &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> z;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">b</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;B b()&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src="/image/vt/4.png" alt="1" /></p><h1 id="待补充"><a class="markdownIt-Anchor" href="#待补充"></a> 待补充</h1><p>多继承情况下对象和虚表的布局、thunk这种编译器魔法</p><h1 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结：</h1><ol><li><p>每个类,只要含有虚函数,new出来的对象就包含一个虚函数指针,指向这个类的虚函数表(这个虚函数表一个类用一张)</p></li><li><p>子类继承父类,会形成一个新的虚函数表,但是虚函数的实际地址还是用的父类的,如果子类重写了某个虚函数,那么子类的虚函数表中存放的就是重写的虚函数的地址</p></li><li><p>不同类之间可以通过强制转型调用其他类的虚函数</p></li></ol><p>注：转载自<a href="https://zhuanlan.zhihu.com/p/563418849">C++虚函数表的位置——从内存的角度 - 知乎 (zhihu.com)</a></p>]]></content>
    
    
    <summary type="html">从内存角度分析虚函数表。</summary>
    
    
    
    <category term="C++" scheme="http://aflyingsheep.github.io/categories/C/"/>
    
    
    <category term="C++" scheme="http://aflyingsheep.github.io/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>Respeaker 4-mic录制与播放</title>
    <link href="http://aflyingsheep.github.io/2023/03/01/alsa/"/>
    <id>http://aflyingsheep.github.io/2023/03/01/alsa/</id>
    <published>2023-03-01T13:55:06.000Z</published>
    <updated>2023-03-01T15:48:17.155Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="调节音量"><a class="markdownIt-Anchor" href="#调节音量"></a> 调节音量</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> alsamixer</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 使用F6选中声卡(JieLi BR17)并点回车,使用方向键↑↓调节声音大小，按ESC退出</span></span><br></pre></td></tr></table></figure><h1 id="录制"><a class="markdownIt-Anchor" href="#录制"></a> 录制</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 查看设备</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> arecord -l</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 找到BR17，查看它是哪个card。card会对应好几个device(但是BR17只有一个device)，记住所需要的device</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 录制</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> arecord --device=plughw:1,0 -f s32_LE -r 16000 -c 8 filename.wav</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 其中，--device=plughw代表使用插入的设备，后面对应的1,0代表card == 1, device == 0，所以需要根据上面的情况进行更改</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> -f代表保存的参数，使用s32_LE</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> -r代表频率，-c代表通道数</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> filename可以改为你所需要的文件名</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 点击回车开始录制，点击ctrl+c暂停录制</span></span><br></pre></td></tr></table></figure><h1 id="播放"><a class="markdownIt-Anchor" href="#播放"></a> 播放</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 查看设备</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> aplay -l</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 找到BR17，查看它是哪个card。card会对应好几个device(但是BR17只有一个device)，记住所需要的device</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 播放</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> aplay --device=plughw:1,0 -f s32_LE filename.wav</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 其中，--device=plughw代表使用插入的设备，后面对应的1,0代表card == 1, device == 0，所以需要根据上面的情况进行更改</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> -f代表播放的参数，使用s32_LE（s32_LE是一种封装，调用这个格式会自动帮你更改参数，比如波特率、大端小端等）</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> filename是录制的文件名</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 点击回车开始播放，点击ctrl+c暂停播放</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">树莓派使用Respeaker 4-mic的录制(arecord)与播放(aplay)功能。</summary>
    
    
    
    <category term="Raspberry Pi" scheme="http://aflyingsheep.github.io/categories/Raspberry-Pi/"/>
    
    
    <category term="Raspberry Pi" scheme="http://aflyingsheep.github.io/tags/Raspberry-Pi/"/>
    
  </entry>
  
  <entry>
    <title>C++11：lambda表达式</title>
    <link href="http://aflyingsheep.github.io/2023/02/28/cpp/lambda/"/>
    <id>http://aflyingsheep.github.io/2023/02/28/cpp/lambda/</id>
    <published>2023-02-28T12:06:06.000Z</published>
    <updated>2023-02-28T12:58:32.701Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="介绍"><a class="markdownIt-Anchor" href="#介绍"></a> 介绍</h1><p>lambda 来源于函数式编程的概念，也是现代编程语言的一个特点，，C# 3.5 和 Java 8 中就引入了 lambda 表达式。Lambda 表达式（Lambda Expression）是 C++11 引入的一个“语法糖”，可以方便快捷地创建一个“函数对象”。多用于在函数体内直接嵌套生成一个子函数，可以方便函数体内后续的调用。</p><p>从 C<ins>11 开始，C</ins> 有三种方式可以创建/传递一个可以被调用的对象：</p><ul><li>函数指针</li><li>仿函数(函数对象)</li><li>Lambda表达式</li></ul><h2 id="函数指针"><a class="markdownIt-Anchor" href="#函数指针"></a> 函数指针</h2><p>函数指针是从 C 语言继承下来的东西，比较原始，功能也比较弱：</p><ol><li>无法直接捕获当前的一些状态，所有外部状态只能通过参数传递（不考虑在函数内部使用 static 变量）。</li><li>使用函数指针的调用无法 inline（编译期无法确定这个指针会被赋上什么值）。</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 一个指向有两个整型参数，返回值为整型参数的函数指针类型</span></span><br><span class="line"><span class="built_in"><span class="keyword">int</span></span> (*)(<span class="keyword">int</span>, <span class="keyword">int</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通常我们用 typedef 来定义函数指针类型的别名方便使用</span></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">int</span> <span class="params">(*Plus)</span><span class="params">(<span class="keyword">int</span>, <span class="keyword">int</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从 C++11 开始，更推荐使用 using 来定义别名</span></span><br><span class="line"><span class="keyword">using</span> Plus = <span class="built_in"><span class="keyword">int</span></span> (*)(<span class="keyword">int</span>, <span class="keyword">int</span>);</span><br></pre></td></tr></table></figure><h2 id="仿函数"><a class="markdownIt-Anchor" href="#仿函数"></a> 仿函数</h2><p>仿函数其实就是让一个类（class/struct）的对象的使用看上去像一个函数，具体实现就是在类中实现 operator()。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Plus</span> &#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">  &#125;   </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Plus plus; </span><br><span class="line">std::cout &lt;&lt; <span class="built_in">plus</span>(<span class="number">11</span>, <span class="number">22</span>) &lt;&lt; std::endl;   <span class="comment">// 输出 33</span></span><br></pre></td></tr></table></figure><p>相比函数指针，仿函数对象可通过成员变量来捕获/传递一些状态。缺点就是，写起来很麻烦。</p><h2 id="lambda表达式"><a class="markdownIt-Anchor" href="#lambda表达式"></a> Lambda表达式</h2><p>Lambda 表达式在表达能力上和仿函数是等价的。编译器一般也是通过自动生成类似仿函数的代码来实现 Lambda 表达式的。上面的例子，用 Lambda 改写如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> plus = [](<span class="keyword">int</span> a, <span class="keyword">int</span> b) -&gt; <span class="keyword">int</span> &#123; <span class="keyword">return</span> a + b &#125;;</span><br></pre></td></tr></table></figure><h1 id="lambda-表达式的概念和基本用法"><a class="markdownIt-Anchor" href="#lambda-表达式的概念和基本用法"></a> lambda 表达式的概念和基本用法</h1><p>lambda 表达式定义了一个匿名函数，并且可以捕获一定范围内的变量。lambda 表达式的语法形式可简单归纳如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[ capture-list ] ( params ) opt -&gt; ret &#123; body; &#125;;</span><br></pre></td></tr></table></figure><ul><li>opt: 函数声明选项，包括<code>mutable/exception/attribute</code></li><li>mutable：仅当 lambda 表达式是 mutable 时，才允许修改按值捕获的参数。</li><li>exception：异常标识。</li><li>attribute：属性标识。</li></ul><p>lambda 表达式的捕获，其实就是将局部自动变量保存到 lambda 表达式内部。</p><p><strong>lambda 表达式不能捕获全局变量或 static 变量</strong>。</p><p>举例而言，一个完整的 lambda 表达式看起来像这样：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> f = [](<span class="keyword">int</span> a) -&gt; <span class="keyword">int</span> &#123; <span class="keyword">return</span> a + <span class="number">1</span>; &#125;;</span><br><span class="line">std::cout &lt;&lt; <span class="built_in">f</span>(<span class="number">1</span>) &lt;&lt; std::endl;  <span class="comment">// 输出: 2</span></span><br></pre></td></tr></table></figure><p>上面通过一行代码定义了一个小小的功能闭包，用来将输入加 1 并返回。</p><p>C++11 中允许省略 lambda 表达式的返回值定义，这样编译器就会根据 return 语句自动推导出返回值类型：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> f = [](<span class="keyword">int</span> a)&#123; <span class="keyword">return</span> a + <span class="number">1</span>; &#125;;</span><br></pre></td></tr></table></figure><p>需要注意的是，初始化列表不能用于返回值的自动推导：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> x1 = [](<span class="keyword">int</span> i)&#123; <span class="keyword">return</span> i; &#125;;  <span class="comment">// OK: return type is int</span></span><br><span class="line"><span class="keyword">auto</span> x2 = []()&#123; <span class="keyword">return</span> &#123; <span class="number">1</span>, <span class="number">2</span> &#125;; &#125;;  <span class="comment">// error: 无法推导出返回值类型</span></span><br></pre></td></tr></table></figure><p>这时我们需要显式给出具体的返回值类型。</p><p>另外，lambda 表达式在没有参数列表时，参数列表是可以省略的。因此像下面的写法都是正确的：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> f1 = []()&#123; <span class="keyword">return</span> <span class="number">1</span>; &#125;;</span><br><span class="line"><span class="keyword">auto</span> f2 = []&#123; <span class="keyword">return</span> <span class="number">1</span>; &#125;;  <span class="comment">// 省略空参数表</span></span><br></pre></td></tr></table></figure><h1 id="使用-lambda-表达式捕获列表"><a class="markdownIt-Anchor" href="#使用-lambda-表达式捕获列表"></a> 使用 lambda 表达式捕获列表</h1><ul><li>[] 不捕获任何变量。</li><li>[&amp;] 捕获外部作用域中所有变量，并作为引用在函数体中使用（按引用捕获）。</li><li>[=] 捕获外部作用域中所有变量，并作为副本在函数体中使用（按值捕获）。</li><li>[=，&amp;foo] 按值捕获外部作用域中所有变量，并按引用捕获 foo 变量。</li><li>[bar] 按值捕获 bar 变量，同时不捕获其他变量。</li><li>[this] 捕获当前类中的 this 指针，让 lambda 表达式拥有和当前类成员函数同样的访问权限。如果已经使用了 &amp; 或者 =，就默认添加此选项。捕获 this 的目的是可以在 lamda 中使用当前类的成员函数和成员变量。this 指针只能按值捕获 [this] ，不能按引用捕获 [&amp;this] 。</li></ul><p>具体用法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> i_ = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> x1 = []&#123; <span class="keyword">return</span> i_; &#125;;                    <span class="comment">// error，没有捕获外部变量</span></span><br><span class="line">        <span class="keyword">auto</span> x2 = [=]&#123; <span class="keyword">return</span> i_ + x + y; &#125;;           <span class="comment">// OK，捕获所有外部变量</span></span><br><span class="line">        <span class="keyword">auto</span> x3 = [&amp;]&#123; <span class="keyword">return</span> i_ + x + y; &#125;;           <span class="comment">// OK，捕获所有外部变量</span></span><br><span class="line">        <span class="keyword">auto</span> x4 = [<span class="keyword">this</span>]&#123; <span class="keyword">return</span> i_; &#125;;                <span class="comment">// OK，捕获this指针</span></span><br><span class="line">        <span class="keyword">auto</span> x5 = [<span class="keyword">this</span>]&#123; <span class="keyword">return</span> i_ + x + y; &#125;;        <span class="comment">// error，没有捕获x、y</span></span><br><span class="line">        <span class="keyword">auto</span> x6 = [<span class="keyword">this</span>, x, y]&#123; <span class="keyword">return</span> i_ + x + y; &#125;;  <span class="comment">// OK，捕获this指针、x、y</span></span><br><span class="line">        <span class="keyword">auto</span> x7 = [<span class="keyword">this</span>]&#123; <span class="keyword">return</span> i_++; &#125;;              <span class="comment">// OK，捕获this指针，并修改成员的值</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">int</span> a = <span class="number">0</span>, b = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">auto</span> f1 = []&#123; <span class="keyword">return</span> a; &#125;;               <span class="comment">// error，没有捕获外部变量</span></span><br><span class="line"><span class="keyword">auto</span> f2 = [&amp;]&#123; <span class="keyword">return</span> a++; &#125;;            <span class="comment">// OK，捕获所有外部变量，并对a执行自加运算</span></span><br><span class="line"><span class="keyword">auto</span> f3 = [=]&#123; <span class="keyword">return</span> a; &#125;;              <span class="comment">// OK，捕获所有外部变量，并返回a</span></span><br><span class="line"><span class="keyword">auto</span> f4 = [=]&#123; <span class="keyword">return</span> a++; &#125;;            <span class="comment">// error，a是以复制方式捕获的，无法修改</span></span><br><span class="line"><span class="keyword">auto</span> f5 = [a]&#123; <span class="keyword">return</span> a + b; &#125;;          <span class="comment">// error，没有捕获变量b</span></span><br><span class="line"><span class="keyword">auto</span> f6 = [a, &amp;b]&#123; <span class="keyword">return</span> a + (b++); &#125;;  <span class="comment">// OK，捕获a和b的引用，并对b做自加运算</span></span><br><span class="line"><span class="keyword">auto</span> f7 = [=, &amp;b]&#123; <span class="keyword">return</span> a + (b++); &#125;;  <span class="comment">// OK，捕获所有外部变量和b的引用，并对b做自加运算</span></span><br></pre></td></tr></table></figure><p>需要注意的是，默认状态下 lambda 表达式无法修改通过复制方式捕获的外部变量。如果希望修改这些变量的话，我们需要使用引用方式进行捕获。</p><p>一个容易出错的细节是关于 lambda 表达式的延迟调用的：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">auto</span> f = [=]&#123; <span class="keyword">return</span> a; &#125;;      <span class="comment">// 按值捕获外部变量</span></span><br><span class="line">a += <span class="number">1</span>;                         <span class="comment">// a被修改了</span></span><br><span class="line">std::cout &lt;&lt; <span class="built_in">f</span>() &lt;&lt; std::endl;  <span class="comment">// 输出？</span></span><br></pre></td></tr></table></figure><p>在这个例子中，lambda 表达式按值捕获了所有外部变量。在捕获的一瞬间，a 的值就已经被复制到f中了。之后 a 被修改，但此时 f 中存储的 a 仍然还是捕获时的值，因此，最终输出结果是 0。</p><p>如果希望 lambda 表达式在调用时能够即时访问外部变量，我们应当使用引用方式捕获。</p><p>从上面的例子中我们知道，按值捕获得到的外部变量值是在 lambda 表达式定义时的值。此时所有外部变量均被复制了一份存储在 lambda 表达式变量中。此时虽然修改 lambda 表达式中的这些外部变量并不会真正影响到外部，我们却仍然<strong>无法修改它们</strong>。</p><p>那么如果希望去<strong>修改按值捕获的外部变量</strong>应当怎么办呢？这时，需要显式指明 lambda 表达式为 mutable：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">auto</span> f1 = [=]&#123; <span class="keyword">return</span> a++; &#125;;             <span class="comment">// error，修改按值捕获的外部变量</span></span><br><span class="line"><span class="keyword">auto</span> f2 = [=]() <span class="keyword">mutable</span> &#123; <span class="keyword">return</span> a++; &#125;;  <span class="comment">// OK，mutable</span></span><br></pre></td></tr></table></figure><p>需要注意的一点是，被 mutable 修饰的 lambda 表达式就算没有参数也要写明参数列表。</p><h1 id="lambda表达式类型"><a class="markdownIt-Anchor" href="#lambda表达式类型"></a> lambda表达式类型</h1><p>lambda 表达式的类型在 C++11 中被称为“闭包类型（Closure Type）”。它是一个特殊的，匿名的非 nunion 的类类型。我们可以认为它是一个带有 operator() 的类，即仿函数。因此，我们可以使用 std::function 和 std::bind 来存储和操作 lambda 表达式：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">std::function&lt;<span class="built_in"><span class="keyword">int</span></span>(<span class="keyword">int</span>)&gt; f1 = [](<span class="keyword">int</span> a) &#123; <span class="keyword">return</span> a; &#125;;</span><br><span class="line">std::function&lt;<span class="built_in"><span class="keyword">int</span></span>(<span class="keyword">void</span>)&gt; f2 = std::<span class="built_in">bind</span>([](<span class="keyword">int</span> a)&#123; <span class="keyword">return</span> a; &#125;, <span class="number">123</span>);</span><br></pre></td></tr></table></figure><p>另外，对于没有捕获任何变量的 lambda 表达式，还可以被转换成一个普通的函数指针：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">func_t</span> = <span class="built_in"><span class="keyword">int</span></span>(*)(<span class="keyword">int</span>);</span><br><span class="line"><span class="keyword">func_t</span> f = [](<span class="keyword">int</span> a)&#123; <span class="keyword">return</span> a; &#125;;</span><br><span class="line"><span class="built_in">f</span>(<span class="number">123</span>);</span><br></pre></td></tr></table></figure><p>lambda 表达式可以说是就地定义仿函数闭包的“语法糖”。它的捕获列表捕获住的任何外部变量，最终均会变为闭包类型的成员变量。而一个使用了成员变量的类的 operator()，如果能直接被转换为普通的函数指针，那么 lambda 表达式本身的 this 指针就丢失掉了。而没有捕获任何外部变量的 lambda 表达式则不存在这个问题。</p><p>这里也可以很自然地解释为何按值捕获无法修改捕获的外部变量。因为按照 C++ 标准，lambda 表达式的 operator() 默认是 const 的。一个 const 成员函数是无法修改成员变量的值的。而 mutable 的作用，就在于取消 operator() 的 const。</p><p>需要注意的是，没有捕获变量的 lambda 表达式可以直接转换为函数指针，而捕获变量的 lambda 表达式则不能转换为函数指针。看看下面的代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span><span class="params">(*Ptr)</span><span class="params">(<span class="keyword">int</span>*)</span></span>;</span><br><span class="line">Ptr p = [](<span class="keyword">int</span>* p)&#123;<span class="keyword">delete</span> p;&#125;;  <span class="comment">// 正确，没有状态的lambda（没有捕获）的lambda表达式可以直接转换为函数指针</span></span><br><span class="line">Ptr p1 = [&amp;](<span class="keyword">int</span>* p)&#123;<span class="keyword">delete</span> p;&#125;;  <span class="comment">// 错误，有状态的lambda不能直接转换为函数指针</span></span><br></pre></td></tr></table></figure><p>上面第二行代码能编译通过，而第三行代码不能编译通过，因为第三行的代码捕获了变量，不能直接转换为函数指针。</p>]]></content>
    
    
    <summary type="html">C++11——lambda表达式，是 C++11 引入的一个“语法糖”。</summary>
    
    
    
    <category term="CS" scheme="http://aflyingsheep.github.io/categories/CS/"/>
    
    <category term="C++11" scheme="http://aflyingsheep.github.io/categories/C-11/"/>
    
    
    <category term="CS" scheme="http://aflyingsheep.github.io/tags/CS/"/>
    
    <category term="C/C++" scheme="http://aflyingsheep.github.io/tags/C-C/"/>
    
    <category term="C++11" scheme="http://aflyingsheep.github.io/tags/C-11/"/>
    
  </entry>
  
  <entry>
    <title>C++11：智能指针</title>
    <link href="http://aflyingsheep.github.io/2023/02/28/cpp/ptr/"/>
    <id>http://aflyingsheep.github.io/2023/02/28/cpp/ptr/</id>
    <published>2023-02-28T04:13:06.000Z</published>
    <updated>2023-02-28T04:14:13.288Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="shared_ptr有代码存疑"><a class="markdownIt-Anchor" href="#shared_ptr有代码存疑"></a> shared_ptr(有代码存疑)</h2><p>shared_ptr使用了引用计数，每一个shared_ptr的拷贝都指向相同的内存，每次拷贝都会触发引用计数+1，每次生命周期结束析构的时候引用计数-1，在最后一个shared_ptr析构的时候，内存才会释放。</p><p>使用方法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ClassWrapper</span> &#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">ClassWrapper</span>() &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;construct&quot;</span> &lt;&lt; endl;</span><br><span class="line">        data = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">ClassWrapper</span>() &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;deconstruct&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">if</span> (data != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">delete</span>[] data;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;print&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span>* data;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Func</span><span class="params">(std::shared_ptr&lt;ClassWrapper&gt; ptr)</span> </span>&#123;</span><br><span class="line">    ptr-&gt;<span class="built_in">Print</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> smart_ptr = std::make_shared&lt;ClassWrapper&gt;();</span><br><span class="line">    <span class="keyword">auto</span> ptr2 = smart_ptr; <span class="comment">// 引用计数+1</span></span><br><span class="line">    ptr2-&gt;<span class="built_in">Print</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 函数体内部引用计数+1，执行后-1，如果函数定义为引用传参则引用计数不变</span></span><br><span class="line">    <span class="built_in">Func</span>(smart_ptr); </span><br><span class="line">    smart_ptr-&gt;<span class="built_in">Print</span>();</span><br><span class="line">    ClassWrapper *p = smart_ptr.<span class="built_in">get</span>(); <span class="comment">// 可以通过get获取裸指针</span></span><br><span class="line">    p-&gt;<span class="built_in">Print</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>智能指针还可以自定义删除器，在引用计数为0的时候自动调用删除器来释放对象的内存，代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这块有点没看懂...</span></span><br><span class="line"><span class="function">std::shared_ptr&lt;<span class="keyword">int</span>&gt; <span class="title">ptr</span><span class="params">(<span class="keyword">new</span> <span class="keyword">int</span>, [](<span class="keyword">int</span> *p)&#123; <span class="keyword">delete</span> p; &#125;)</span></span>;</span><br></pre></td></tr></table></figure><p>通过shared_from_this()返回this指针，不要把this指针作为shared_ptr返回出来，因为this指针本质就是裸指针，通过this返回可能 会导致重复析构，不能把this指针交给智能指针管理。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line">      <span class="function">shared_ptr&lt;A&gt; <span class="title">GetSelf</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">shared_from_this</span>();</span><br><span class="line">        <span class="comment">// return shared_ptr&lt;A&gt;(this); 错误，会导致double free</span></span><br><span class="line">    &#125;  </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>注意避免循环引用，可能导致内存永远不会释放，造成内存泄漏：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">A</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">B</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">A</span> &#123;</span></span><br><span class="line">    std::shared_ptr&lt;B&gt; bptr;</span><br><span class="line">    ~<span class="built_in">A</span>() &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;A delete&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">B</span> &#123;</span></span><br><span class="line">    std::shared_ptr&lt;A&gt; aptr;</span><br><span class="line">    ~<span class="built_in">B</span>() &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;B delete&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> aaptr = std::make_shared&lt;A&gt;();<span class="comment">// aaptr: 1</span></span><br><span class="line">    <span class="keyword">auto</span> bbptr = std::make_shared&lt;B&gt;();<span class="comment">// bbptr: 1</span></span><br><span class="line">    aaptr-&gt;bptr = bbptr;<span class="comment">// bbptr: 2</span></span><br><span class="line">    bbptr-&gt;aptr = aaptr;<span class="comment">// aaptr: 2</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>aptr和bptr的引用计数为2，离开作用域后aptr和bptr的引用计数-1，但是永远不会为0，导致指针永远不会析构，产生了内存泄漏，如何解决这种问题呢，答案是使用<strong>weak_ptr</strong>。</p><h2 id="weak_ptr"><a class="markdownIt-Anchor" href="#weak_ptr"></a> weak_ptr</h2><p><code>weak_ptr</code>本身也是一个模板类，但是不能直接用它来定义一个智能指针的对象，只能配合<code>shared_ptr</code>来使用，可以将<code>shared_ptr</code>的对象赋值给<code>weak_ptr</code>，并且这样并不会改变引用计数的值。查看<code>weak_ptr</code>的代码时发现，它主要有<code>lock</code>、<code>swap</code>、<code>reset</code>、<code>expired</code>、<code>operator=</code>、<code>use_count</code>几个函数，与<code>shared_ptr</code>相比多了<code>lock</code>、<code>expired</code>函数，但是却少了<code>get</code>函数，甚至连<code>operator* </code>和 <code>operator-&gt;</code>都没有，可用的函数数量少的可怜，下面通过一些例子来了解一下<code>weak_ptr</code>的具体用法。</p><ol><li><p><code>weak_ptr</code>解决<code>shared_ptr</code>循环引用的问题<br />定义两个类，每个类中又包含一个指向对方类型的智能指针作为成员变量，然后创建对象，设置完成后查看引用计数后退出，看一下测试结果：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CB</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CA</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">CA</span>() &#123; cout &lt;&lt; <span class="string">&quot;CA() called! &quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">    ~<span class="built_in">CA</span>() &#123; cout &lt;&lt; <span class="string">&quot;~CA() called! &quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">set_ptr</span><span class="params">(shared_ptr&lt;CB&gt;&amp; ptr)</span> </span>&#123; m_ptr_b = ptr; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">b_use_count</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;b use count : &quot;</span> &lt;&lt; m_ptr_b.<span class="built_in">use_count</span>() &lt;&lt; endl; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;this is class CA!&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    shared_ptr&lt;CB&gt; m_ptr_b;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CB</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">CB</span>() &#123; cout &lt;&lt; <span class="string">&quot;CB() called! &quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">    ~<span class="built_in">CB</span>() &#123; cout &lt;&lt; <span class="string">&quot;~CB() called! &quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">set_ptr</span><span class="params">(shared_ptr&lt;CA&gt;&amp; ptr)</span> </span>&#123; m_ptr_a = ptr; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">a_use_count</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;a use count : &quot;</span> &lt;&lt; m_ptr_a.<span class="built_in">use_count</span>() &lt;&lt; endl; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;this is class CB!&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    shared_ptr&lt;CA&gt; m_ptr_a;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test_refer_to_each_other</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">shared_ptr&lt;CA&gt; <span class="title">ptr_a</span><span class="params">(<span class="keyword">new</span> CA())</span></span>;</span><br><span class="line">    <span class="function">shared_ptr&lt;CB&gt; <span class="title">ptr_b</span><span class="params">(<span class="keyword">new</span> CB())</span></span>;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;a use count : &quot;</span> &lt;&lt; ptr_a.<span class="built_in">use_count</span>() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;b use count : &quot;</span> &lt;&lt; ptr_b.<span class="built_in">use_count</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    ptr_a-&gt;<span class="built_in">set_ptr</span>(ptr_b);</span><br><span class="line">    ptr_b-&gt;<span class="built_in">set_ptr</span>(ptr_a);</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;a use count : &quot;</span> &lt;&lt; ptr_a.<span class="built_in">use_count</span>() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;b use count : &quot;</span> &lt;&lt; ptr_b.<span class="built_in">use_count</span>() &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">测试结果：</span></span><br><span class="line"><span class="comment">CA() called!</span></span><br><span class="line"><span class="comment">    CB() called!</span></span><br><span class="line"><span class="comment">    a use count : 1</span></span><br><span class="line"><span class="comment">    b use count : 1</span></span><br><span class="line"><span class="comment">    a use count : 2</span></span><br><span class="line"><span class="comment">    b use count : 2</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>通过结果可以看到，最后CA和CB的对象并没有被析构，其中的引用效果如下图所示，起初定义完ptr_a和ptr_b时，只有①③两条引用，然后调用函数set_ptr后又增加了②④两条引用，当test_refer_to_each_other这个函数返回时，对象ptr_a和ptr_b被销毁，也就是①③两条引用会被断开，但是②④两条引用依然存在，每一个的引用计数都不为0，结果就导致其指向的内部对象无法析构，造成内存泄漏。</p><p><img src="/image/ptr/1.png" alt="1" /></p><p>解决这种状况的办法就是将两个类中的一个成员变量改为<code>weak_ptr</code>对象，因为<code>weak_ptr</code>不会增加引用计数，使得引用形不成环，最后就可以正常的释放内部的对象，不会造成内存泄漏，比如将<code>CB</code>中的成员变量改为<code>weak_ptr</code>对象，代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CB</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">CB</span>() &#123; cout &lt;&lt; <span class="string">&quot;CB() called! &quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">    ~<span class="built_in">CB</span>() &#123; cout &lt;&lt; <span class="string">&quot;~CB() called! &quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">set_ptr</span><span class="params">(shared_ptr&lt;CA&gt;&amp; ptr)</span> </span>&#123; m_ptr_a = ptr; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">a_use_count</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;a use count : &quot;</span> &lt;&lt; m_ptr_a.<span class="built_in">use_count</span>() &lt;&lt; endl; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;this is class CB!&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    weak_ptr&lt;CA&gt; m_ptr_a;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">测试结果：</span></span><br><span class="line"><span class="comment">CA() called!</span></span><br><span class="line"><span class="comment">    CB() called!</span></span><br><span class="line"><span class="comment">    a use count : 1</span></span><br><span class="line"><span class="comment">    b use count : 1</span></span><br><span class="line"><span class="comment">    a use count : 1</span></span><br><span class="line"><span class="comment">    b use count : 2</span></span><br><span class="line"><span class="comment">    ~CA() called!</span></span><br><span class="line"><span class="comment">    ~CB() called!</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p><img src="/image/ptr/2.png" alt="2" /></p></li><li><p>weak_ptr常用函数</p><p><code>weak_ptr</code>中只有函数<code>lock</code>和<code>expired</code>两个函数比较重要，因为它本身不会增加引用计数，所以它指向的对象可能在它用的时候已经被释放了，所以在用之前需要使用<code>expired</code>函数来检测是否过期，然后使用<code>lock</code>函数来获取其对应的<code>shared_ptr</code>对象，然后进行后续操作：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">shared_ptr&lt;CA&gt; <span class="title">ptr_a</span><span class="params">(<span class="keyword">new</span> CA())</span></span>;     <span class="comment">// 输出：CA() called!</span></span><br><span class="line">    <span class="function">shared_ptr&lt;CB&gt; <span class="title">ptr_b</span><span class="params">(<span class="keyword">new</span> CB())</span></span>;     <span class="comment">// 输出：CB() called!</span></span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;ptr_a use count : &quot;</span> &lt;&lt; ptr_a.<span class="built_in">use_count</span>() &lt;&lt; endl; <span class="comment">// 输出：ptr_a use count : 1</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;ptr_b use count : &quot;</span> &lt;&lt; ptr_b.<span class="built_in">use_count</span>() &lt;&lt; endl; <span class="comment">// 输出：ptr_b use count : 1</span></span><br><span class="line">    </span><br><span class="line">    weak_ptr&lt;CA&gt; wk_ptr_a = ptr_a;</span><br><span class="line">    weak_ptr&lt;CB&gt; wk_ptr_b = ptr_b;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!wk_ptr_a.<span class="built_in">expired</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        wk_ptr_a.<span class="built_in">lock</span>()-&gt;<span class="built_in">show</span>();        <span class="comment">// 输出：this is class CA!</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!wk_ptr_b.<span class="built_in">expired</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        wk_ptr_b.<span class="built_in">lock</span>()-&gt;<span class="built_in">show</span>();        <span class="comment">// 输出：this is class CB!</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 编译错误</span></span><br><span class="line">    <span class="comment">// 编译必须作用于相同的指针类型之间</span></span><br><span class="line">    <span class="comment">// wk_ptr_a.swap(wk_ptr_b);         // 调用交换函数</span></span><br><span class="line"></span><br><span class="line">    wk_ptr_b.<span class="built_in">reset</span>();                   <span class="comment">// 将wk_ptr_b的指向清空</span></span><br><span class="line">    <span class="keyword">if</span> (wk_ptr_b.<span class="built_in">expired</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;wk_ptr_b is invalid&quot;</span> &lt;&lt; endl;  <span class="comment">// 输出：wk_ptr_b is invalid 说明改指针已经无效</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    wk_ptr_b = ptr_b;</span><br><span class="line">    <span class="keyword">if</span> (!wk_ptr_b.<span class="built_in">expired</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        wk_ptr_b.<span class="built_in">lock</span>()-&gt;<span class="built_in">show</span>();        <span class="comment">// 输出：this is class CB! 调用赋值操作后，wk_ptr_b恢复有效</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 编译错误</span></span><br><span class="line">    <span class="comment">// 编译必须作用于相同的指针类型之间</span></span><br><span class="line">    <span class="comment">// wk_ptr_b = wk_ptr_a;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 最后输出的引用计数还是1，说明之前使用weak_ptr类型赋值，不会影响引用计数</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;ptr_a use count : &quot;</span> &lt;&lt; ptr_a.<span class="built_in">use_count</span>() &lt;&lt; endl; <span class="comment">// 输出：ptr_a use count : 1</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;ptr_b use count : &quot;</span> &lt;&lt; ptr_b.<span class="built_in">use_count</span>() &lt;&lt; endl; <span class="comment">// 输出：ptr_b use count : 1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>总结</p><ul><li>weak_ptr虽然是一个模板类，但是不能用来直接定义指向原始指针的对象。</li><li>weak_ptr接受shared_ptr类型的变量赋值，但是反过来是行不通的，需要使用lock函数。</li><li>weak_ptr设计之初就是为了服务于shared_ptr的，所以不增加引用计数就是它的核心功能。</li><li>由于不知道什么之后weak_ptr所指向的对象就会被析构掉，所以使用之前请先使用expired函数检测一下</li></ul></li></ol><h2 id="unique_ptr"><a class="markdownIt-Anchor" href="#unique_ptr"></a> unique_ptr</h2><p><code>auto_ptr</code>本身是一个模板类，那么一般情况下直接用它来定义一个智能指针的对象。不过在当前不建议使用。</p><p>operator=也就是赋值运算符，是智能指针auto_ptr最具争议的一个方法，或者说一种特性，它的种种限制完全来自于这个赋值操作，作为面向的对象中的一部分，如果把一个对象赋值给另一个对象，那么两个对象就是完全一样的，但是这一点却在auto_ptr上打破了，智能指针auto_ptr的赋值，只是移交了所有权，将内部对象的控制所有权从等号的右侧转移到左侧，等号右侧的智能指针丧失对原有内部对象的控制，如果右侧的对象不检测内部对象的有效性，就会造成程序崩溃，测试如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test5</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> <span class="function">auto_ptr&lt;Example&gt; <span class="title">ptr5</span><span class="params">(<span class="keyword">new</span> Example(<span class="number">5</span>))</span></span>;     <span class="comment">// Example: 5(输出内容)</span></span><br><span class="line"> auto_ptr&lt;Example&gt; ptr6 = ptr5;              <span class="comment">// 没有输出</span></span><br><span class="line"></span><br><span class="line"> <span class="keyword">if</span> (ptr5.<span class="built_in">get</span>())</span><br><span class="line">     cout &lt;&lt; <span class="string">&quot;ptr5 is valid&quot;</span> &lt;&lt; endl;        <span class="comment">// 没有输出，说明ptr5已经无效，如果再调用就会崩溃</span></span><br><span class="line"></span><br><span class="line"> <span class="keyword">if</span> (ptr6.<span class="built_in">get</span>())</span><br><span class="line">     cout &lt;&lt; <span class="string">&quot;ptr6 is valid&quot;</span> &lt;&lt; endl;        <span class="comment">// ptr6 is valid(输出内容)</span></span><br><span class="line"></span><br><span class="line"> ptr6-&gt;<span class="built_in">test_print</span>();                         <span class="comment">// in test print: number = 5(输出内容)</span></span><br><span class="line"> <span class="comment">//ptr5-&gt;test_print();                       // 直接崩溃 </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试auto_ptr作为参数，这是常常容易出错的情况，原因还是<code>operator=</code>的操作引起的，因为<code>auto_ptr</code>的赋值会转移控制权，所以你把<code>auto_ptr</code>的对象作为参数传递给一个函数的时候，后面再使用这个对象就会直接崩溃。</p><p>unique_ptr与auto_ptr是最像的，他设计之初就是为了替代auto_ptr，其实两者基本上没有区别，如果把auto_ptr限制一下，使其不能通过拷贝构造和赋值获得所有权，但是可以通过std::move()函数获得所有权，那基本上就变成了unique_pr，这一点通过下面的函数分析也可以看出，两者的函数基本一致。</p><p><code>unique_ptr</code>作为一个模板类，可以直接用它来定义一个智能指针的对象，例如<code>std::unique_pr&lt;Test&gt; pa(new Test);</code>，查看<code>unique_ptr</code>的代码时发现，它主要有get、release、reset、operator*、operator-&gt;、operator=、swap、operator bool、get_deleter几个函数，相比于auto_ptr常用函数来说，只多了swap、operator bool、get_deleter这三个函数，基本上没什么变化。</p><h2 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h2><ol><li>对比auto_ptr和unique_ptr后发现，unique_ptr几乎只是将auto_ptr的operator=改为std::move()函数。</li><li>现在标准库中只剩下了shared_ptr、weak_ptr和unique_ptr三个智能指针，weak_ptr是为了解决shared_ptr的循环引用问题而存在的，有其特定的使用情况，所以只剩下了shared_ptr和unique_ptr的选择，选择的标准就是看是否需要对原对象共享所有权，如果需要使用shared_ptr，如果不需要是独占所有权的使用unique_ptr。</li><li>unique_ptr并没有从根本上消除可能错误，仅仅是提高了犯错的成本，并且给出移动所有权的提示，但是在容器vector元素赋值时依然很隐晦，可能造成auto_ptr相同的错误。</li></ol>]]></content>
    
    
    <summary type="html">C++11智能指针，包括shared_ptr, weak_ptr, unique_ptr。</summary>
    
    
    
    <category term="CS" scheme="http://aflyingsheep.github.io/categories/CS/"/>
    
    <category term="C++11" scheme="http://aflyingsheep.github.io/categories/C-11/"/>
    
    
    <category term="CS" scheme="http://aflyingsheep.github.io/tags/CS/"/>
    
    <category term="C/C++" scheme="http://aflyingsheep.github.io/tags/C-C/"/>
    
    <category term="C++11" scheme="http://aflyingsheep.github.io/tags/C-11/"/>
    
  </entry>
  
  <entry>
    <title>C++11：引用折叠和完美转发(巨NB)</title>
    <link href="http://aflyingsheep.github.io/2023/02/27/cpp/forward/"/>
    <id>http://aflyingsheep.github.io/2023/02/27/cpp/forward/</id>
    <published>2023-02-27T14:55:06.000Z</published>
    <updated>2023-02-28T13:00:34.449Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="引用折叠"><a class="markdownIt-Anchor" href="#引用折叠"></a> 引用折叠</h1><p><strong>引用</strong>的意思众所周知，当我们使用某个对象的别名的时候就好像直接使用了该对象，这也就是引用的含义。在C++11中，新加入了右值的概念。所以引用的类型就有两种形式：左值引用<code>T&amp;</code>和右值引用<code>T&amp;&amp;</code>。</p><p>所谓的折叠，就是多个的意思。上面介绍引用分为左值引用和右值引用两种，那么将这两种类型进行排列组合，就有四种情况：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- 左值-左值 T&amp; &amp;</span><br><span class="line">- 左值-右值 T&amp; &amp;&amp;</span><br><span class="line">- 右值-左值 T&amp;&amp; &amp;</span><br><span class="line">- 右值-右值 T&amp;&amp; &amp;&amp;</span><br></pre></td></tr></table></figure><p>下面我们介绍引用折叠在模板中的应用：<em>完美转发</em>。在介绍完美转发之前，我们先介绍一下<em>万能引用</em>。</p><h1 id="万能引用"><a class="markdownIt-Anchor" href="#万能引用"></a> 万能引用</h1><p><strong>万能引用</strong>并不是C<ins>的语法特性，而是我们利用现有的C</ins>语法，自己实现的一个功能。因为这个功能既能接受左值类型的参数，也能接受右值类型的参数。所以叫做万能引用。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function">ReturnType <span class="title">Function</span><span class="params">(T&amp;&amp; parem)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 函数功能实现</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来，我们看一下为什么上面这个函数能<strong>万能引用</strong>不同类型的参数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;boost/type_index.hpp&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> boost::typeindex::type_id_with_cvr;  </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PrintType</span><span class="params">(T&amp;&amp; param)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 利用Boost库打印模板推导出来的 T 类型</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;T type：&quot;</span> &lt;&lt; type_id_with_cvr&lt;T&gt;().<span class="built_in">pretty_name</span>() &lt;&lt; endl; </span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 利用Boost库打印形参的类型</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;param type:&quot;</span> &lt;&lt; type_id_with_cvr&lt;<span class="keyword">decltype</span>(param)&gt;().<span class="built_in">pretty_name</span>() &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> a = <span class="number">0</span>;                              <span class="comment">// 左值</span></span><br><span class="line"><span class="built_in">PrintType</span>(a);                           <span class="comment">// 传入左值</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> &amp;lvalue_refence_a = a;              <span class="comment">// 左值引用</span></span><br><span class="line"><span class="built_in">PrintType</span>(lvalue_refence_a);            <span class="comment">// 传入左值引用</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">PrintType</span>(<span class="built_in"><span class="keyword">int</span></span>(<span class="number">2</span>));                      <span class="comment">// 传入右值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>boost库用于看到模板内参数类型。</p><p>通过上面的代码可以清楚的看到，<code>void PrintType(T&amp;&amp; param)</code>可以接受任何类型的参数。下面，我们来仔细观察并分析一下<code>main</code>函数中对<code>PrintType()</code>的各个调用结果。</p><ol><li>传入左值</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">0</span>;                              <span class="comment">// 左值</span></span><br><span class="line"><span class="built_in">PrintType</span>(a);                           <span class="comment">// 传入左值</span></span><br><span class="line"><span class="comment">/***************************************************/</span></span><br><span class="line">输出：T type      : <span class="keyword">int</span> &amp;</span><br><span class="line">      param type  : <span class="keyword">int</span> &amp;</span><br></pre></td></tr></table></figure><p>我们将T的推导类型<code>int&amp;</code>带入模板，得到实例化的类型：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PrintType</span><span class="params">(<span class="keyword">int</span>&amp; &amp;&amp; param)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注：所有的引用折叠最终都代表一个引用，要么是左值引用，要么是右值引用。规则就是：如果任一引用为左值引用，则结果为左值引用。否则（即两个都是右值引用），结果为右值引用。</p><p><strong>编译器将T推导为 int&amp; 类型。当我们用 int&amp; 替换掉 T 后，得到 int &amp; &amp;&amp;。也就是说，<code>int&amp; &amp;&amp;</code>等价于<code>int &amp;</code>。<code>void PrintType(int&amp; &amp;&amp; param)</code> == <code>void PrintType(int&amp; param)</code></strong></p><p>所以传入右值之后，函数模板推导的最终版本就是：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PrintType</span><span class="params">(<span class="keyword">int</span>&amp; param)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>剩下的几个调用结果就很明显了：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> &amp;lvalue_refence_a = a;              <span class="comment">//左值引用</span></span><br><span class="line"><span class="built_in">PrintType</span>(lvalue_refence_a);            <span class="comment">// 传入左值引用</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * T type      : int &amp;</span></span><br><span class="line"><span class="comment"> * T &amp;&amp;        : int &amp; &amp;&amp;</span></span><br><span class="line"><span class="comment"> * param type  : int &amp;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">PrintType</span>(<span class="built_in"><span class="keyword">int</span></span>(<span class="number">2</span>));                      <span class="comment">// 传入右值</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * T type      : int</span></span><br><span class="line"><span class="comment"> * T &amp;&amp;        : int &amp;&amp;</span></span><br><span class="line"><span class="comment"> * param type  : int &amp;&amp;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h1 id="完美转发"><a class="markdownIt-Anchor" href="#完美转发"></a> 完美转发</h1><p>有了万能引用。当我们既需要接收左值类型，又需要接收右值类型的时候，再也不用分开写两个重载函数了。那么，什么情况下，我们需要一个函数，既能接收左值，又能接收右值呢？</p><p>答案就是：转发的时候。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 万能引用，转发接收到的参数 param</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PrintType</span><span class="params">(T&amp;&amp; param)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">f</span>(param);  <span class="comment">// 将参数param转发给函数 void f()</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 接收左值的函数 f()</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(T &amp;)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;f(T &amp;)&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 接收右值的函数f()</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(T &amp;&amp;)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;f(T &amp;&amp;)&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> a = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">PrintType</span>(a);<span class="comment">//传入左值</span></span><br><span class="line"><span class="built_in">PrintType</span>(<span class="built_in"><span class="keyword">int</span></span>(<span class="number">0</span>));<span class="comment">//传入右值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们执行上面的代码，按照预想，在main中我们给 PrintType 分别传入一个左值和一个右值。PrintType将参数转发给 f() 函数。f()有两个重载，分别接收左值和右值。</p><p>正常的情况下,<code>PrintType(a);</code>应该打印<code>f(T&amp;)</code>,<code>PrintType(int());</code>应该打印<code>f(T&amp;&amp;)</code>。</p><p><strong>但是</strong>，真实的输出结果是</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">f</span>(T &amp;);</span><br><span class="line"><span class="built_in">f</span>(T &amp;);</span><br></pre></td></tr></table></figure><p><strong>当外部传入参数给 PrintType 函数时，param既可以被初始化为左值引用，也可以被初始化为右值引用，取决于我们传递给 PrintType 函数的实参类型。但是，当我们在函数 PrintType 内部，将param传递给另一个函数的时候，此时，param是被当作左值进行传递的。</strong> <em>应为这里的 param 是个具名的对象。我们不进行详细的探讨了。大家只需要己住，任何的函数内部，对形参的直接使用，都是按照左值进行的。</em></p><p><strong>我们可以通过一些其它的手段改变这个情况，比如使用 std::forward 。</strong></p><p>使用万能引用的时候，如果传入的实参是个<strong>右值(包括右值引用)</strong>，那么，<strong>模板类型 T 被推导为 实参的类型（没有引用属性）</strong>，如果传入实参是个左值，T被推导为左值引用。<strong>也就是说，模板中的 T 保存着传递进来的实参的信息，我们可以利用 T 的信息来强制类型转换我们的 param 使它和实参的类型一致。</strong></p><p>具体的做法就是，将模板函数<code>void PrintType(T&amp;&amp; param)</code>中对<code>f(param)</code>的调用，改为<code>f(std::forward&lt;T&gt;(param));</code>然后重新运行一下程序。输出如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">f</span>(T &amp;);</span><br><span class="line"><span class="built_in">f</span>(T &amp;&amp;);</span><br></pre></td></tr></table></figure><h2 id="完美转发原理"><a class="markdownIt-Anchor" href="#完美转发原理"></a> 完美转发原理</h2><p><code>std::forward</code>是怎么利用到 T 的信息的呢？</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *  精简了标准库的代码，在细节上可能不完全正确，但是足以让我们了解转发函数 forward 的了</span></span><br><span class="line"><span class="comment"> */</span> </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function">T&amp;&amp; <span class="title">forward</span><span class="params">(T &amp;param)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">static_cast</span>&lt;T&amp;&amp;&gt;(param);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>我们可以看到，不管T是值类型，还是左值引用，还是右值引用，T&amp;经过引用折叠，都将是左值引用类型。也就是forward 以左值引用的形式接收参数 param, 然后 通过将param进行强制类型转换 static_cast&lt;T&amp;&amp;&gt; （），最终再以一个 T&amp;&amp;返回</strong></p><ol><li><p>传入 PrintType 实参是右值类型：</p><p>根据以上的分析，可以知道T将被推导为值类型，也就是不带有引用属性，假设为 int 。那么，将T = int 带入forward。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span>&amp;&amp; <span class="title">forward</span><span class="params">(<span class="keyword">int</span> &amp;param)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&amp;&amp;&gt;(param);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>param</code>在forward内被强制类型转换为 int &amp;&amp;<em>(static_cast&lt;int&amp;&amp;&gt;(param))</em>, 然后按照int &amp;&amp; 返回，两个右值引用最终还是右值引用。最终保持了实参的右值属性，转发正确。</p></li><li><p>传入 PrintType 实参是左值类型：</p><p>根据以上的分析，可以知道T将被推导为左值引用类型，假设为int&amp;。那么，将T = int&amp; 带入forward。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span>&amp; &amp;&amp; <span class="title">forward</span><span class="params">(<span class="keyword">int</span>&amp; &amp;param)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&amp; &amp;&amp;&gt;(param);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>引用折叠一下就是：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span>&amp; <span class="title">forward</span><span class="params">(<span class="keyword">int</span>&amp; param)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&amp;&gt;(param);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>传递给 PrintType 左值，forward返回一个左值引用，保留了实参的左值属性，转发正确。</p></li></ol>]]></content>
    
    
    <summary type="html">引用折叠、万能引用和完美转发，摘录自知乎ReFantasy。</summary>
    
    
    
    <category term="CS" scheme="http://aflyingsheep.github.io/categories/CS/"/>
    
    <category term="C++11" scheme="http://aflyingsheep.github.io/categories/C-11/"/>
    
    
    <category term="CS" scheme="http://aflyingsheep.github.io/tags/CS/"/>
    
    <category term="C/C++" scheme="http://aflyingsheep.github.io/tags/C-C/"/>
    
    <category term="C++11" scheme="http://aflyingsheep.github.io/tags/C-11/"/>
    
  </entry>
  
  <entry>
    <title>C++11：新特性</title>
    <link href="http://aflyingsheep.github.io/2023/02/27/cpp/cpp11/"/>
    <id>http://aflyingsheep.github.io/2023/02/27/cpp/cpp11/</id>
    <published>2023-02-27T07:55:06.000Z</published>
    <updated>2023-02-28T13:01:56.087Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="auto-decltype"><a class="markdownIt-Anchor" href="#auto-decltype"></a> auto &amp; decltype</h1><ul><li>auto：让编译器在编译器就推导出变量的类型，可以通过=右边的类型推导出变量的类型。</li><li>decltype：相对于auto用于推导变量类型，而decltype则用于推导表达式类型，这里只用于编译器分析表达式的类型，表达式实际不会进行运算。</li></ul><ol><li><p>auto的限制：</p><ol><li>auto的使用必须马上初始化，否则无法推导出类型</li><li>auto在一行定义多个变量时，各个变量的推导不能产生二义性，否则编译失败</li><li>auto不能用作函数参数</li><li>在类中auto不能用作非静态成员变量</li><li>auto不能定义数组，可以定义指针</li><li>auto无法推导出模板参数</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">auto</span> a = i, &amp;b = i, *c = &amp;i; <span class="comment">// a是int，b是i的引用，c是i的指针，auto就相当于int</span></span><br><span class="line"><span class="keyword">auto</span> d = <span class="number">0</span>, f = <span class="number">1.0</span>; <span class="comment">// error，0和1.0类型不同，对于编译器有二义性，没法推导</span></span><br><span class="line"><span class="keyword">auto</span> e; <span class="comment">// error，使用auto必须马上初始化，否则无法推导类型</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">auto</span> value)</span> </span>&#123;&#125; <span class="comment">// error，auto不能用作函数参数</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line">    <span class="keyword">auto</span> a = <span class="number">1</span>; <span class="comment">// error，在类中auto不能用作非静态成员变量</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">auto</span> b = <span class="number">1</span>; <span class="comment">// error，这里与auto无关，正常static int b = 1也不可以</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">auto</span> c = <span class="number">1</span>; <span class="comment">// ok</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a[<span class="number">10</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">auto</span> b = a; <span class="comment">// ok</span></span><br><span class="line">    <span class="keyword">auto</span> c[<span class="number">10</span>] = a; <span class="comment">// error，auto不能定义数组，可以定义指针</span></span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; d;</span><br><span class="line">    vector&lt;<span class="keyword">auto</span>&gt; f = d; <span class="comment">// error，auto无法推导出模板参数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>auto与const, volatile</p><ol><li>在不声明为引用或指针时，auto会忽略等号右边的引用类型和cv限定</li><li>在声明为引用或者指针时，auto会保留等号右边的引用和cv属性</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">auto</span> *a = &amp;i; <span class="comment">// a是int*</span></span><br><span class="line"><span class="keyword">auto</span> &amp;b = i; <span class="comment">// b是int&amp;</span></span><br><span class="line"><span class="keyword">auto</span> c = b; <span class="comment">// c是int，忽略了引用</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">auto</span> d = i; <span class="comment">// d是const int</span></span><br><span class="line"><span class="keyword">auto</span> e = d; <span class="comment">// e是int</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">auto</span>&amp; f = e; <span class="comment">// f是const int&amp;</span></span><br><span class="line"><span class="keyword">auto</span> &amp;g = f; <span class="comment">// g是const int&amp;</span></span><br></pre></td></tr></table></figure></li><li><p>decltype: decltype则用于推导表达式类型，这里只用于编译器分析表达式的类型，表达式实际不会进行运算</p><p>若exp是左值，decltype(exp)是exp类型的左值引用。</p><p>如: <code>decltype(a += b) d = c</code>中的d即为int&amp;, 因为<code>a += b</code>是一个左值。</p></li><li><p>auto和decltype的配合使用</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> U&gt;</span></span><br><span class="line"><span class="function">return_value <span class="title">add</span><span class="params">(T t, U u)</span> </span>&#123;<span class="comment">// t和v类型不确定，无法推导出return_value类型</span></span><br><span class="line">    <span class="keyword">return</span> t + u;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> U&gt;</span></span><br><span class="line"><span class="function"><span class="title">decltype</span><span class="params">(t + u)</span> <span class="title">add</span><span class="params">(T t, U u)</span> </span>&#123; <span class="comment">// t和u尚未定义</span></span><br><span class="line">    <span class="keyword">return</span> t + u;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回类型后置的配合使用方法，为了解决函数返回值类型依赖于参数却难以确定返回值类型的问题</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> U&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">add</span><span class="params">(T t, U u)</span> -&gt; <span class="title">decltype</span><span class="params">(t + u)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> t + u;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h1 id="左值引用-右值引用-移动语义-完美转发"><a class="markdownIt-Anchor" href="#左值引用-右值引用-移动语义-完美转发"></a> 左值引用、右值引用、移动语义、完美转发</h1><p><a href="https://aflyingsheep.github.io/2023/02/27/cpp/forward/">站内推荐: 引用折叠和完美转发</a></p><p><a href="https://zhuanlan.zhihu.com/p/137662465">左值引用、右值引用、移动语义、完美转发，你知道的不知道的都在这里 - 知乎 (zhihu.com)</a></p><p>返回值优化!!!这里还没有看</p><p><a href="https://shaharmike.com/cpp/rvo/">Return Value Optimization | Shahar Mike’s Web Spot</a></p><p><a href="https://stackoverflow.com/questions/12953127/what-are-copy-elision-and-return-value-optimization">c++ - What are copy elision and return value optimization? - Stack Overflow</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 右值引用</span></span><br><span class="line"><span class="keyword">int</span> a = <span class="number">4</span>;</span><br><span class="line"><span class="keyword">int</span> &amp;&amp;b = a;<span class="comment">// error! a是左值</span></span><br><span class="line"><span class="keyword">int</span> &amp;&amp;c = std::<span class="built_in">move</span>(a);<span class="comment">// ok</span></span><br></pre></td></tr></table></figure><ol><li><p>移动语义：转移所有权，对于别人的一块资源转为自己拥有，别人不再拥有也不再使用。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 移动方法：移动构造函数</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">A</span>(A&amp;&amp; a) &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;data_ = a.data_;</span><br><span class="line">        a.data_ = <span class="literal">nullptr</span>;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;move&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> *data_;</span><br><span class="line">    <span class="keyword">int</span> size_;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// main</span></span><br><span class="line"><span class="function">A <span class="title">a</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line">A b = a;<span class="comment">// 浅拷贝</span></span><br><span class="line">A c = std::<span class="built_in">move</span>(a);<span class="comment">// 调用移动构造函数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// C++所有的STL都实现了移动语义；</span></span><br><span class="line"><span class="comment">// 移动语义仅针对于那些实现了移动构造函数的类的对象，对于那种基本类型int、float等没有任何优化作用，还是会拷贝，因为它们实现没有对应的移动构造函数。</span></span><br></pre></td></tr></table></figure></li><li><p>完美转发：可以写一个接受任意实参的函数模板，并转发到其它函数，目标函数会收到与转发函数完全相同的实参，转发函数实参是左值那目标函数实参也是左值，转发函数实参是右值那目标函数实参也是右值。</p></li></ol><h1 id="列表初始化"><a class="markdownIt-Anchor" href="#列表初始化"></a> 列表初始化</h1><p>在C++11中可以直接在变量名后面加上初始化列表来进行对象的初始化。</p><h2 id="stdinitializer_list"><a class="markdownIt-Anchor" href="#stdinitializer_list"></a> std::initializer_list</h2><p>使用STL过程中可能发现它的初始化列表可以是任意长度,使用<code>std::initializer_list</code>实现：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">CustomVec</span> &#123;</span></span><br><span class="line">    std::vector&lt;<span class="keyword">int</span>&gt; data;</span><br><span class="line">    <span class="built_in">CustomVec</span>(std::initializer_list&lt;<span class="keyword">int</span>&gt; list) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> iter = list.<span class="built_in">begin</span>(); iter != list.<span class="built_in">end</span>(); ++iter) &#123;</span><br><span class="line">            data.<span class="built_in">push_back</span>(*iter);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>注意：std::initializer_list，它可以接收任意长度的初始化列表，但是里面必须是相同类型T，或者都可以转换为T。</p><h1 id="并发待补充"><a class="markdownIt-Anchor" href="#并发待补充"></a> 并发(待补充)</h1><p>。。。</p><h1 id="智能指针"><a class="markdownIt-Anchor" href="#智能指针"></a> 智能指针</h1><p><a href="https://aflyingsheep.github.io/2023/02/28/cpp/ptr/">站内推荐：智能指针</a></p><h1 id="基于范围的for循环"><a class="markdownIt-Anchor" href="#基于范围的for循环"></a> 基于范围的for循环：</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="keyword">int</span>&gt; vec;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> iter = vec.<span class="built_in">begin</span>(); iter != vec.<span class="built_in">end</span>(); iter++) &#123; <span class="comment">// before c++11</span></span><br><span class="line">    cout &lt;&lt; *iter &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i : vec) &#123; <span class="comment">// c++11基于范围的for循环</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;i&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="委托构造函数"><a class="markdownIt-Anchor" href="#委托构造函数"></a> 委托构造函数</h1><p>委托构造函数允许在同一个类中一个构造函数调用另外一个构造函数，可以在变量初始化时简化操作。</p><p>注意委托环！！！</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">A</span> &#123;</span></span><br><span class="line">    <span class="built_in">A</span>()&#123;&#125;</span><br><span class="line">    <span class="built_in">A</span>(<span class="keyword">int</span> a) &#123; a_ = a; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">A</span>(<span class="keyword">int</span> a, <span class="keyword">int</span> b) : <span class="built_in">A</span>(a) &#123; b_ = b; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">A</span>(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> c) : <span class="built_in">A</span>(a, b) &#123; c_ = c; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> a_;</span><br><span class="line">    <span class="keyword">int</span> b_;</span><br><span class="line">    <span class="keyword">int</span> c_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="继承构造函数"><a class="markdownIt-Anchor" href="#继承构造函数"></a> 继承构造函数</h1><p>有时基类TestA可能有好多个构造函数。如果TestA有大量的构造函数，TestB只有一些成员函数，对于派生类而言，其构造等同于构造基类，这个时候我们就要写很多透传的构造函数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestA</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">TestA</span>(string i): <span class="built_in">a1</span>(i) &#123;&#125;</span><br><span class="line">    <span class="built_in">TestA</span>(<span class="keyword">int</span> i) : <span class="built_in">a2</span>(i) &#123;&#125;</span><br><span class="line">    <span class="built_in">TestA</span>(<span class="keyword">double</span> i) : <span class="built_in">a3</span>(i) &#123;&#125;</span><br><span class="line">    ~<span class="built_in">TestA</span>() &#123;&#125;</span><br><span class="line">    <span class="function">string <span class="title">geta1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a1;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> string <span class="title">getb1</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    string a1;</span><br><span class="line">    <span class="keyword">int</span> a2;</span><br><span class="line">    <span class="keyword">double</span> a3;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestB</span>:</span> <span class="keyword">public</span> TestA&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">TestB</span>(string i):<span class="built_in">TestA</span>(i),<span class="built_in">b1</span>(i) &#123;&#125;</span><br><span class="line">    <span class="built_in">TestB</span>(<span class="keyword">int</span> i) :<span class="built_in">TestA</span>(i), <span class="built_in">b2</span>(i) &#123;&#125;</span><br><span class="line">    <span class="built_in">TestB</span>(<span class="keyword">double</span> i) :<span class="built_in">TestA</span>(i), <span class="built_in">b3</span>(i) &#123;&#125;</span><br><span class="line">    ~<span class="built_in">TestB</span>() &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> string <span class="title">getb1</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> b1;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">testb</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    string b1;</span><br><span class="line">    <span class="keyword">int</span> b2;</span><br><span class="line">    <span class="keyword">double</span> b3;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>c++11里提供一个规则，派生类可以通过使用using声明来声明继承基类的构造函数。这样的话就可以如下代码来代替上面的代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestA</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">TestA</span>(string i): <span class="built_in">a1</span>(i) &#123;&#125;</span><br><span class="line">    <span class="built_in">TestA</span>(<span class="keyword">int</span> i) : <span class="built_in">a2</span>(i) &#123;&#125;</span><br><span class="line">    <span class="built_in">TestA</span>(<span class="keyword">double</span> i) : <span class="built_in">a3</span>(i) &#123;&#125;</span><br><span class="line">    ~<span class="built_in">TestA</span>() &#123;&#125;</span><br><span class="line">    <span class="function">string <span class="title">geta1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a1;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> string <span class="title">getb1</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    string a1;</span><br><span class="line">    <span class="keyword">int</span> a2;</span><br><span class="line">    <span class="keyword">double</span> a3;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestB</span>:</span> <span class="keyword">public</span> TestA&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 继承构造函数</span></span><br><span class="line"><span class="keyword">using</span> TestA::TestA; </span><br><span class="line"><span class="comment">// ....</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">testb</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    string b1;</span><br><span class="line">    <span class="keyword">int</span> b2;</span><br><span class="line">    <span class="keyword">double</span> b3;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>但是继承构造函数 只会初始化基类中的成员变量，对于派生类的成员变量，不会操作。可以通过使用初始化表达式来解决这个问题，例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestB</span>:</span> <span class="keyword">public</span> TestA&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 继承构造函数</span></span><br><span class="line"><span class="keyword">using</span> TestA::TestA; </span><br><span class="line"><span class="comment">// ....</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">testb</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    string b1&#123;<span class="string">&quot;b1&quot;</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> b2&#123;<span class="number">0</span>&#125;;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这里另外有一点需要注意的事，如果基类构造函数参数有默认值，默认值会导致基类产生多个构造函数的版本。这样都会被派生类继承。所以在使用有参数默认值的构造函数的基类，必须小心。</p><p>另外私有的构造函数，不会被继承构造。</p><h1 id="nullptr"><a class="markdownIt-Anchor" href="#nullptr"></a> nullptr</h1><p>nullptr是c<ins>11用来表示空指针新引入的常量值，在c</ins>中如果表示空指针语义时建议使用nullptr而不要使用NULL，因为NULL本质上是个int型的0，其实不是个指针。举例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">void</span> *ptr)</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;func ptr&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;func i&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">func</span>(<span class="literal">NULL</span>); <span class="comment">// 编译失败，会产生二义性</span></span><br><span class="line">    <span class="built_in">func</span>(<span class="literal">nullptr</span>); <span class="comment">// 输出func ptr</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="final-override"><a class="markdownIt-Anchor" href="#final-override"></a> final &amp; override</h1><p>c++11关于继承新增了两个关键字，<strong>final用于修饰一个类，表示禁止该类进一步派生和虚函数的进一步重载</strong>，override用于修饰派生类中的成员函数，<strong>标明该函数重写了基类函数</strong>，如果一个函数声明了override但父类却没有这个虚函数，编译报错，使用override关键字可以避免开发者在重写基类函数时无意产生的错误。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Base</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;base&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Derived</span> :</span> <span class="keyword">public</span> Base&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123; <span class="comment">// 确保func被重写</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;derived&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">fu</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123; <span class="comment">// error，基类没有fu()，不可以被重写</span></span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Base</span> <span class="keyword">final</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;base&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Derived</span> :</span> <span class="keyword">public</span> Base&#123; <span class="comment">// 编译失败，final修饰的类不可以被继承</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;derived&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="default"><a class="markdownIt-Anchor" href="#default"></a> default</h1><p>c++11引入default特性，多数时候用于声明构造函数为默认构造函数，如果类中有了自定义的构造函数，编译器就不会隐式生成默认构造函数，如下代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">A</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line">    <span class="built_in">A</span>(<span class="keyword">int</span> i) &#123; a = i; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    A a; <span class="comment">// 编译出错</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码编译出错，因为没有匹配的构造函数，因为编译器没有生成默认构造函数，而通过default，程序员只需在函数声明后加上“<code>=default;</code>”，就可将该函数声明为 defaulted 函数，编译器将为显式声明的 defaulted 函数自动生成函数体，如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">A</span> &#123;</span></span><br><span class="line">    <span class="built_in">A</span>() = <span class="keyword">default</span>;</span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line">    <span class="built_in">A</span>(<span class="keyword">int</span> i) &#123; a = i; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    A a;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="delete"><a class="markdownIt-Anchor" href="#delete"></a> delete</h1><p>c++中，如果开发人员没有定义特殊成员函数，那么编译器在需要特殊成员函数时候会隐式自动生成一个默认的特殊成员函数，例如拷贝构造函数或者拷贝赋值操作符</p><p>我们有时候想禁止对象的拷贝与赋值，可以使用delete修饰，如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">A</span> &#123;</span></span><br><span class="line">    <span class="built_in">A</span>() = <span class="keyword">default</span>;</span><br><span class="line">    <span class="built_in">A</span>(<span class="keyword">const</span> A&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    A&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> A&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line">    <span class="built_in">A</span>(<span class="keyword">int</span> i) &#123; a = i; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    A a1;</span><br><span class="line">    A a2 = a1;  <span class="comment">// 错误，拷贝构造函数被禁用</span></span><br><span class="line">    A a3;</span><br><span class="line">    a3 = a1;  <span class="comment">// 错误，拷贝赋值操作符被禁用</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>delele函数在c++11中很常用，std::unique_ptr就是通过delete修饰来禁止对象的拷贝的。</p><h1 id="explicit"><a class="markdownIt-Anchor" href="#explicit"></a> explicit</h1><p>explicit专用于修饰构造函数，表示只能显式构造，不可以被隐式转换。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">A</span> &#123;</span></span><br><span class="line">    <span class="built_in">A</span>(<span class="keyword">int</span> value) &#123; <span class="comment">// 没有explicit关键字</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;value&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    A a = <span class="number">1</span>; <span class="comment">// 可以隐式转换</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/***********************************/</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">A</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">A</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;value&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    A a = <span class="number">1</span>; <span class="comment">// error，不可以隐式转换</span></span><br><span class="line">    <span class="function">A <span class="title">aa</span><span class="params">(<span class="number">2</span>)</span></span>; <span class="comment">// ok</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="constexpr"><a class="markdownIt-Anchor" href="#constexpr"></a> constexpr</h1><p>constexpr是c++11新引入的关键字，用于编译时的常量和常量函数，这里直接介绍constexpr和const的区别：</p><p>两者都代表可读，const只表示read only的语义，只保证了运行时不可以被修改，但它修饰的仍然有可能是个动态变量，constexpr修饰的才是真正的常量，它会在编译期间就会被计算出来，整个运行过程中都不可以被改变，constexpr可以用于修饰函数，这个函数的返回值会尽可能在编译期间被计算出来当作一个常量，但是如果编译期间此函数不能被计算出来，那它就会当作一个普通函数被处理。如下代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="keyword">int</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> i + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">2</span>;</span><br><span class="line">    <span class="built_in">func</span>(i);<span class="comment">// 普通函数</span></span><br><span class="line">    <span class="built_in">func</span>(<span class="number">2</span>);<span class="comment">// 编译期间就会被计算出来</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>const用于修饰不能被修改的对象，但const对象的值通常在程序运行期间才能确定</p></li><li><p>constexpr用于修饰常量表达式或可返回常量表达式的constexpr函数，在编译时能确定值。</p></li><li><p>constexpr函数都是inline函数</p></li></ul><h1 id="emun作用域"><a class="markdownIt-Anchor" href="#emun作用域"></a> emun作用域</h1><p>c++11新增有作用域的枚举类型，不带作用域的枚举类型可以自动转换成整形，且不同的枚举可以相互比较，代码中的红色居然可以和白色比较，这都是潜在的难以调试的bug，而这种完全可以通过有作用域的枚举来规避。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="keyword">class</span> <span class="title">AColor</span> &#123;</span></span><br><span class="line">    kRed,</span><br><span class="line">    kGreen,</span><br><span class="line">    kBlue</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="keyword">class</span> <span class="title">BColor</span> &#123;</span></span><br><span class="line">    kWhite,</span><br><span class="line">    kBlack,</span><br><span class="line">    kYellow</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (AColor::kRed == BColor::kWhite) &#123; <span class="comment">// 编译失败</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;red == white&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同时带作用域的枚举类型可以选择底层类型，默认是int，可以改成char等别的类型。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="keyword">class</span> <span class="title">AColor</span> :</span> <span class="keyword">char</span> &#123;</span><br><span class="line">    kRed,</span><br><span class="line">    kGreen,</span><br><span class="line">    kBlue</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="非受限联合体待补充"><a class="markdownIt-Anchor" href="#非受限联合体待补充"></a> 非受限联合体(待补充)</h1><p>。。。</p><h1 id="sizeof"><a class="markdownIt-Anchor" href="#sizeof"></a> sizeof</h1><p>c++11中sizeof可以用的类的数据成员上：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">A</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> data[<span class="number">10</span>];</span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    A a;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;size &quot;</span> &lt;&lt; <span class="built_in"><span class="keyword">sizeof</span></span>(a.data) &lt;&lt; endl;<span class="comment">// before c++11</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;size &quot;</span> &lt;&lt; <span class="built_in"><span class="keyword">sizeof</span></span>(A::data) &lt;&lt; endl;<span class="comment">// c++11</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>想知道类中数据成员的大小在c++11中方便了许多，而不需要定义一个对象，在计算对象的成员大小。</p><h1 id="assertion"><a class="markdownIt-Anchor" href="#assertion"></a> assertion</h1><p>c++11引入static_assert声明，用于在<strong>编译期间检查</strong>，如果第一个参数值为false，则打印message，编译失败。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in"><span class="keyword">static_assert</span></span>(<span class="literal">true</span>/<span class="literal">false</span>, message);</span><br></pre></td></tr></table></figure><h1 id="内存对齐待补充"><a class="markdownIt-Anchor" href="#内存对齐待补充"></a> 内存对齐(待补充)</h1><p>。。。</p><h1 id="thread_local"><a class="markdownIt-Anchor" href="#thread_local"></a> thread_local</h1><p>c++11引入thread_local，用thread_local修饰的变量具有thread周期，每一个线程都拥有并只拥有一个该变量的独立实例，一般用于需要保证线程安全的函数中。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">A</span>() &#123;&#125;</span><br><span class="line">    ~<span class="built_in">A</span>() &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">(<span class="keyword">const</span> std::string &amp;name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">thread_local</span> <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        ++count;</span><br><span class="line">        std::cout &lt;&lt; name &lt;&lt; <span class="string">&quot;: &quot;</span> &lt;&lt; count &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">const</span> std::string &amp;name)</span> </span>&#123;</span><br><span class="line">    A a1;</span><br><span class="line">    a1.<span class="built_in">test</span>(name);</span><br><span class="line">    a1.<span class="built_in">test</span>(name);</span><br><span class="line">    A a2;</span><br><span class="line">    a2.<span class="built_in">test</span>(name);</span><br><span class="line">    a2.<span class="built_in">test</span>(name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::<span class="built_in">thread</span>(func, <span class="string">&quot;thread1&quot;</span>).<span class="built_in">join</span>();</span><br><span class="line">    std::<span class="built_in">thread</span>(func, <span class="string">&quot;thread2&quot;</span>).<span class="built_in">join</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">输出结果：</span></span><br><span class="line"><span class="comment">thread1: 1</span></span><br><span class="line"><span class="comment">    thread1: 2</span></span><br><span class="line"><span class="comment">    thread1: 3</span></span><br><span class="line"><span class="comment">    thread1: 4</span></span><br><span class="line"><span class="comment">    thread2: 1</span></span><br><span class="line"><span class="comment">    thread2: 2</span></span><br><span class="line"><span class="comment">    thread2: 3</span></span><br><span class="line"><span class="comment">    thread2: 4</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>验证上述说法，对于一个线程私有变量，一个线程拥有且只拥有一个该实例，类似于static。</p><h1 id="基础数值类型"><a class="markdownIt-Anchor" href="#基础数值类型"></a> 基础数值类型</h1><p>c++11新增了几种数据类型：long long、char16_t、char32_t等</p><h1 id="正则表达式待补充"><a class="markdownIt-Anchor" href="#正则表达式待补充"></a> 正则表达式(待补充)</h1><p>c++11引入了regex库更好的支持正则表达式</p><h1 id="新增数据结构"><a class="markdownIt-Anchor" href="#新增数据结构"></a> 新增数据结构</h1><ul><li><p>std::forward_list：单向链表，只可以前进，在特定场景下使用，相比于<code>std::list</code>节省了内存，提高了性能。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">std::forward_list&lt;<span class="keyword">int</span>&gt; fl = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;elem : fl) &#123;</span><br><span class="line">    cout &lt;&lt; elem;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>它实现为单链表，且实质上与其在 C 中实现相比无任何开销</li><li>与 std::list 相比，此容器在不需要双向迭代时提供更有效地利用空间的存储</li></ul></li><li><p>std::unordered_set：基于hash表实现的set，内部不会排序，使用方法和set类似</p></li><li><p>std::unordered_map：基于hash表实现的map，内部不会排序，使用方法和set类似</p></li><li><p>std::array：数组，在越界访问时抛出异常，建议使用std::array替代普通的数组</p></li><li><p>std::tuple: 元组类型</p><p><a href="https://aflyingsheep.github.io/2023/02/28/cpp/tuple/">站内推荐：c++11: tuple</a></p></li></ul><h1 id="新增算法待补充"><a class="markdownIt-Anchor" href="#新增算法待补充"></a> 新增算法(待补充)</h1><p>。。。</p><h1 id="随机数功能"><a class="markdownIt-Anchor" href="#随机数功能"></a> 随机数功能</h1><p>c++11关于随机数功能则较之前丰富了很多，典型的可以选择概率分布类型，先看如下代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;random&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::default_random_engine <span class="title">random</span><span class="params">(time(<span class="literal">nullptr</span>))</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">std::uniform_int_distribution&lt;<span class="keyword">int</span>&gt; <span class="title">int_dis</span><span class="params">(<span class="number">0</span>, <span class="number">100</span>)</span></span>; <span class="comment">// 整数均匀分布</span></span><br><span class="line">    <span class="function">std::uniform_real_distribution&lt;<span class="keyword">float</span>&gt; <span class="title">real_dis</span><span class="params">(<span class="number">0.0</span>, <span class="number">1.0</span>)</span></span>; <span class="comment">// 浮点数均匀分布</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="built_in">int_dis</span>(random) &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="built_in">real_dis</span>(random) &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">输出：</span></span><br><span class="line"><span class="comment">38 100 93 7 66 0 68 99 41 7</span></span><br><span class="line"><span class="comment">0.232202 0.617716 0.959241 0.970859 0.230406 0.430682 0.477359 0.971858 0.0171148 0.64863</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>代码中举例的是整数均匀分布和浮点数均匀分布，c++11提供的概率分布类型还有好多，例如伯努利分布、正态分布等，具体可以见最后的参考资料。</p><h1 id="lambda表达式"><a class="markdownIt-Anchor" href="#lambda表达式"></a> Lambda表达式</h1>]]></content>
    
    
    <summary type="html">C++11新特性。</summary>
    
    
    
    <category term="CS" scheme="http://aflyingsheep.github.io/categories/CS/"/>
    
    <category term="C++11" scheme="http://aflyingsheep.github.io/categories/C-11/"/>
    
    
    <category term="CS" scheme="http://aflyingsheep.github.io/tags/CS/"/>
    
    <category term="C/C++" scheme="http://aflyingsheep.github.io/tags/C-C/"/>
    
    <category term="C++11" scheme="http://aflyingsheep.github.io/tags/C-11/"/>
    
  </entry>
  
  <entry>
    <title>C++11：tuple</title>
    <link href="http://aflyingsheep.github.io/2023/02/27/cpp/tuple/"/>
    <id>http://aflyingsheep.github.io/2023/02/27/cpp/tuple/</id>
    <published>2023-02-27T07:55:06.000Z</published>
    <updated>2023-02-28T13:01:15.401Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="tuple"><a class="markdownIt-Anchor" href="#tuple"></a> tuple</h1><p>std::tuple是C++11新标准引入的一个类模板，又称为元组，是一个固定大小的异构值集合，由std::pair泛化而来。pair可以看作是tuple的一种特殊情况，成员数t目限定为两个。tuple可以有任意个成员数量，但是每个确定的tuple类型的成员数目是固定的。</p><p>从概念上讲，它们类似于C的结构体，但是不具有命名的数据成员，我们也可以把他当做一个通用的结构体来用，不需要创建结构体又获取结构体的特征，在某些情况下可以取代结构体使程序更简洁，直观。</p><p>tuple 的应用场景很广泛，例如当需要存储多个不同类型的元素时，可以使用 tuple；当函数需要返回多个数据时，可以将这些数据存储在 tuple 中，函数只需返回一个 tuple 对象即可。</p><h1 id="tuple基本用法"><a class="markdownIt-Anchor" href="#tuple基本用法"></a> tuple基本用法</h1><h2 id="tuple对象的创建和初始化"><a class="markdownIt-Anchor" href="#tuple对象的创建和初始化"></a> tuple对象的创建和初始化</h2><ol><li><p>类的构造函数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;tuple&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::tuple&lt;std::string, <span class="keyword">int</span>&gt; t1;    <span class="comment">//无参构造</span></span><br><span class="line">    <span class="function">std::tuple&lt;std::string, <span class="keyword">int</span>&gt; <span class="title">t2</span><span class="params">(t1)</span></span>;<span class="comment">//拷贝构造</span></span><br><span class="line">    <span class="function">std::tuple&lt;std::string, <span class="keyword">int</span>&gt; <span class="title">t3</span><span class="params">(std::make_tuple(<span class="string">&quot;Lily&quot;</span>, <span class="number">1</span>))</span></span>;</span><br><span class="line">    <span class="function">std::tuple&lt;std::string, <span class="keyword">long</span>&gt; <span class="title">t4</span><span class="params">(t3)</span></span>;   <span class="comment">//隐式类型转换构造的左值方式</span></span><br><span class="line">    <span class="function">std::tuple&lt;std::string, <span class="keyword">int</span>&gt; <span class="title">t5</span><span class="params">(<span class="string">&quot;Mike&quot;</span>, <span class="number">2</span>)</span></span>; <span class="comment">//初始化列表构造的右值方式</span></span><br><span class="line">    <span class="function">std::tuple&lt;std::string, <span class="keyword">int</span>&gt; <span class="title">t6</span><span class="params">(std::make_pair(<span class="string">&quot;Jack&quot;</span>,<span class="number">3</span>))</span></span>;  <span class="comment">//将pair对象转换为tuple对象</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>make_tuple()函数：make_tuple() 函数以模板的形式定义在头文件中，功能是创建一个 tuple 右值对象（或者临时对象）。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">std::tuple&lt;std::string, <span class="keyword">double</span> ,<span class="keyword">int</span>&gt; t1 = std::<span class="built_in">make_tuple</span>(<span class="string">&quot;Jack&quot;</span>, <span class="number">66.6</span>, <span class="number">88</span>);</span><br><span class="line"><span class="keyword">auto</span> t2 = std::<span class="built_in">make_tuple</span>(<span class="number">1</span>, <span class="string">&quot;Lily&quot;</span>, <span class="string">&#x27;c&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//t2的类型实际是std::tuple&lt;int, const char *, char&gt;</span></span><br></pre></td></tr></table></figure></li></ol><h2 id="获取tuple的值"><a class="markdownIt-Anchor" href="#获取tuple的值"></a> 获取tuple的值</h2><ol><li><p>std::get(std::tuple)</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;tuple&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> t1 = std::<span class="built_in">make_tuple</span>(<span class="number">1</span>, <span class="string">&quot;PI&quot;</span>, <span class="number">3.14</span>);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&#x27;(&#x27;</span> &lt;&lt; std::get&lt;<span class="number">0</span>&gt;(t1) &lt;&lt; <span class="string">&#x27;,&#x27;</span> &lt;&lt; std::get&lt;<span class="number">1</span>&gt;(t1) &lt;&lt;</span><br><span class="line">            <span class="string">&#x27;,&#x27;</span> &lt;&lt; std::get&lt;<span class="number">2</span>&gt;(t1) &lt;&lt;  <span class="string">&#x27;)&#x27;</span> &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">output: (1,PI,3.14)</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">std::tuple&lt;std::tuple&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;, <span class="keyword">int</span>, <span class="keyword">int</span>&gt; t;</span><br><span class="line">t = std::<span class="built_in">make_tuple</span>(std::tuple&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;(<span class="number">2</span>, <span class="number">1</span>), <span class="number">1</span>, <span class="number">1</span>); </span><br><span class="line"></span><br><span class="line">std::cout &lt;&lt; std::get&lt;<span class="number">0</span>&gt;(std::get&lt;<span class="number">0</span>&gt;(t));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">output: 2</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></li></ol><p>由于get的特性，<strong>tuple不支持迭代</strong>，只能通过元素索引(或tie解包)进行获取元素的值。但是<strong>给定的索引必须是在编译器就已经给定</strong>，不能在运行期进行动态传递，否则将发生编译错误。</p><ol start="2"><li><p>std::tie(): 解包时，我们如果只想解某个位置的值时，可以用std::ignore占位符来表示不解某个位置的值</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;tuple&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> t1 = std::<span class="built_in">make_tuple</span>(<span class="number">1</span>, <span class="string">&quot;PI&quot;</span>, <span class="number">3.14</span>);</span><br><span class="line">    <span class="keyword">auto</span> t2 = std::<span class="built_in">make_tuple</span>(<span class="number">2</span>, <span class="string">&quot;MAX&quot;</span>, <span class="number">999</span>);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&#x27;(&#x27;</span> &lt;&lt; std::get&lt;<span class="number">0</span>&gt;(t1) &lt;&lt; <span class="string">&#x27;,&#x27;</span> &lt;&lt; std::get&lt;<span class="number">1</span>&gt;(t1) &lt;&lt;</span><br><span class="line">            <span class="string">&#x27;,&#x27;</span> &lt;&lt; std::get&lt;<span class="number">2</span>&gt;(t1) &lt;&lt;  <span class="string">&#x27;)&#x27;</span> &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">    std::string name;</span><br><span class="line">    <span class="keyword">double</span> value;</span><br><span class="line">    std::<span class="built_in">tie</span>(num, name, value) = t1;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&#x27;(&#x27;</span> &lt;&lt; num &lt;&lt; <span class="string">&#x27;,&#x27;</span> &lt;&lt; name &lt;&lt; <span class="string">&#x27;,&#x27;</span> &lt;&lt; value &lt;&lt; <span class="string">&#x27;)&#x27;</span> &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    num = <span class="number">0</span>, name = <span class="string">&quot;&quot;</span>, value = <span class="number">0</span>;</span><br><span class="line">    std::<span class="built_in">tie</span>(std::ignore, name, value) = t2;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&#x27;(&#x27;</span> &lt;&lt; num &lt;&lt; <span class="string">&#x27;,&#x27;</span> &lt;&lt; name &lt;&lt; <span class="string">&#x27;,&#x27;</span> &lt;&lt; value &lt;&lt; <span class="string">&#x27;)&#x27;</span> &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">output:</span></span><br><span class="line"><span class="comment">(1,PI,3.14)</span></span><br><span class="line"><span class="comment">(1,PI,3.14)</span></span><br><span class="line"><span class="comment">(0,MAX,999)</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></li></ol><h2 id="其他方法"><a class="markdownIt-Anchor" href="#其他方法"></a> 其他方法</h2><ol><li><p>获取元素个数：</p><p>可以采用<code>std::tuple_size&lt;T&gt;::value</code>来获得，其中T必须要显式给出tuple的类型；</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;tuple&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> t1 = std::<span class="built_in">make_tuple</span>(<span class="number">2</span>, <span class="string">&quot;MAX&quot;</span>, <span class="number">999</span>, <span class="number">888</span>, <span class="number">65.6</span>);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;The t1 has elements: &quot;</span> &lt;&lt; std::tuple_size&lt;<span class="keyword">decltype</span>(t1)&gt;::value &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">output: The t1 has elements: 5</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>获取元素类型：</p><p>可以直接采用<code>std::tuple&lt;size_t i,decltype(tuple)&gt;::type</code>来获取；</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">include &lt;iostream&gt;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;tuple&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> t1 = std::<span class="built_in">make_tuple</span>(<span class="number">2</span>, <span class="string">&quot;MAX&quot;</span>, <span class="number">999.9</span>);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;The t1 has elements: &quot;</span> &lt;&lt; std::tuple_size&lt;<span class="keyword">decltype</span>(t1)&gt;::value &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    std::tuple_element&lt;<span class="number">0</span>, <span class="keyword">decltype</span>(t1)&gt;::type type0;</span><br><span class="line">    std::tuple_element&lt;<span class="number">1</span>, <span class="keyword">decltype</span>(t1)&gt;::type type1;</span><br><span class="line">    std::tuple_element&lt;<span class="number">2</span>, <span class="keyword">decltype</span>(t1)&gt;::type type2;</span><br><span class="line">    type0 = std::get&lt;<span class="number">0</span>&gt;(t1);</span><br><span class="line">    type1 = std::get&lt;<span class="number">1</span>&gt;(t1);</span><br><span class="line">    type2 = std::get&lt;<span class="number">2</span>&gt;(t1);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;type0 : &quot;</span> &lt;&lt; type0 &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;type1 : &quot;</span> &lt;&lt; type1 &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;type2 : &quot;</span> &lt;&lt; type2 &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">output:</span></span><br><span class="line"><span class="comment">The t1 has elements: 3</span></span><br><span class="line"><span class="comment">type0 : 2</span></span><br><span class="line"><span class="comment">type1 : MAX</span></span><br><span class="line"><span class="comment">type2 : 999.9</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></li><li><p>使用tuple引用来改变tuple内元素的值：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> a, b, c;</span><br><span class="line">std::tuple&lt;<span class="keyword">int</span>&amp;, <span class="keyword">int</span>&amp;&gt; t = std::<span class="built_in">make_tuple</span>(std::<span class="built_in">ref</span>(a), std::<span class="built_in">ref</span>(b));</span><br><span class="line"></span><br><span class="line">a = <span class="number">1</span>; b = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">std::cout &lt;&lt; std::get&lt;<span class="number">0</span>&gt;(t) &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; std::get&lt;<span class="number">1</span>&gt;(t) &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">a = <span class="number">2</span>; b = <span class="number">3</span>;</span><br><span class="line">std::cout &lt;&lt; std::get&lt;<span class="number">0</span>&gt;(t) &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; std::get&lt;<span class="number">1</span>&gt;(t) &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">输出：</span></span><br><span class="line"><span class="comment">1 2</span></span><br><span class="line"><span class="comment">2 3</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></li></ol>]]></content>
    
    
    <summary type="html">C++11新特性。</summary>
    
    
    
    <category term="CS" scheme="http://aflyingsheep.github.io/categories/CS/"/>
    
    <category term="C++11" scheme="http://aflyingsheep.github.io/categories/C-11/"/>
    
    
    <category term="CS" scheme="http://aflyingsheep.github.io/tags/CS/"/>
    
    <category term="C/C++" scheme="http://aflyingsheep.github.io/tags/C-C/"/>
    
    <category term="C++11" scheme="http://aflyingsheep.github.io/tags/C-11/"/>
    
  </entry>
  
  <entry>
    <title>C++函数指针</title>
    <link href="http://aflyingsheep.github.io/2023/02/27/cpp/function_pointer/"/>
    <id>http://aflyingsheep.github.io/2023/02/27/cpp/function_pointer/</id>
    <published>2023-02-27T05:46:08.000Z</published>
    <updated>2023-02-27T06:07:14.808Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>函数指针是指指向函数而非指向对象的指针。像其他指针一样，函数指针也指向某个特定的类型。函数类型由其返回类型以及形参表确定， 而与函数名无关：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// pf points to function returning bool that takes two const string references</span></span><br><span class="line"><span class="built_in"><span class="keyword">bool</span></span> (*pf)(<span class="keyword">const</span> string &amp;, <span class="keyword">const</span> string &amp;);</span><br></pre></td></tr></table></figure><p>这个语句将 pf 声明为指向函数的指针，它所指向的函数带有两个 const string&amp; 类型的形参和 bool 类型的返回值。</p><p>*pf 两侧的圆括号是必需的：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// declares a function named pf that returns a bool*</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> *<span class="title">pf</span><span class="params">(<span class="keyword">const</span> string &amp;, <span class="keyword">const</span> string &amp;)</span></span>;</span><br></pre></td></tr></table></figure><h2 id="用-typedef-简化函数指针的定义"><a class="markdownIt-Anchor" href="#用-typedef-简化函数指针的定义"></a> 用 typedef 简化函数指针的定义</h2><p>函数指针类型相当地冗长。使用 typedef 为指针类型定义同义词，可将函数指针的使用大大简化：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">bool</span> <span class="params">(*cmpFcn)</span><span class="params">(<span class="keyword">const</span> string &amp;, <span class="keyword">const</span> string &amp;)</span></span>;</span><br></pre></td></tr></table></figure><p>该定义表示 cmpFcn 是一种指向函数的指针类型的名字。该指针类型为“指向返回 bool 类型并带有两个 const string 引用形参的函数的指针”。在要使用这种函数指针类型时，只需直接使用 cmpFcn 即可，不必每次都把整个类型声明全部写出来。</p><h2 id="指向函数的指针的初始化和赋值"><a class="markdownIt-Anchor" href="#指向函数的指针的初始化和赋值"></a> 指向函数的指针的初始化和赋值</h2><p>在引用函数名但又没有调用该函数时，函数名将被自动解释为指向函数的指针。假设有函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// compares lengths of two strings</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">lengthCompare</span><span class="params">(<span class="keyword">const</span> string &amp;, <span class="keyword">const</span> string &amp;)</span></span>;</span><br></pre></td></tr></table></figure><p>除了用作函数调用的左操作数以外，对 lengthCompare 的任何使用都被解释为如下类型的指针：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in"><span class="keyword">bool</span></span> (*)(<span class="keyword">const</span> string &amp;, <span class="keyword">const</span> string &amp;);</span><br></pre></td></tr></table></figure><p>此时，直接引用函数名等效于在函数名上应用取地址操作符：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cmpFcn pf1 = lengthCompare;</span><br><span class="line">cmpFcn pf2 = &amp;lengthCompare;</span><br></pre></td></tr></table></figure><p>函数指针只能通过同类型的函数或函数指针或 0 值常量表达式进行初始化或赋值。</p><p>将函数指针初始化为 0，表示该指针不指向任何函数。</p><p>指向不同函数类型的指针之间不存在转换。</p><h2 id="通过指针调用函数"><a class="markdownIt-Anchor" href="#通过指针调用函数"></a> 通过指针调用函数</h2><p>指向函数的指针可用于调用它所指向的函数。可以不需要使用解引用操作符，直接通过指针调用函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cmpFcn pf = lengthCompare;</span><br><span class="line"><span class="built_in">lengthCompare</span>(<span class="string">&quot;hi&quot;</span>, <span class="string">&quot;bye&quot;</span>); <span class="comment">// direct call</span></span><br><span class="line"><span class="built_in">pf</span>(<span class="string">&quot;hi&quot;</span>, <span class="string">&quot;bye&quot;</span>); <span class="comment">// equivalent call: pf1 implicitly dereferenced</span></span><br><span class="line">(*pf)(<span class="string">&quot;hi&quot;</span>, <span class="string">&quot;bye&quot;</span>); <span class="comment">// equivalent call: pf1 explicitly dereferenced</span></span><br></pre></td></tr></table></figure><p>如果指向函数的指针没有初始化，或者具有 0 值，则该指针不能在函数调用中使用。只有当指针已经初始化，或被赋值为指向某个函数，方能安全地用来调用函数。</p><h2 id="函数指针的形参"><a class="markdownIt-Anchor" href="#函数指针的形参"></a> 函数指针的形参</h2><p>函数的形参可以是指向函数的指针。这种形参可以用以下两种形式编写：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">useBigger</span><span class="params">(<span class="keyword">const</span> string &amp;, <span class="keyword">const</span> string &amp;,<span class="keyword">bool</span>(<span class="keyword">const</span> string &amp;, <span class="keyword">const</span> string &amp;))</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">useBigger</span><span class="params">(<span class="keyword">const</span> string &amp;, <span class="keyword">const</span> string &amp;,<span class="keyword">bool</span> (*)(<span class="keyword">const</span> string &amp;, <span class="keyword">const</span> string &amp;))</span></span>;</span><br></pre></td></tr></table></figure><h2 id="返回指向函数的指针"><a class="markdownIt-Anchor" href="#返回指向函数的指针"></a> 返回指向函数的指针</h2><p>函数可以返回指向函数的指针，但是，正确写出这种返回类型相当不容易：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in"><span class="keyword">int</span></span> (*<span class="built_in">ff</span>(<span class="keyword">int</span>))(<span class="keyword">int</span>*, <span class="keyword">int</span>);</span><br></pre></td></tr></table></figure><p>它是一个指向函数的指针，所指向的函数返回 int 型并带有两个分别是int* 型和 int 型的形参。</p><p>使用 typedef 可使该定义更简明易懂：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">int</span> <span class="params">(*PF)</span><span class="params">(<span class="keyword">int</span>*, <span class="keyword">int</span>)</span></span>;</span><br><span class="line"><span class="function">PF <span class="title">ff</span><span class="params">(<span class="keyword">int</span>)</span></span>; <span class="comment">// ff returns a pointer to function</span></span><br></pre></td></tr></table></figure><p>允许将形参定义为函数类型，但函数的返回类型则必须是指向函数的指针，而不能是函数。</p><p>具有函数类型的形参所对应的实参将被自动转换为指向相应函数类型的指针。但是，当返回的是函数时，同样的转换操作则无法实现：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// func is a function type, not a pointer to function!</span></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="keyword">int</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span>*, <span class="keyword">int</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f1</span><span class="params">(func)</span></span>; <span class="comment">// ok: f1 has a parameter of function type</span></span><br><span class="line"><span class="function">func <span class="title">f2</span><span class="params">(<span class="keyword">int</span>)</span></span>; <span class="comment">// error: f2 has a return type of function type</span></span><br><span class="line"><span class="function">func *<span class="title">f3</span><span class="params">(<span class="keyword">int</span>)</span></span>; <span class="comment">// ok: f3 returns a pointer to function type</span></span><br></pre></td></tr></table></figure><h2 id="指向重载函数的指针"><a class="markdownIt-Anchor" href="#指向重载函数的指针"></a> 指向重载函数的指针</h2><p>C++ 语言允许使用函数指针指向重载的函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">void</span> <span class="title">ff</span><span class="params">(vector&lt;<span class="keyword">double</span>&gt;)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">void</span> <span class="title">ff</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span>)</span></span>;</span><br></pre></td></tr></table></figure><p>指针的类型必须与重载函数的一个版本精确匹配。如果没有精确匹配的函数，则对该指针的初始化或赋值都将导致编译错误：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// error: no match: invalid parameter list</span></span><br><span class="line"><span class="built_in"><span class="keyword">void</span></span> (*pf2)(<span class="keyword">int</span>) = &amp;ff;</span><br><span class="line"><span class="comment">// error: no match: invalid return type</span></span><br><span class="line"><span class="built_in"><span class="keyword">double</span></span> (*pf3)(vector&lt;<span class="keyword">double</span>&gt;);</span><br><span class="line">pf3 = &amp;ff;</span><br></pre></td></tr></table></figure><h2 id="decltype用于函数指针类型"><a class="markdownIt-Anchor" href="#decltype用于函数指针类型"></a> decltype用于函数指针类型</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">string::size_type <span class="title">sumLength</span><span class="params">(<span class="keyword">const</span> string&amp;,<span class="keyword">const</span> string&amp;)</span></span>;</span><br><span class="line"><span class="keyword">decltype</span>(sumLength) *<span class="built_in">getFcn</span>(<span class="keyword">const</span> string&amp;)</span><br></pre></td></tr></table></figure><p>使用decltype得到的是某个函数类型而非指针类型，因此需要显示的加上指针。</p>]]></content>
    
    
    <summary type="html">函数指针是指指向函数而非指向对象的指针。像其他指针一样，函数指针也指向某个特定的类型。函数类型由其返回类型以及形参表确定,而与函数名无关.</summary>
    
    
    
    <category term="CS" scheme="http://aflyingsheep.github.io/categories/CS/"/>
    
    
    <category term="CS" scheme="http://aflyingsheep.github.io/tags/CS/"/>
    
    <category term="C/C++" scheme="http://aflyingsheep.github.io/tags/C-C/"/>
    
  </entry>
  
  <entry>
    <title>C++ Primer</title>
    <link href="http://aflyingsheep.github.io/2023/02/24/cpp/cpp_primer/"/>
    <id>http://aflyingsheep.github.io/2023/02/24/cpp/cpp_primer/</id>
    <published>2023-02-24T13:22:06.000Z</published>
    <updated>2023-02-27T07:44:46.903Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="顺序容器"><a class="markdownIt-Anchor" href="#顺序容器"></a> 顺序容器</h1><ol><li><p>容器的元素类型必须满足以下两个约束：元素类型必须支持赋值运算、元素类型的对象必须可以复制。</p></li><li><p>不要存储end操作返回的迭代器。添加或删除deque或vector容器内的元素都会导致存储的迭代器失效。</p></li><li><p>vector提供了两个类成员函数: capacity和reserve。capacity用于获取容器需要分配更多的储存空间之前能够存储的元素总数；reserve操作告诉vector容器应该预留多少个元素的储存空间。</p></li><li><p>deque提供更复杂的数据结构，从队列两端插入和删除非常快，在中间操作代价更高。</p><p>deque支持对所有元素的随机访问。</p><p>deque在首尾插入元素不会使迭代器失效，在首位删除或在中间插入删除都会使迭代器失效。</p></li><li><p>适配器：</p><ol><li>默认的stack和queue基于deque容器实现，priority_queue在vector容器上实现。</li><li>stack可以建立在vector, list, deque容器上；queue只能建立在list上，不能建立在vector上(要提供push_front运算)；priority_queue可以建立在vector, deque上，不能建立在list上(要提供随机访问)。</li><li>优先队列：允许用户为队列中存储的元素设置优先级</li></ol></li></ol><h1 id="关联容器"><a class="markdownIt-Anchor" href="#关联容器"></a> 关联容器</h1><ol><li><p>标准库定义了make_pair函数，由传递给它的两个实参生成一个新的pair对象</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">pair&lt;string, string&gt; next_auth;</span><br><span class="line">string first, second;</span><br><span class="line"><span class="keyword">while</span> (cin &gt;&gt; first &gt;&gt; second) &#123;</span><br><span class="line">    next_auth = <span class="built_in">make_pair</span>(first, second);</span><br><span class="line">    <span class="comment">// process pair</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>关联容器的键不但有一个类型，还有一个比较函数，默认情况下为键类型定义的 &lt; 操作符实现比较。</p></li><li><p>map.insert(e)返回pair&lt;map&lt;&gt;::iterator, bool&gt;, 如果键已在map中则关联值保持不变，返回的迭代器指向该pair并返回false；如果不在则插入新元素并返回迭代器和true；</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// insert重写单词统计</span></span><br><span class="line">map&lt;string, <span class="keyword">int</span>&gt; word_count;</span><br><span class="line">string word;</span><br><span class="line"><span class="keyword">while</span> (cin&gt;&gt; word) &#123;</span><br><span class="line">    pair&lt;map&lt;string, <span class="keyword">int</span>&gt;::iterator, <span class="keyword">bool</span>&gt; ret = word_count.<span class="built_in">insert</span>(make_pair&lt;word, <span class="number">1</span>&gt;);</span><br><span class="line">    <span class="keyword">if</span> (!ret.second) &#123;</span><br><span class="line">        ++ret.first-&gt;second;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>set.insert(e)同样返回pair&lt;set&lt;&gt;::iterator, bool&gt;，与map类似，bool表示是否存在，迭代器指向插入或存在的值。</p></li><li><p>在multimap与multiset中查找元素，可以在同一个键上调用<code>lower_bound, upper_bound</code>，分别返回该键关联的第一个元素与最后一个元素的下一位置。如果不存在，则<code>lower_bound == upper_bound</code>并且指向应该插入的位置。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 查找作者写的所有的书</span></span><br><span class="line"><span class="function">string <span class="title">search_item</span><span class="params">(<span class="string">&quot;Tom&quot;</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">authors_it begin = authors.<span class="built_in">lower_bound</span>(search_item),</span><br><span class="line">end = authors.<span class="built_in">upper_bound</span>(search_item);</span><br><span class="line"><span class="keyword">while</span> (begin != end) &#123;</span><br><span class="line">    std::cout &lt;&lt; begin.second &lt;&lt; std::endl;</span><br><span class="line">    ++begin;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>更直接的，可以直接调用equal_range函数取代以上两个函数，返回一对迭代器的pair对象。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 查找作者写的所有的书</span></span><br><span class="line"><span class="function">string <span class="title">search_item</span><span class="params">(<span class="string">&quot;Tom&quot;</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">pair&lt;authors_it, authors_it&gt; pos = authors.<span class="built_in">equal_range</span>(search_item);</span><br><span class="line"><span class="keyword">while</span> (pos.first != pos.second) &#123;</span><br><span class="line">    std::cout &lt;&lt; pos.second &lt;&lt; std::endl;</span><br><span class="line">    ++pos.first;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h1 id="类"><a class="markdownIt-Anchor" href="#类"></a> 类</h1><h2 id="初始化表"><a class="markdownIt-Anchor" href="#初始化表"></a> 初始化表</h2><ol><li>必须对任何const或引用类型成员以及没有默认构造函数的类类型的任何成员使用初始化式。</li><li>成员被初始化的顺序是定义成员的次序，而不是初始化表的顺序。</li></ol><h2 id="隐式类型转换"><a class="markdownIt-Anchor" href="#隐式类型转换"></a> 隐式类型转换</h2><ol><li>将构造函数声明为explicit，防止需要隐式转换的上下文中使用构造函数。</li></ol><h2 id="static类成员"><a class="markdownIt-Anchor" href="#static类成员"></a> static类成员</h2><h2 id="类类型对象"><a class="markdownIt-Anchor" href="#类类型对象"></a> 类类型对象</h2><p>在 C++ 中，我们可以使用类名后加上一对括号来创建一个类的对象，同时可以使用类名和作用域解析运算符（<code>::</code>）来访问类的静态成员和静态函数。然而，当我们使用类名后加上一对括号时，编译器无法确定我们是要创建一个类的对象还是访问类的类型对象。因此，为了区分类对象和类类型对象，我们需要在类名后面添加关键字<code>class</code>。</p><p>例如，假设我们有以下的 C++ 代码，其中定义了一个名为<code>MyClass</code>的类和一个类类型对象<code>myClassObj</code>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> count;</span><br><span class="line">    <span class="built_in">MyClass</span>() &#123;</span><br><span class="line">        count++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> MyClass::count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    MyClass obj1;</span><br><span class="line">    MyClass::count = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// create a class object</span></span><br><span class="line">    MyClass obj2;</span><br><span class="line">    obj2.x = <span class="number">42</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// create a class type object</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> <span class="title">myClassObj</span>;</span></span><br><span class="line">    myClassObj.count = <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;obj1.count = &quot;</span> &lt;&lt; obj1.count &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;obj2.x = &quot;</span> &lt;&lt; obj2.x &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;myClassObj.count = &quot;</span> &lt;&lt; myClassObj.count &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面的示例中，我们在创建类类型对象<code>myClassObj</code>时，在类名<code>MyClass</code>前面加上了关键字<code>class</code>。这样，编译器就可以确定我们要创建一个表示<code>MyClass</code>类本身的对象。</p><p>使用关键字<code>class</code>声明类类型对象是一种好习惯，可以让代码更加清晰明了。另外，需要注意的是，关键字<code>class</code>只在初始化类类型对象时需要使用，在访问类的静态成员和静态函数时不需要使用。</p><h1 id="复制控制"><a class="markdownIt-Anchor" href="#复制控制"></a> 复制控制</h1><h2 id="复制构造函数"><a class="markdownIt-Anchor" href="#复制构造函数"></a> 复制构造函数</h2><ol><li><p>复制构造函数：只有单个形参，且形参是本类类型对象的引用。</p></li><li><p>C++支持两种初始化形式：直接初始化(将初始化式放在括号内，调用实参匹配的构造函数)、复制初始化(用&quot;=&quot;符号，调用复制构造函数)。复制构造函数首先使用指定构造函数创建一个临时对象，然后用复制构造函数将临时对象复制到正在创建的对象。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 构造函数初始化举例</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> std::string;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Sales_item</span> &#123;</span></span><br><span class="line">string x;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Sales_item</span>(string input) : <span class="built_in">x</span>(input) &#123;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;构造函数被调用&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">Sales_item</span>(<span class="keyword">const</span> Sales_item&amp; other) &#123;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;复制构造函数被调用&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">x = other.x;</span><br><span class="line">&#125;</span><br><span class="line">&#125;; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//std::pair &lt;int, double&gt; p;</span></span><br><span class="line"><span class="comment">//p = std::make_pair(1.2, 1);</span></span><br><span class="line"><span class="comment">//std::cout &lt;&lt; p.first &lt;&lt; std::endl &lt;&lt; p.second;</span></span><br><span class="line">string s = <span class="string">&quot;000&quot;</span>;</span><br><span class="line"><span class="comment">// Sales_item si(s);</span></span><br><span class="line">Sales_item si = <span class="built_in">string</span>(<span class="string">&quot;000&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">输出结果：</span></span><br><span class="line"><span class="comment">构造函数被调用</span></span><br><span class="line"><span class="comment">复制构造函数被调用</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>注：如果构造函数是explicit，则<code>Sales_item si = string(&quot;000&quot;);</code>失效。</p></li><li><p>复制构造函数是接受单个类类型引用形参(通常const)修饰的构造函数，一般不应设置为<code>explicit</code>。为了防止复制，类必须显式声明其复制构造函数为<code>private</code>。为防止友元和成员进行复制，可以声明一个<code>private</code>的复制构造函数但不定义，这样任何使用未定义的成员的任何尝试都会导致链接失败，编译时便会出错。</p></li></ol><h2 id="赋值操作符"><a class="markdownIt-Anchor" href="#赋值操作符"></a> 赋值操作符</h2><ol><li><p>赋值操作符声明可以为：（右操作数一般作为const引用传递）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Sales_item</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Sales_item&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> Sales_item&amp;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol><h1 id="重载操作符"><a class="markdownIt-Anchor" href="#重载操作符"></a> 重载操作符</h1><ol><li>操作符定义为非成员函数时，通常必须将它们设置为所操作类的友元，以访问类的私有部分。</li></ol><h2 id="重载操作符设计"><a class="markdownIt-Anchor" href="#重载操作符设计"></a> 重载操作符设计</h2><ol><li>不要重置具有内置含义的操作符：重载逗号、取地址、逻辑与或等都不是好做法，这些操作符有内置含义。</li><li>大多数操作符对类对象没有意义。可以考虑逻辑映射到操作符操作，如相等测试重载<code>==</code>，输入输出重载移位操作符，测试对象为空重载非操作符。</li><li>复合赋值操作符。如重载<code>+</code>也要重载<code>+=</code>。</li><li>相等和关系操作符。<strong>将要用作关联容器键类型的类应该定义<code>&lt;</code>和<code>==</code>操作符</strong>。如果定义了相等操作符，也应该定义<code>!=</code>操作符。</li><li>选择类函数或普通非成员函数的指导原则：<ol><li>赋值、下标、调用、成员访问箭头(<code>=, [], (), -&gt;</code>)等操作符必须定义为成员。</li><li>复合操作符通常定义为类的成员。</li><li>改变对象状态或与给定类型紧密联系的其他一些操作符，如自增，自减，解引用，一般定义为类的成员。</li><li>对称操作符最好定义为普通非成员函数，如算数操作符、相等操作符、关系操作符和位操作符。</li></ol></li></ol><h2 id="输入输出操作符重载"><a class="markdownIt-Anchor" href="#输入输出操作符重载"></a> 输入输出操作符重载</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 重载输出操作符定义：</span></span><br><span class="line">ostream&amp;</span><br><span class="line">    <span class="keyword">operator</span> &lt;&lt;(ostream&amp; os, <span class="keyword">const</span> ClassType&amp; object) &#123;</span><br><span class="line">    <span class="comment">// prepare object</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// output</span></span><br><span class="line">    os &lt;&lt; ...</span><br><span class="line">    <span class="keyword">return</span> os;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 如Sales_item</span></span><br><span class="line">ostream&amp;</span><br><span class="line">    <span class="keyword">operator</span> &lt;&lt;(ostream&amp; os, <span class="keyword">const</span> Sales_item&amp; s) &#123;</span><br><span class="line">    os &lt;&lt; s.isbn &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> os;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输入操作符</span></span><br><span class="line"><span class="comment">// 重要！！！输入操作符必须处理错误和文件结束的可能性</span></span><br><span class="line">istream&amp;</span><br><span class="line">    <span class="keyword">operator</span> &gt;&gt;(istream&amp; in, Sales_item&amp; s) &#123;</span><br><span class="line"> <span class="keyword">double</span> price;</span><br><span class="line">    in &gt;&gt; s.isbn &gt;&gt; s.units_sold &gt;&gt; price;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (in) s.revenue = s.units_sold * price;</span><br><span class="line">    <span class="comment">// if input error, reset Sales_item</span></span><br><span class="line">    <span class="keyword">else</span> s = <span class="built_in">Sales_item</span>();</span><br><span class="line">    <span class="keyword">return</span> in;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注：IO操作符必须为非成员函数，因为成员函数只能隐藏左操作数，所以预达到目标只能重载<code>ostream</code>，但是<code>ostream</code>却是在标准库中的，不能乱动…</p><h2 id="下标操作符"><a class="markdownIt-Anchor" href="#下标操作符"></a> 下标操作符</h2><p>类定义下标操作符时，一般需要定义两个版本：一个为非const成员并返回引用，另一个为const成员并返回const引用。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> &amp;<span class="keyword">operator</span>[] (<span class="keyword">const</span> <span class="keyword">size_t</span>);</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> &amp;<span class="keyword">operator</span> [](<span class="keyword">const</span> <span class="keyword">size_t</span>) <span class="keyword">const</span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; data;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span>&amp; <span class="keyword">operator</span> [](<span class="keyword">const</span> <span class="keyword">size_t</span> index) &#123;</span><br><span class="line">    <span class="keyword">return</span> data[index];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span>&amp; <span class="keyword">operator</span> [](<span class="keyword">const</span> <span class="keyword">size_t</span> index) <span class="keyword">const</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> data[index];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="成员访问操作符"><a class="markdownIt-Anchor" href="#成员访问操作符"></a> 成员访问操作符</h2><p>指针支持的基本操作有解引用操作和箭头操作，我们的类可以定义：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ScreenPtr</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// constructor and copy control memberes as before</span></span><br><span class="line">    Screen &amp;<span class="keyword">operator</span> *() &#123; <span class="keyword">return</span> *ptr-&gt;sp &#125;;</span><br><span class="line">    Screen *<span class="keyword">operator</span> -&gt;() &#123; <span class="keyword">return</span> ptr-&gt;sp &#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">const</span> Screen &amp;<span class="keyword">operator</span> *() <span class="keyword">const</span> &#123; <span class="keyword">return</span> *ptr-&gt;sp &#125;;</span><br><span class="line">    <span class="keyword">const</span> Screen *<span class="keyword">operator</span> -&gt;() <span class="keyword">const</span> &#123; <span class="keyword">return</span> ptr-&gt;sp &#125;;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    ScrPtr *ptr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="重载箭头操作符"><a class="markdownIt-Anchor" href="#重载箭头操作符"></a> 重载箭头操作符</h2><p><code>-&gt;</code>表现为接受一个对象和一个成员名。由编译器处理获得成员的工作。所以，当我们编写如下代码：</p><p><code>point -&gt; action()</code></p><p>等价于编写</p><p><code>(point -&gt; action)()</code></p><p>换句话说，我们想调用对<code>point -&gt; action()</code>求值的结果，编译器将代码进行如下求值：</p><ol><li>如果<code>point</code>为指针，指向具有名为<code>action</code>的成员的类对象，则将编译为调用该对象的<code>action</code>成员；</li><li>否则，如果<code>action</code>是定义了<code>operator-&gt;</code>操作符的类的对象，则等价于<code>point.operator-&gt;()-&gt;action</code>。即执行<code>point</code>的<code>operator-&gt;()</code>，然后使用该结果再重复这三步。</li><li>否则，代码错误。</li></ol><p><strong>对重载箭头的返回值约束</strong>：重载箭头必须返回指向类类型的指针，或者返回定义了自己的箭头操作符的类类型对象。</p><ul><li>如果返回值是指针，则解引用，若没有该成员则编译器报错</li><li>如果返回值为类类型对象(或这种对象的引用)，则递归调用该操作符。</li></ul><h2 id="自增自减操作符重载"><a class="markdownIt-Anchor" href="#自增自减操作符重载"></a> 自增自减操作符重载</h2><p>C++不要求自增或自减操作符一定作为类的成员，但由于操作符改变对象状态，更倾向于作为成员。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 前缀操作符的实现(++ptr)：</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CheckedPtr</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    CheckedPtr&amp; <span class="keyword">operator</span>++() &#123;</span><br><span class="line">        <span class="comment">// 处理</span></span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 为了区别前后缀形式，后缀操作符函数接受一个额外的(无用的)int型形参，使用后编译器提供0作为形参的实参。</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CheckedPtr</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    CheckedPtr <span class="keyword">operator</span>++(<span class="keyword">int</span>) &#123;</span><br><span class="line">        <span class="comment">// 注：后缀返回的是旧值</span></span><br><span class="line">        <span class="function">CheckedPtr <span class="title">ret</span><span class="params">(*<span class="keyword">this</span>)</span></span>;</span><br><span class="line">        ++*<span class="keyword">this</span>;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 显式调用</span></span><br><span class="line"><span class="function">CheckedPtr <span class="title">parr</span><span class="params">(ia, ia + size)</span></span>;</span><br><span class="line">parr.<span class="keyword">operator</span>++(<span class="number">0</span>);<span class="comment">// 后缀形式</span></span><br><span class="line">parr.<span class="keyword">operator</span>++();  <span class="comment">// 前缀形式</span></span><br></pre></td></tr></table></figure><h2 id="调用操作符和函数对象"><a class="markdownIt-Anchor" href="#调用操作符和函数对象"></a> 调用操作符和函数对象</h2><p>函数对象：定义了调用操作符的类，其对象称为函数对象，即它们的行为类似函数的对象。</p><ol><li><p>函数对象用于标准库算法</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// old</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">GT6</span><span class="params">(<span class="keyword">const</span> string &amp;s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> s.<span class="built_in">size</span>() &gt;= <span class="number">6</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">vector&lt;string&gt;::sizetype wc = <span class="built_in">count_if</span>(words.<span class="built_in">begin</span>(), words.<span class="built_in">end</span>(), GT6);</span><br><span class="line"></span><br><span class="line"><span class="comment">// new</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GT_cls</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">GT_cls</span>(<span class="keyword">size_t</span> val = <span class="number">0</span>): <span class="built_in">bound</span>(val) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span> <span class="params">(<span class="keyword">const</span> string &amp;s)</span> </span>&#123; <span class="keyword">return</span> s.<span class="built_in">size</span>() &gt;= bound; &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::string::size_type bound;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">vector&lt;string&gt;::sizetype wc = <span class="built_in">count_if</span>(words.<span class="built_in">begin</span>(), words.<span class="built_in">end</span>(), <span class="built_in">GT_cls</span>(<span class="number">6</span>));</span><br></pre></td></tr></table></figure></li><li><p>函数对象的适配器和绑定器</p><ol><li>绑定器，是一种函数适配器，通过将一个操作数绑定到给定值而将二元函数对象转换为一元函数对象。</li><li>求反器，是一种函数适配器，将为其函数对象的真值求反。</li></ol><p>标准库定义了两个绑定器的适配器: <code>bind1st, bind2nd</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 计算一个容器中所有小于等于10的元素个数</span></span><br><span class="line"><span class="built_in">count_if</span>(vec.<span class="built_in">begin</span>(), vec.<span class="built_in">end</span>(), <span class="built_in">bind2nd</span>(less_equal&lt;<span class="keyword">int</span>&gt;(), <span class="number">10</span>));</span><br></pre></td></tr></table></figure><p>标准库定义了两个求反器: <code>not1, not2</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 对上个函数求反，即求所有大于10的元素个数</span></span><br><span class="line"><span class="built_in">count_if</span>(vec.<span class="built_in">begin</span>(), vec.<span class="built_in">end</span>(), <span class="built_in">not1</span>(<span class="built_in">bind2nd</span>(less_equal&lt;<span class="keyword">int</span>&gt;(), <span class="number">10</span>)));</span><br></pre></td></tr></table></figure></li></ol><h2 id="其他运算符重载"><a class="markdownIt-Anchor" href="#其他运算符重载"></a> 其他运算符重载</h2><ol><li>定义了<code>operator==</code>的类更容易与标准库一起使用，有些算法默认使用<code>==</code>运算符，如find。</li><li>关联容器以及某些算法，默认使用&lt;操作符。一般而言，关系操作符，诸如相等操作符应定义为非成员函数。</li><li>无论形参为何种类型，赋值操作符必须定义为成员函数。且赋值操作符和复合赋值操作符应返回左操作数的引用。</li></ol><h1 id="转换与类类型"><a class="markdownIt-Anchor" href="#转换与类类型"></a> 转换与类类型</h1><h2 id="转换操作符"><a class="markdownIt-Anchor" href="#转换操作符"></a> 转换操作符</h2><p>转换操作符是一种特殊的<strong>类成员函数</strong>，定义将类类型值转变为其他类型值的转换。<strong>在类定义体内声明</strong>，格式如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 形式：operator type()</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SmallInt</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">SmallInt</span>(<span class="keyword">int</span> i = <span class="number">0</span>): <span class="built_in">val</span>(i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; <span class="number">0</span> || i &gt; <span class="number">255</span>)</span><br><span class="line">            <span class="keyword">throw</span> std::<span class="built_in">out_of_range</span>(<span class="string">&quot;Bad!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">operator</span> <span class="title">int</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> val; &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::<span class="keyword">size_t</span> val;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中，<code>type</code>表示<strong>内置类型名、类类型名或由类型别名所定义的名字</strong>。对任何可作为函数返回类型的类型(<code>void</code>除外)都可以定义转换函数。</p><ol><li><p>一般而言，不允许转换为数组或函数类型，但允许转换为指针类型(数据和函数的指针)以及引用类型。</p></li><li><p>使用转换函数时，被转换的类型不必与所需要的类型完全匹配。例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SmallInt si;</span><br><span class="line"><span class="keyword">double</span> dval;</span><br><span class="line">si &gt;= dval;</span><br></pre></td></tr></table></figure><p><code>SmallInt</code>首先转换为<code>int</code>类型，然后<code>int</code>转换为<code>double</code>的值。</p></li><li><p>**类类型转换以后不能在跟一个类类型转换！！**如果需要多个类类型转换，则代码会错误。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 假定另一个类Integral，可以转换为SmallInt但不能转换为Int</span></span><br><span class="line"><span class="function">Itergral <span class="title">intVal</span><span class="params">(<span class="number">1</span>)</span></span>;</span><br><span class="line"><span class="function">SmallInt <span class="title">si</span><span class="params">(intval)</span></span>;<span class="comment">//ok, Integral-&gt;SmallInt</span></span><br><span class="line"><span class="keyword">int</span> i = si;<span class="comment">//ok, SmallInt-&gt;int</span></span><br><span class="line"><span class="keyword">int</span> j = intval<span class="comment">//error, Integral -x-&gt; int</span></span><br></pre></td></tr></table></figure></li><li><p>标准转换可放在类类型转换之前。</p></li></ol><h2 id="实参匹配与转换"><a class="markdownIt-Anchor" href="#实参匹配与转换"></a> 实参匹配与转换</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 我们为SmallInt加上另外两个转换</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SmallInt</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">SmallInt</span>(<span class="keyword">int</span> = <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">SmallInt</span>(<span class="keyword">double</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">operator</span> <span class="title">int</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> val; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">operator</span> <span class="title">double</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;<span class="keyword">return</span> val; &#125;</span><br><span class="line">    </span><br><span class="line">    std::<span class="keyword">size_t</span> val;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><p>实参匹配和多个转换操作符：</p><p>一般而言，给出一个类与两个内置类型之间的转换是不好的做法，例如下述例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">compute</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fp_compute</span><span class="params">(<span class="keyword">double</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">extend_compute</span><span class="params">(<span class="keyword">long</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">SmallInt si;</span><br><span class="line"><span class="built_in">compute</span>(si);<span class="comment">// SmallInt -&gt; int</span></span><br><span class="line"><span class="built_in">fp_compute</span>(si);<span class="comment">// SmallInt -&gt; double</span></span><br><span class="line"><span class="built_in">extend_compute</span>(si);<span class="comment">// error! ambiguous!</span></span><br></pre></td></tr></table></figure></li><li><p>实参匹配和构造函数转换</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">manip</span><span class="params">(<span class="keyword">const</span> SmallInt &amp;)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">double</span> d; <span class="keyword">int</span> i; <span class="keyword">long</span> l;</span><br><span class="line"><span class="built_in">manip</span>(d);<span class="comment">// ok: use SmallInt(double)</span></span><br><span class="line"><span class="built_in">manip</span>(i);<span class="comment">// ok: use SmallInt(int)</span></span><br><span class="line"><span class="built_in">manip</span>(l);<span class="comment">// error! ambiguous!</span></span><br></pre></td></tr></table></figure></li><li><p>当两个类定义了转换时的二义性</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Integral</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SmallInt</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">SmallInt</span>(Integral);<span class="comment">// convert from Integral to SmallInt</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Integral</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">operator</span> <span class="title">SmallInt</span><span class="params">()</span> <span class="keyword">const</span></span>; <span class="comment">// convert from Integral to SmallInt</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// main</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">compute</span><span class="params">(SmallInt)</span></span>;</span><br><span class="line">Integral int_val;</span><br><span class="line"><span class="built_in">compute</span>(int_val);<span class="comment">//error! ambigouos!</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">compute</span>(<span class="built_in">SmallInt</span>(int_val));<span class="comment">// ok</span></span><br><span class="line"><span class="built_in">compute</span>(int_val.<span class="keyword">operator</span> <span class="built_in">SmallInt</span>());<span class="comment">// ok</span></span><br></pre></td></tr></table></figure></li></ol><h2 id="重载确定和类的实参"><a class="markdownIt-Anchor" href="#重载确定和类的实参"></a> 重载确定和类的实参</h2><ol><li><p>在需要转换函数的实参时，编译器自动应用类的转换操作符或构造函数。于是函数重载确定由三部分组成：</p><ol><li><p>确定候选函数集合：与被调用函数同名的函数。</p></li><li><p>确定可行函数：形参数目、类型与函数调用中的实参相匹配的候选函数。如果有转换操作，编译器还需确定使用哪个转换操作。</p></li><li><p>选择最佳匹配的函数。</p></li></ol></li><li><p>转换操作符之后的标准转换</p><p>哪个函数是最佳匹配，可能依赖于匹配不同函数中是否涉及了一个或多个类类型转换：</p><ul><li><p>如果重载集中的两个函数可以使用同一转换函数匹配，则使用在转换之后或之前的标准转换序列的等级确定哪个函数为最佳匹配；</p></li><li><p>否则，如果使用不同的转换操作，则认为两个转换是一样好的匹配，不管标准转换的等级如何。</p></li></ul></li><li><p>面对二义性转换，程序员可以使用强制转换显式指定应用哪个转换操作：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">compute</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">compute</span><span class="params">(<span class="keyword">double</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">SmallInt si;</span><br><span class="line"><span class="built_in">compute</span>(<span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(si));</span><br></pre></td></tr></table></figure></li><li><p>标准转换和构造函数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SmallInt</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">SmallInt</span>(<span class="keyword">int</span> = <span class="number">0</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Integral</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Integral</span>(<span class="keyword">int</span> = <span class="number">0</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">manip</span><span class="params">(<span class="keyword">const</span> Integral)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">manip</span><span class="params">(<span class="keyword">const</span> SmallInt)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">manip</span>(<span class="number">10</span>);<span class="comment">// error! ambiguous!</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 即使一个类定义了实参需要标准转换的构造函数，该函数调用也具有二义性。</span></span><br><span class="line"><span class="comment">// 原因见本节第二点</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用显式构造消除二义性</span></span><br><span class="line"><span class="built_in">manip</span>(<span class="built_in">SmallInt</span>(<span class="number">10</span>));</span><br><span class="line"><span class="built_in">manip</span>(<span class="built_in">Integral</span>(<span class="number">10</span>));</span><br></pre></td></tr></table></figure></li></ol><h1 id="面向对象编程"><a class="markdownIt-Anchor" href="#面向对象编程"></a> 面向对象编程</h1><p>在C++中，通过基类的引用(或指针)调用虚函数时，发生动态绑定。引用(或指针)既可以指向基类对象也可以指向派生类对象，这是动态绑定的关键。用引用(或指针)调用的虚函数在<strong>运行时确定</strong>，被调用的函数是引用(或指针)所指对象的实际类型定义的。</p><h2 id="定义基类和派生类"><a class="markdownIt-Anchor" href="#定义基类和派生类"></a> 定义基类和派生类</h2><ol><li><p>派生类中虚函数的声明必须与基类中的定义方式完全匹配。但有一个例外：返回对基类型的引用(或指针)的虚函数，派生类中可以返回派生类的引用(或指针)。</p></li><li><p>声明派生类不需要包含派生列表。</p></li><li><p><code>virtual</code>与其他成员函数</p><ol><li><p>要触发动态绑定，必须实现两个条件：</p><ul><li>只有指定为虚函数的成员函数才可以进行动态绑定。</li><li>必须通过基类类型的引用或指针进行函数调用。</li></ul><p>当基类类型的引用和指针既可以指向基类类型，也可以指向派生类，因为派生类包含着基类。当使用指针或引用调用虚函数时，只有才运行时才可以确定指向的类型，并调用相应的函数。</p><p><strong>引用和指针的静态类型与动态类型可以不同</strong>，这是C++用以支持多态性的基石。</p></li><li><p>覆盖虚函数机制：派生类虚函数调用基类版本时，必须显式使用作用域操作符。如果派生函数忽略了这样做，则函数调用在运行时确定并且将是一个自身调用，从而导致无穷递归。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Bulk_item: Item_base</span></span><br><span class="line">Bulk_item derived;</span><br><span class="line">Item_base* baseP = &amp;derived;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用基类版本的虚函数</span></span><br><span class="line"><span class="keyword">double</span> b = baseP-&gt;Item_base::<span class="built_in">net_price</span>(<span class="number">42</span>);</span><br></pre></td></tr></table></figure></li><li><p>虚函数与默认实参：派生类对于默认形参省略了该实参，则会使用基类的默认形参！！！</p><p>所以基类与派生类的默认实参最好设置成一样的！</p></li></ol></li><li><p>公用、私有和受保护的继承</p><ul><li>公用继承：基类成员保持自己的访问级别。</li><li>受保护的继承：基类成员的<code>public</code>成员为派生类的<code>protected</code>成员。</li><li>私有继承：基类成员的所有成员在派生类中为<code>private</code>成员。</li></ul><ol><li><p>接口继承与实现继承：<code>private</code>和<code>protected</code>派生的类不继承基类的接口，这些派生通常被称为实现继承。</p></li><li><p>去除个别成员：尽管使用<code>private</code>或<code>protected</code>继承，但也可以使用<code>using</code>声明来从命名空间使用名字，保持访问等级：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">int</span> m;</span><br><span class="line">&#125;; </span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Extext</span>:</span> <span class="keyword">private</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">using</span> Base::m;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// main</span></span><br><span class="line">Base base;</span><br><span class="line"><span class="keyword">int</span> m = base.m;<span class="comment">// ok</span></span><br></pre></td></tr></table></figure></li><li><p>默认继承保护级别：<code>struct</code>保留字定义的类与用<code>class</code>定义的类唯一不同是默认的成员保护级别和默认的派生保护级别不同，其他无区别：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span> &#123;</span><span class="comment">/* ... */</span>&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">D1</span> :</span> Base &#123;<span class="comment">/* ... */</span>&#125;;<span class="comment">// public继承</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D2</span> :</span> Base &#123;<span class="comment">/* ... */</span>&#125;<span class="comment">// private继承</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 以下定义方式等价</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D3</span> :</span> <span class="keyword">public</span> Base &#123;<span class="comment">/* ... */</span>&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">D3</span> :</span> Base &#123;<span class="comment">/* ... */</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 以下定义方式等价</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D4</span> :</span> Base &#123;<span class="comment">/* ... */</span>&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">D4</span> :</span> <span class="keyword">private</span> Base &#123;<span class="comment">/* ... */</span>&#125;;</span><br></pre></td></tr></table></figure></li></ol></li><li><p>友元关系与继承：有缘关系不能继承。基类的友元对派生类的成员没有特殊访问权限。如果基类被授予友元关系，则只有基类具有特殊访问权限，该基类的派生类不能访问授予友元关系的类。</p></li><li><p>继承与静态成员：如果基类定义了<code>static</code>成员，则整个继承层次中只有一个这样的成员，无论从基类派生出多少个派生类，每个<code>static</code>成员只有一个实例。</p></li></ol><h2 id="转换与继承"><a class="markdownIt-Anchor" href="#转换与继承"></a> 转换与继承</h2><ol><li><p>引用转换不同于转换对象：</p><ul><li>可以将派生类型的对象传给希望接受基类引用的函数，引用直接绑定到该对象，但转换不会在任何方面改变派生类型对象，该对象仍是派生类型对象；</li><li>将派生类型对象传给希望接受基类对象(而不是引用)的函数时，派生类对象的基类部分被复制到形参，形参类型便是固定的——编译与运行时均为基类对象。</li></ul></li><li><p>用派生类对象对基类对象进行初始化或赋值：</p><ul><li><p>基类一般(显式或隐式)定义自己的复制构造函数和赋值操作符，这些成员接受一个形参，<strong>该形参是基类类型的<code>const</code>引用</strong>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Item_base item;</span><br><span class="line">Bulk_item bulk;</span><br><span class="line"><span class="comment">// ok, use Item_base::Item_base(const Item_base&amp;)</span></span><br><span class="line"><span class="function">Item_base <span class="title">item</span><span class="params">(bulk)</span></span>;</span><br><span class="line"><span class="comment">// ok, call Item_base::operator=(const Item_base&amp;)</span></span><br><span class="line">item = bulk;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">转换步骤：</span></span><br><span class="line"><span class="comment">1. Bulk_item对象转换为Item_base引用</span></span><br><span class="line"><span class="comment">2. 将该引用作为实参传给复制构造函数或赋值操作符</span></span><br><span class="line"><span class="comment">3. 使用Bulk_item的Item_base部分分别调用构造函数或赋值的Item_base对象的成员进行初始化和赋值</span></span><br><span class="line"><span class="comment">4. 执行完毕后，对象即为Item_base，包含Bulk_item的Item_base部分的副本，但实参的Bulk_item部分被忽略</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>派生类到基类转换的可访问性：</p><ol><li><p>如果使用public继承，则用户代码和后代类都可以使用派生类到基类的转换；</p></li><li><p>如果使用private和protected继承，用户代码不能将派生类型对象转换为基类对象：</p><ul><li>如果是private继承，则从private继承类派生的类不能转换为基类；</li><li>如果是protected继承，则后续派生类的成员可以转换为基类类型；</li></ul></li><li><p>无论是什么派生访问标号，派生类本身都可以访问基类的public成员，因此派生类本身成员和友元总是可以访问派生类到基类的转换：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">int</span> m = <span class="number">1</span>;</span><br><span class="line">&#125;; </span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Extext</span>:</span> <span class="keyword">private</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">using</span> Base::m;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">function</span><span class="params">(<span class="keyword">const</span> Base&amp; base)</span> </span>&#123;</span><br><span class="line">std::cout &lt;&lt; base.m;</span><br><span class="line">&#125; </span><br><span class="line">    <span class="comment">// 这个函数体现了转换，本身的成员函数总是可以访问派生类到基类的转换的</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">display</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">function</span>(*<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// main</span></span><br><span class="line">Extext ex;</span><br><span class="line">ex.<span class="built_in">display</span>();</span><br></pre></td></tr></table></figure></li></ol></li><li><p>基类到派生类的转换：没有从基类到派生类的自动转换，使用基类指针或引用实际绑定到派生类对象时，同样存在限制；如果知道基类到派生类转换是安全的，可以使用<code>static_case</code>或<code>dynamic_cast</code>进行转换。</p></li></ol><h2 id="构造函数与复制控制"><a class="markdownIt-Anchor" href="#构造函数与复制控制"></a> 构造函数与复制控制</h2><ol><li><p>派生类可以在自己构造函数的初始化列表中向基类的构造函数进行参数传递。</p></li><li><p>一个类只能初始化自己的<strong>直接基类</strong>！</p></li><li><p>定义派生类复制构造函数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span> &#123;</span> <span class="comment">/* ... */</span> &#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span>:</span> <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// Base::Base(const Base&amp;) 不会被自动调用，需要使用初始化函数Base(d)</span></span><br><span class="line">    <span class="built_in">Derived</span>(<span class="keyword">const</span> Derived&amp; d) &#123;</span><br><span class="line">        <span class="built_in">Base</span>(d);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>初始化函数<code>Base(d)</code>将派生类对象d转换为它的基类部分的引用，并调用基类复制构造函数。</p></li><li><p>派生类赋值操作符：如果派生类定义了自己的赋值操作符，该操作符必须对基类部分进行显式赋值：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Derived &amp;Derived::<span class="keyword">operator</span>=(<span class="keyword">const</span> Derived&amp; rhs) &#123;</span><br><span class="line">    <span class="comment">// 必须防止自身赋值</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span> != &amp;rhs) &#123;</span><br><span class="line">        Base::<span class="keyword">operator</span>=(rhs);</span><br><span class="line">        <span class="comment">// do something...</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>派生类的析构函数：每个析构函数只负责清除自己的成员。对象撤销顺序与构造函数相反，按继承层次依次向上调用。</p></li><li><p>虚析构函数：删除指向动态分配对象的指针时，指针的静态类型可能与被删除对象的动态类型不同，可能会删除实际指向派生类对象的基类类型指针。</p><p>要保证运行适当的析构函数，基类中的析构函数必须为虚函数。那么通过指针调用时，运行哪个析构函数将因指针所指对象类型的不同而不同。</p><p>所以，即使析构函数没有工作要做，继承层次的根类也应该定义一个虚析构函数。</p></li><li><p>构造函数和赋值操作符不是虚函数！</p><ul><li>构造函数在运行时，对象的动态类型是不完整的；</li><li>虚函数要求形式完全相同，而赋值操作符中每个类都有一个与类本身相同的形参。</li></ul></li><li><p>构造函数和析构函数中的虚函数：</p><p>在构造派生类对象时首先会运行基类的构造函数，而在撤销派生类对象时，会按照构造顺序的逆序撤销基类部分。在这两种情况下运行构造函数或析构函数，对象都是不完整的，编译器将对象的类型视为在构造和析构期间发生了变化。在基类构造函数或析构函数中，将派生类对象视为基类对象看待，<strong>这对虚函数的绑定有影响</strong>。</p><p><strong>如果在构造函数或析构函数中调用虚函数，则运行的是为构造函数或析构函数自身类型定义的版本</strong>。</p></li></ol><h2 id="纯虚函数"><a class="markdownIt-Anchor" href="#纯虚函数"></a> 纯虚函数</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Disc_item</span>:</span> <span class="keyword">public</span> Item_base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">net_price</span><span class="params">(std::<span class="keyword">size_t</span>)</span> <span class="keyword">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在函数形参表后面写上=0以指定纯虚函数。</p><p>含有(或继承)一个或多个纯虚函数的类是抽象基类，除了作为抽象基类的派生类的对象的组成部分，不能创建抽象类型的对象。</p><h2 id="容器与继承"><a class="markdownIt-Anchor" href="#容器与继承"></a> 容器与继承</h2><p>因为派生类对象在赋值给基类对象时会被&quot;切掉&quot;，所以容器与通过继承相关的类型不能很好的融合。</p><h2 id="句柄类与继承"><a class="markdownIt-Anchor" href="#句柄类与继承"></a> 句柄类与继承</h2><ol><li><p>句柄类存储和管理基类指针。指针所指对象的类型可以变化，既可以指向基类类型对象又可以指向派生类型对象。用户通过句柄类访问继承层次的操作。句柄类类似指针执行操作，<strong>虚成员</strong>的行为将在运行时根据句柄实际绑定的对象类型而变化。</p></li><li><p>复制未知类型：句柄类经常需要在不知道对象的确切类型时分配已知对象的新副本。解决这个问题的通常方法是定义<strong>虚操作</strong>进行复制，称该操作为clone。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 基类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Item_base</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> Item_base* <span class="title">clone</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Item_base</span>(*<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 派生类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bulk_item</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> Bulk_item* <span class="title">clone</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Bulk_item</span>(*<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>句柄的使用</p><ol><li><p>使用带比较器的关联容器</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">compare</span><span class="params">(<span class="keyword">const</span> Sales_item&amp; lhs, <span class="keyword">const</span> Sales_item&amp; rhs)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> lhs-&gt;<span class="built_in">book</span>() &lt; rhs-&gt;<span class="built_in">book</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">bool</span> <span class="params">(*Comp)</span> <span class="params">(<span class="keyword">const</span> Sales_item&amp;, <span class="keyword">const</span> Sales_item&amp;)</span></span>;</span><br><span class="line"><span class="function">std::multiset&lt;Sales_item, Comp&gt; <span class="title">items</span><span class="params">(compare)</span></span>;</span><br></pre></td></tr></table></figure></li><li><p>使用句柄执行虚函数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">Basket::total</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">double</span> sum = <span class="number">0.0</span>;</span><br><span class="line">    <span class="keyword">for</span> (const_iter iter = items.<span class="built_in">begin</span>(); </span><br><span class="line">         iter != items.<span class="built_in">end</span>(); </span><br><span class="line">         iter = items.<span class="built_in">upper_bound</span>(*iter)) &#123;</span><br><span class="line">        sum += (*iter)-&gt;<span class="built_in">net_price</span>(items.<span class="built_in">count</span>(*iter));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol></li></ol>]]></content>
    
    
    <summary type="html">C++ Primer学习笔记，这个书牛牛牛。</summary>
    
    
    
    <category term="CS" scheme="http://aflyingsheep.github.io/categories/CS/"/>
    
    
    <category term="CS" scheme="http://aflyingsheep.github.io/tags/CS/"/>
    
    <category term="C/C++" scheme="http://aflyingsheep.github.io/tags/C-C/"/>
    
  </entry>
  
  <entry>
    <title>C++：const在各个位置的含义</title>
    <link href="http://aflyingsheep.github.io/2023/02/23/cpp/const/"/>
    <id>http://aflyingsheep.github.io/2023/02/23/cpp/const/</id>
    <published>2023-02-23T09:37:06.000Z</published>
    <updated>2023-02-28T05:49:58.526Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="const在函数的各个位置"><a class="markdownIt-Anchor" href="#const在函数的各个位置"></a> const在函数的各个位置</h1><p>1.<code>const</code>在函数返回值前，表明返回值为<code>const</code></p><p><code>const int getNum() &#123; return i; &#125;    // 表示返回值为const</code></p><p>2.<code>const</code>在参数前面，表明参数为<code>const</code>，在函数体不能改变</p><p><code>int getNum(const int num) &#123;&#125;   //num在函数体中不能被改变</code></p><p>3.<code>const</code>在函数体后面，表示是类的常成员函数（函数体中可以把<code>this</code>看做是<code>const</code>，类的成员不能改变，只能调用其他常成员函数。<strong>即不可以修改该类的成员变量</strong>。）</p><p><code>public int getNum() const;</code></p><h1 id="const在指针定义的各个位置"><a class="markdownIt-Anchor" href="#const在指针定义的各个位置"></a> const在指针定义的各个位置</h1><p><code>const int a = 2;</code></p><p>`const int* p;</p><p>这种情况表示p是一个指向<code>const int</code>的指针。<code>p</code>可以改变，但是它指向的内容是不可变的。</p><p>`int const* p = &amp;a;</p><p>这种情况表示p是一个指向int的const指针。p的地址不可以改变，但是它指向的内容可变。比如<code>*p = 3;</code></p><p><code>const int const *p = &amp;a;</code></p><p><code>p</code>是一个指向<code>const int</code>的<code>const</code>指针。它指向的内容，和自身的地址都不可变。</p>]]></content>
    
    
    <summary type="html">const常量，在函数各个位置有不同含义</summary>
    
    
    
    <category term="C++" scheme="http://aflyingsheep.github.io/categories/C/"/>
    
    
    <category term="C++" scheme="http://aflyingsheep.github.io/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>线性方程组的迭代式求解方法</title>
    <link href="http://aflyingsheep.github.io/2023/02/10/math/sor/"/>
    <id>http://aflyingsheep.github.io/2023/02/10/math/sor/</id>
    <published>2023-02-10T12:22:06.000Z</published>
    <updated>2023-02-11T08:41:34.155Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="笔记图解"><a class="markdownIt-Anchor" href="#笔记图解"></a> 笔记图解</h1><p><img src="/image/j_gs_sor/1.jpeg" alt="1" /></p>]]></content>
    
    
    <summary type="html">详解Jacobi迭代法、Gauss-Seidel迭代法、SOR超松弛迭代法由一般形式转化为矩阵形式</summary>
    
    
    
    <category term="Math" scheme="http://aflyingsheep.github.io/categories/Math/"/>
    
    
    <category term="Math" scheme="http://aflyingsheep.github.io/tags/Math/"/>
    
  </entry>
  
  <entry>
    <title>cmake学习笔记</title>
    <link href="http://aflyingsheep.github.io/2023/01/30/linux/cmake/"/>
    <id>http://aflyingsheep.github.io/2023/01/30/linux/cmake/</id>
    <published>2023-01-30T13:27:06.000Z</published>
    <updated>2023-02-11T08:42:55.001Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>实验环境下载地址：<a href="https://github.com/AFlyingSheep/cmake-learn/archive/refs/heads/master.zip">Click me!</a></p><h1 id="cmake一个helloword"><a class="markdownIt-Anchor" href="#cmake一个helloword"></a> CMake一个HelloWord</h1><p>1、步骤一，写一个HelloWord</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#main.cpp</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">std::cout &lt;&lt;  <span class="string">&quot;hello word&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2、步骤二，写CMakeLists.txt</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">#CMakeLists.<span class="function">txt</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">PROJECT</span> <span class="params">(HELLO)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">SET</span><span class="params">(SRC_LIST main.cpp)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">MESSAGE</span><span class="params">(STATUS <span class="string">&quot;This is BINARY dir &quot;</span> $&#123;HELLO_BINARY_DIR&#125;)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">MESSAGE</span><span class="params">(STATUS <span class="string">&quot;This is SOURCE dir &quot;</span>$&#123;HELLO_SOURCE_DIR&#125;)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">ADD_EXECUTABLE</span><span class="params">(hello $&#123;SRC_LIST&#125;)</span></span></span><br></pre></td></tr></table></figure><p>3、步骤三、使用cmake，生成makefile文件</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">cmake .</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line">[root@localhost cmake]<span class="meta"># cmake .</span></span><br><span class="line"><span class="function">CMake <span class="title">Warning</span> <span class="params">(dev)</span> in CMakeLists.txt:</span></span><br><span class="line"><span class="function">  Syntax Warning in cmake code at</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">    /root/cmake/CMakeLists.txt:<span class="number">7</span>:<span class="number">37</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">  Argument not separated from preceding token by whitespace.</span></span><br><span class="line"><span class="function">This warning is for project developers.  Use -Wno-dev to suppress it.</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">-- The C compiler identification is GNU <span class="number">10.2</span><span class="number">.1</span></span></span><br><span class="line"><span class="function">-- The CXX compiler identification is GNU <span class="number">10.2</span><span class="number">.1</span></span></span><br><span class="line"><span class="function">-- Check for working C compiler: /usr/bin/cc</span></span><br><span class="line"><span class="function">-- Check for working C compiler: /usr/bin/cc -- works</span></span><br><span class="line"><span class="function">-- Detecting C compiler ABI info</span></span><br><span class="line"><span class="function">-- Detecting C compiler ABI info - done</span></span><br><span class="line"><span class="function">-- Check for working CXX compiler: /usr/bin/c++</span></span><br><span class="line"><span class="function">-- Check for working CXX compiler: /usr/bin/c++ -- works</span></span><br><span class="line"><span class="function">-- Detecting CXX compiler ABI info</span></span><br><span class="line"><span class="function">-- Detecting CXX compiler ABI info - done</span></span><br><span class="line"><span class="function">-- This is BINARY dir /root/cmake</span></span><br><span class="line"><span class="function">-- This is SOURCE dir /root/cmake</span></span><br><span class="line"><span class="function">-- Configuring done</span></span><br><span class="line"><span class="function">-- Generating done</span></span><br><span class="line"><span class="function">-- Build files have been written to: /root/cmake</span></span><br></pre></td></tr></table></figure><p>目录下就生成了这些文件-CMakeFiles, CMakeCache.txt, cmake_install.cmake 等文件，并且生成了Makefile.<br />现在不需要理会这些文件的作用，以后你也可以不去理会。最关键的是，它自动生成了Makefile.</p><p>4、使用make命令编译</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">root@localhost cmake]<span class="meta"># make</span></span><br><span class="line">Scanning dependencies of target hello</span><br><span class="line">[<span class="number">100</span>%] Building CXX object CMakeFiles/hello.dir/main.cpp.o</span><br><span class="line">Linking CXX executable hello</span><br><span class="line">[<span class="number">100</span>%] Built target hello</span><br></pre></td></tr></table></figure><p>5、最终生成了Hello的可执行程序</p><h1 id="cmake一个helloword-的语法介绍"><a class="markdownIt-Anchor" href="#cmake一个helloword-的语法介绍"></a> CMake一个HelloWord-的语法介绍</h1><h2 id="project关键字"><a class="markdownIt-Anchor" href="#project关键字"></a> PROJECT关键字</h2><p>可以用来指定工程的名字和支持的语言，默认支持所有语言</p><p>PROJECT (HELLO)   指定了工程的名字，并且支持所有语言—建议</p><p>PROJECT (HELLO CXX)      指定了工程的名字，并且支持语言是C++</p><p>PROJECT (HELLO C CXX)      指定了工程的名字，并且支持语言是C和C++</p><p>该指定隐式定义了两个CMAKE的变量</p><p><projectname>_BINARY_DIR，本例中是 HELLO_BINARY_DIR</p><p><projectname>_SOURCE_DIR，本例中是 HELLO_SOURCE_DIR</p><p>MESSAGE关键字就可以直接使用者两个变量，当前都指向当前的工作目录，后面会讲外部编译</p><p>问题：如果改了工程名，这两个变量名也会改变</p><p>解决：又定义两个预定义变量：PROJECT_BINARY_DIR和PROJECT_SOURCE_DIR，这两个变量和HELLO_BINARY_DIR，HELLO_SOURCE_DIR是一致的。所以改了工程名也没有关系</p><h2 id="set关键字"><a class="markdownIt-Anchor" href="#set关键字"></a> SET关键字</h2><p>用来显示的指定变量的</p><p>SET(SRC_LIST main.cpp)    SRC_LIST变量就包含了main.cpp</p><p>也可以 SET(SRC_LIST main.cpp t1.cpp t2.cpp)</p><h2 id="message关键字"><a class="markdownIt-Anchor" href="#message关键字"></a> MESSAGE关键字</h2><p>向终端输出用户自定义的信息</p><p>主要包含三种信息：</p><ul><li>SEND_ERROR，产生错误，生成过程被跳过。</li><li>SATUS，输出前缀为—的信息。</li><li>FATAL_ERROR，立即终止所有 cmake 过程.</li></ul><h2 id="add_executable关键字"><a class="markdownIt-Anchor" href="#add_executable关键字"></a> ADD_EXECUTABLE关键字</h2><p>生成可执行文件</p><p>ADD_EXECUTABLE(hello ${SRC_LIST})     生成的可执行文件名是hello，源文件读取变量SRC_LIST中的内容</p><p>也可以直接写 ADD_EXECUTABLE(hello main.cpp)</p><p>上述例子可以简化的写成</p><p>PROJECT(HELLO)<br />ADD_EXECUTABLE(hello main.cpp)</p><p>注意：工程名的 HELLO 和生成的可执行文件 hello 是没有任何关系的</p><h1 id="语法的基本原则"><a class="markdownIt-Anchor" href="#语法的基本原则"></a> 语法的基本原则</h1><ul><li><p>变量使用${}方式取值，但是在 IF 控制语句中是直接使用变量名</p></li><li><p>指令(参数 1 参数 2…) 参数使用括弧括起，参数之间使用空格或分号分开。 以上面的 ADD_EXECUTABLE 指令为例，如果存在另外一个 func.cpp 源文件</p><p>就要写成：ADD_EXECUTABLE(hello main.cpp func.cpp)或者ADD_EXECUTABLE(hello main.cpp;func.cpp)</p></li><li><p>指令是大小写无关的，参数和变量是大小写相关的。但，推荐你全部使用大写指令</p></li></ul><h2 id="语法注意事项"><a class="markdownIt-Anchor" href="#语法注意事项"></a> 语法注意事项</h2><ul><li>SET(SRC_LIST main.cpp) 可以写成 SET(SRC_LIST “main.cpp”)，如果源文件名中含有空格，就必须要加双引号</li><li>ADD_EXECUTABLE(hello main) 后缀可以不写，他会自动去找.c和.cpp，最好不要这样写，可能会有这两个文件main.cpp和main</li></ul><h1 id="内部构建和外部构建"><a class="markdownIt-Anchor" href="#内部构建和外部构建"></a> 内部构建和外部构建</h1><ul><li>上述例子就是内部构建，他生产的临时文件特别多，不方便清理</li><li>外部构建，就会把生成的临时文件放在build目录下，不会对源文件有任何影响强烈使用外部构建方式</li></ul><h2 id="外部构建方式举例"><a class="markdownIt-Anchor" href="#外部构建方式举例"></a> 外部构建方式举例</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//例子目录，CMakeLists.txt和上面例子一致</span></span><br><span class="line">[root@localhost cmake]<span class="meta"># pwd</span></span><br><span class="line">/root/cmake</span><br><span class="line">[root@localhost cmake]<span class="meta"># ll</span></span><br><span class="line">total <span class="number">8</span></span><br><span class="line">-rw-r--r--. <span class="number">1</span> root root <span class="number">198</span> Dec <span class="number">28</span> <span class="number">20</span>:<span class="number">59</span> CMakeLists.txt</span><br><span class="line">-rw-r--r--. <span class="number">1</span> root root  <span class="number">76</span> Dec <span class="number">28</span> <span class="number">00</span>:<span class="number">18</span> main.cpp</span><br></pre></td></tr></table></figure><p>1、建立一个build目录，可以在任何地方，建议在当前目录下</p><p>2、进入build，运行cmake …    当然…表示上一级目录，你可以写CMakeLists.txt所在的绝对路径，生产的文件都在build目录下了</p><p>3、在build目录下，运行make来构建工程</p><p>注意外部构建的两个变量</p><p>1、HELLO_SOURCE_DIR  还是工程路径</p><p>2、HELLO_BINARY_DIR   编译路径 也就是 /root/cmake/bulid</p><h1 id="让hello-world看起来更像一个工程"><a class="markdownIt-Anchor" href="#让hello-world看起来更像一个工程"></a> 让Hello World看起来更像一个工程</h1><ul><li>为工程添加一个子目录 src，用来放置工程源代码</li><li>添加一个子目录 doc，用来放置这个工程的文档 hello.txt</li><li>在工程目录添加文本文件 COPYRIGHT, README</li><li>在工程目录添加一个 <a href="http://runhello.sh/">runhello.sh</a> 脚本，用来调用 hello 二进制</li><li>将构建后的目标文件放入构建目录的 bin 子目录</li><li>将 doc 目录 的内容以及 COPYRIGHT/README 安装到/usr/share/doc/cmake/</li></ul><h2 id="将目标文件放入构建目录的-bin-子目录"><a class="markdownIt-Anchor" href="#将目标文件放入构建目录的-bin-子目录"></a> 将目标文件放入构建目录的 bin 子目录</h2><p>每个目录下都要有一个CMakeLists.txt说明</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost cmake]<span class="meta"># tree</span></span><br><span class="line">.</span><br><span class="line">├── build</span><br><span class="line">├── CMakeLists.txt</span><br><span class="line">└── src</span><br><span class="line">    ├── CMakeLists.txt</span><br><span class="line">    └── main.cpp</span><br></pre></td></tr></table></figure><p>外层CMakeLists.txt</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">PROJECT</span>(HELLO)</span><br><span class="line"><span class="built_in">ADD_SUBDIRECTORY</span>(src bin)</span><br></pre></td></tr></table></figure><p>src下的CMakeLists.txt</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">ADD_EXECUTABLE</span>(hello main.cpp)</span><br></pre></td></tr></table></figure><h3 id="add_subdirectory-指令"><a class="markdownIt-Anchor" href="#add_subdirectory-指令"></a> ADD_SUBDIRECTORY 指令</h3><p>ADD_SUBDIRECTORY(source_dir [binary_dir] [EXCLUDE_FROM_ALL])</p><ul><li><p>这个指令用于向当前工程添加存放源文件的子目录，并可以指定中间二进制和目标二进制存放的位置</p></li><li><p>EXCLUDE_FROM_ALL函数是将写的目录从编译中排除，如程序中的example</p></li><li><p>ADD_SUBDIRECTORY(src bin)</p><p>将 src 子目录加入工程并指定编译输出(包含编译中间结果)路径为bin 目录</p><p>如果不进行 bin 目录的指定，那么编译结果(包括中间结果)都将存放在build/src 目录</p></li></ul><h3 id="更改二进制的保存路径"><a class="markdownIt-Anchor" href="#更改二进制的保存路径"></a> 更改二进制的保存路径</h3><p>SET 指令重新定义 EXECUTABLE_OUTPUT_PATH 和 LIBRARY_OUTPUT_PATH 变量 来指定最终的目标二进制的位置</p><p>SET(EXECUTABLE_OUTPUT_PATH ${PROJECT_BINARY_DIR}/bin)<br />SET(LIBRARY_OUTPUT_PATH ${PROJECT_BINARY_DIR}/lib)</p><p>思考：加载哪个CMakeLists.txt当中</p><p>哪里要改变目标存放路径，就在哪里加入上述的定义，所以应该在src下的CMakeLists.txt下写</p><h1 id="安装"><a class="markdownIt-Anchor" href="#安装"></a> 安装</h1><ul><li>一种是从代码编译后直接 make install 安装</li><li>一种是打包时的指定 目录安装。<ul><li>简单的可以这样指定目录：make install DESTDIR=/tmp/test</li><li>稍微复杂一点可以这样指定目录：./configure –prefix=/usr</li></ul></li></ul><h2 id="如何安装helloword"><a class="markdownIt-Anchor" href="#如何安装helloword"></a> 如何安装HelloWord</h2><p>使用CMAKE一个新的指令：INSTALL</p><p>INSTALL的安装可以包括：二进制、动态库、静态库以及文件、目录、脚本等</p><p>使用CMAKE一个新的变量：CMAKE_INSTALL_PREFIX</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 目录树结构</span></span><br><span class="line">[root@localhost cmake]<span class="meta"># tree</span></span><br><span class="line">.</span><br><span class="line">├── build</span><br><span class="line">├── CMakeLists.txt</span><br><span class="line">├── COPYRIGHT</span><br><span class="line">├── doc</span><br><span class="line">│   └── hello.txt</span><br><span class="line">├── README</span><br><span class="line">├── runhello.sh</span><br><span class="line">└── src</span><br><span class="line">    ├── CMakeLists.txt</span><br><span class="line">    └── main.cpp</span><br><span class="line"></span><br><span class="line"><span class="number">3</span> directories, <span class="number">7</span> files</span><br></pre></td></tr></table></figure><h3 id="安装文件copyright和readme"><a class="markdownIt-Anchor" href="#安装文件copyright和readme"></a> 安装文件COPYRIGHT和README</h3><p>INSTALL(FILES COPYRIGHT README DESTINATION share/doc/cmake/)</p><p>FILES：文件</p><p>DESTINATION：</p><p>1、写绝对路径</p><p>2、可以写相对路径，相对路径实际路径是：${CMAKE_INSTALL_PREFIX}/&lt;DESTINATION 定义的路径&gt;</p><p>CMAKE_INSTALL_PREFIX  默认是在 /usr/local/</p><p>cmake -DCMAKE_INSTALL_PREFIX=/usr    在cmake的时候指定CMAKE_INSTALL_PREFIX变量的路径</p><h3 id="安装脚本runhellosh"><a class="markdownIt-Anchor" href="#安装脚本runhellosh"></a> <a href="http://xn--runhello-zh5o444ghv3d9ht.sh">安装脚本runhello.sh</a></h3><p>PROGRAMS：非目标文件的可执行程序安装(比如脚本之类)</p><p>INSTALL(PROGRAMS <a href="http://runhello.sh">runhello.sh</a> DESTINATION bin)</p><p>说明：实际安装到的是 /usr/bin</p><h3 id="安装-doc-中的-hellotxt"><a class="markdownIt-Anchor" href="#安装-doc-中的-hellotxt"></a> 安装 doc 中的 hello.txt</h3><ul><li><p>一、是通过在 doc 目录建立CMakeLists.txt ，通过install下的file</p></li><li><p>二、是直接在工程目录通过</p><p>INSTALL(DIRECTORY doc/ DESTINATION share/doc/cmake)</p></li></ul><p>DIRECTORY 后面连接的是所在 Source 目录的相对路径</p><p>注意：abc 和 abc/有很大的区别</p><p>目录名不以/结尾：这个目录将被安装为目标路径下的</p><p>目录名以/结尾：将这个目录中的内容安装到目标路径</p><h3 id="安装过程"><a class="markdownIt-Anchor" href="#安装过程"></a> 安装过程</h3><p>cmake …</p><p>make</p><p>make install</p><h1 id="静态库和动态库的构建"><a class="markdownIt-Anchor" href="#静态库和动态库的构建"></a> 静态库和动态库的构建</h1><p>任务：</p><p>１，建立一个静态库和动态库，提供 HelloFunc 函数供其他程序编程使用，HelloFunc 向终端输出 Hello World 字符串。</p><p>２，安装头文件与共享库。</p><p>静态库和动态库的区别</p><ul><li>静态库的扩展名一般为“.a”或“.lib”；动态库的扩展名一般为“.so”或“.dll”。</li><li>静态库在编译时会直接整合到目标程序中，编译成功的可执行文件可独立运行</li><li>动态库在编译时不会放到连接的目标程序中，即可执行文件无法单独运行。</li></ul><h2 id="构建实例"><a class="markdownIt-Anchor" href="#构建实例"></a> 构建实例</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost cmake2]<span class="meta"># tree</span></span><br><span class="line">.</span><br><span class="line">├── build</span><br><span class="line">├── CMakeLists.txt</span><br><span class="line">└── lib</span><br><span class="line">    ├── CMakeLists.txt</span><br><span class="line">    ├── hello.cpp</span><br><span class="line">    └── hello.h</span><br></pre></td></tr></table></figure><p>hello.h中的内容</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> HELLO_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Hello_H</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">HelloFunc</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>hello.cpp中的内容</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;hello.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">HelloFunc</span><span class="params">()</span></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Hello World&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>项目中的cmake内容</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">PROJECT</span>(HELLO)</span><br><span class="line"><span class="built_in">ADD_SUBDIRECTORY</span>(lib bin)</span><br></pre></td></tr></table></figure><p>lib中CMakeLists.txt中的内容</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">SET</span>(LIBHELLO_SRC hello.cpp)</span><br><span class="line"><span class="built_in">ADD_LIBRARY</span>(hello SHARED $&#123;LIBHELLO_SRC&#125;)</span><br></pre></td></tr></table></figure><h3 id="add_library"><a class="markdownIt-Anchor" href="#add_library"></a> ADD_LIBRARY</h3><p>ADD_LIBRARY(hello SHARED ${LIBHELLO_SRC})</p><ul><li>hello：就是正常的库名，生成的名字前面会加上lib，<a href="http://xn--libhello-x80mpzv93qwwbs3dby3f9mei53b.so">最终产生的文件是libhello.so</a></li><li>SHARED，动态库    STATIC，静态库</li><li>${LIBHELLO_SRC} ：源文件</li></ul><h3 id="同时构建静态和动态库"><a class="markdownIt-Anchor" href="#同时构建静态和动态库"></a> 同时构建静态和动态库</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 如果用这种方式，只会构建一个动态库，不会构建出静态库，虽然静态库的后缀是.a</span></span><br><span class="line"><span class="built_in">ADD_LIBRARY</span>(hello SHARED $&#123;LIBHELLO_SRC&#125;)</span><br><span class="line"><span class="built_in">ADD_LIBRARY</span>(hello STATIC $&#123;LIBHELLO_SRC&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 修改静态库的名字，这样是可以的，但是我们往往希望他们的名字是相同的，只是后缀不同而已</span></span><br><span class="line"><span class="built_in">ADD_LIBRARY</span>(hello SHARED $&#123;LIBHELLO_SRC&#125;)</span><br><span class="line"><span class="built_in">ADD_LIBRARY</span>(hello_static STATIC $&#123;LIBHELLO_SRC&#125;)</span><br></pre></td></tr></table></figure><h3 id="set_target_properties"><a class="markdownIt-Anchor" href="#set_target_properties"></a> SET_TARGET_PROPERTIES</h3><p>这条指令可以用来设置输出的名称，对于动态库，还可以用来指定动态库版本和 API 版本</p><p>同时构建静态和动态库</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">SET</span>(LIBHELLO_SRC hello.cpp)</span><br><span class="line"></span><br><span class="line"><span class="built_in">ADD_LIBRARY</span>(hello_static STATIC $&#123;LIBHELLO_SRC&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">//对hello_static的重名为hello</span></span><br><span class="line"><span class="built_in">SET_TARGET_PROPERTIES</span>(hello_static PROPERTIES  OUTPUT_NAME <span class="string">&quot;hello&quot;</span>)</span><br><span class="line"><span class="comment">//cmake 在构建一个新的target 时，会尝试清理掉其他使用这个名字的库，因为，在构建 libhello.so 时， 就会清理掉 libhello.a</span></span><br><span class="line"><span class="built_in">SET_TARGET_PROPERTIES</span>(hello_static PROPERTIES CLEAN_DIRECT_OUTPUT <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">ADD_LIBRARY</span>(hello SHARED $&#123;LIBHELLO_SRC&#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">SET_TARGET_PROPERTIES</span>(hello PROPERTIES  OUTPUT_NAME <span class="string">&quot;hello&quot;</span>)</span><br><span class="line"><span class="built_in">SET_TARGET_PROPERTIES</span>(hello PROPERTIES CLEAN_DIRECT_OUTPUT <span class="number">1</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="动态库的版本号"><a class="markdownIt-Anchor" href="#动态库的版本号"></a> 动态库的版本号</h3><p>一般动态库都有一个版本号的关联</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">libhello.so<span class="number">.1</span><span class="number">.2</span></span><br><span class="line">libhello.so -&gt;libhello.so<span class="number">.1</span></span><br><span class="line">libhello.so<span class="number">.1</span>-&gt;libhello.so<span class="number">.1</span><span class="number">.2</span></span><br></pre></td></tr></table></figure><p>CMakeLists.txt 插入如下</p><p><code>SET_TARGET_PROPERTIES(hello PROPERTIES VERSION 1.2 SOVERSION 1)</code></p><p>VERSION 指代动态库版本，SOVERSION 指代 API 版本。</p><h3 id="安装共享库和头文件"><a class="markdownIt-Anchor" href="#安装共享库和头文件"></a> 安装共享库和头文件</h3><p>本例中我们将 hello 的共享库安装到<prefix>/lib目录，</p><p>将 hello.h 安装到<prefix>/include/hello 目录</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//文件放到该目录下</span></span><br><span class="line"><span class="built_in">INSTALL</span>(FILES hello.h DESTINATION include/hello)</span><br><span class="line"></span><br><span class="line"><span class="comment">//二进制，静态库，动态库安装都用TARGETS</span></span><br><span class="line"><span class="comment">//ARCHIVE 特指静态库，LIBRARY 特指动态库，RUNTIME 特指可执行目标二进制。</span></span><br><span class="line"><span class="built_in">INSTALL</span>(TARGETS hello hello_static LIBRARY DESTINATION lib ARCHIVE DESTINATION lib)</span><br></pre></td></tr></table></figure><p>注意：</p><p>安装的时候，指定一下路径，放到系统下</p><p><code>cmake -DCMAKE_INSTALL_PREFIX=/usr ..</code></p><h3 id="使用外部共享库和头文件"><a class="markdownIt-Anchor" href="#使用外部共享库和头文件"></a> 使用外部共享库和头文件</h3><p>准备工作，新建一个目录来使用外部共享库和头文件</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@MiWiFi-R4CM-srv cmake3]<span class="meta"># tree</span></span><br><span class="line">.</span><br><span class="line">├── build</span><br><span class="line">├── CMakeLists.txt</span><br><span class="line">└── src</span><br><span class="line">    ├── CMakeLists.txt</span><br><span class="line">    └── main.cpp</span><br></pre></td></tr></table></figure><p>main.cpp</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;hello.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">HelloFunc</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="解决make后头文件找不到的问题"><a class="markdownIt-Anchor" href="#解决make后头文件找不到的问题"></a> 解决：make后头文件找不到的问题</h3><p>PS：include &lt;hello/hello.h&gt;  这样include是可以，这么做的话，就没啥好讲的了</p><p>关键字：INCLUDE_DIRECTORIES    这条指令可以用来向工程添加多个特定的头文件搜索路径，路径之间用空格分割</p><p>在CMakeLists.txt中加入头文件搜索路径</p><p>INCLUDE_DIRECTORIES(/usr/include/hello)</p><h3 id="解决找到引用的函数问题"><a class="markdownIt-Anchor" href="#解决找到引用的函数问题"></a> 解决：找到引用的函数问题</h3><p>报错信息：undefined reference to `HelloFunc()’</p><p>关键字：LINK_DIRECTORIES     添加非标准的共享库搜索路径</p><p>指定第三方库所在路径，LINK_DIRECTORIES(/home/myproject/libs)</p><p>关键字：TARGET_LINK_LIBRARIES    添加需要链接的共享库</p><p>TARGET_LINK_LIBRARIES的时候，只需要给出动态链接库的名字就行了。</p><p>在CMakeLists.txt中插入链接共享库，主要要插在executable的后面</p><p>查看main的链接情况</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[root@MiWiFi-R4CM-srv bin]<span class="meta"># ldd main </span></span><br><span class="line">linux-vdso.so<span class="number">.1</span> =&gt;  (<span class="number">0x00007ffedfda4000</span>)</span><br><span class="line">libhello.so =&gt; /lib64/libhello.<span class="built_in">so</span> (<span class="number">0x00007f41c0d8f000</span>)</span><br><span class="line">libstdc++.so<span class="number">.6</span> =&gt; /lib64/libstdc++.so<span class="number">.6</span> (<span class="number">0x00007f41c0874000</span>)</span><br><span class="line">libm.so<span class="number">.6</span> =&gt; /lib64/libm.so<span class="number">.6</span> (<span class="number">0x00007f41c0572000</span>)</span><br><span class="line">libgcc_s.so<span class="number">.1</span> =&gt; /lib64/libgcc_s.so<span class="number">.1</span> (<span class="number">0x00007f41c035c000</span>)</span><br><span class="line">libc.so<span class="number">.6</span> =&gt; /lib64/libc.so<span class="number">.6</span> (<span class="number">0x00007f41bff8e000</span>)</span><br><span class="line">/lib64/ld-linux-x86<span class="number">-64.</span>so<span class="number">.2</span> (<span class="number">0x00007f41c0b7c000</span>)</span><br></pre></td></tr></table></figure><p>链接静态库</p><p><code>TARGET_LINK_LIBRARIES(main libhello.a)</code></p><h3 id="特殊的环境变量-cmake_include_path-和-cmake_library_path"><a class="markdownIt-Anchor" href="#特殊的环境变量-cmake_include_path-和-cmake_library_path"></a> 特殊的环境变量 CMAKE_INCLUDE_PATH 和 CMAKE_LIBRARY_PATH</h3><p>注意：这两个是环境变量而不是 cmake 变量，可以在linux的bash中进行设置</p><p>我们上面例子中使用了绝对路径INCLUDE_DIRECTORIES(/usr/include/hello)来指明include路径的位置</p><p>我们还可以使用另外一种方式，使用环境变量export CMAKE_INCLUDE_PATH=/usr/include/hello</p><p>补充：生产debug版本的方法：<br />cmake … -DCMAKE_BUILD_TYPE=debug</p>]]></content>
    
    
    <summary type="html">cmake学习笔记，真好用真好用:-)</summary>
    
    
    
    <category term="linux" scheme="http://aflyingsheep.github.io/categories/linux/"/>
    
    
    <category term="C++" scheme="http://aflyingsheep.github.io/tags/C/"/>
    
    <category term="linux" scheme="http://aflyingsheep.github.io/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>C++：模板类和静态成员变量</title>
    <link href="http://aflyingsheep.github.io/2023/01/08/cpp/template_and_static/"/>
    <id>http://aflyingsheep.github.io/2023/01/08/cpp/template_and_static/</id>
    <published>2023-01-08T08:57:06.000Z</published>
    <updated>2023-02-11T13:10:34.737Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="c-模板类和静态成员变量"><a class="markdownIt-Anchor" href="#c-模板类和静态成员变量"></a> C++ 模板类和静态成员变量</h1><p>当一个模板类产生不同的类时，<strong>每个类产生的对象共享static变量</strong>，静态成员变量作用于类层面。即类间不共享，类内共享。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> size_type&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">hello</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> s_a;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">()</span> </span>&#123;</span><br><span class="line">s_a++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;; </span><br><span class="line"></span><br><span class="line"><span class="comment">// 模板类中静态变量的定义</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">size_type</span>&gt;</span> <span class="keyword">int</span> hello&lt;size_type&gt;::s_a = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">hello&lt;<span class="keyword">int</span>&gt; h3;</span><br><span class="line">hello&lt;<span class="keyword">char</span>&gt; h4; </span><br><span class="line"></span><br><span class="line">h3.<span class="built_in">add</span>();</span><br><span class="line">h4.<span class="built_in">add</span>();</span><br><span class="line">h4.<span class="built_in">add</span>();</span><br><span class="line"></span><br><span class="line">std::cout &lt;&lt; hello&lt;<span class="keyword">int</span>&gt;::s_a &lt;&lt; std::endl;</span><br><span class="line">std::cout &lt;&lt; hello&lt;<span class="keyword">char</span>&gt;::s_a &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    out:</span></span><br><span class="line"><span class="comment">    1</span></span><br><span class="line"><span class="comment">    2</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">当一个模板类产生不同的类时，每个类产生的对象共享static变量，静态成员变量作用于类层面</summary>
    
    
    
    <category term="C++" scheme="http://aflyingsheep.github.io/categories/C/"/>
    
    
    <category term="C++" scheme="http://aflyingsheep.github.io/tags/C/"/>
    
  </entry>
  
</feed>
