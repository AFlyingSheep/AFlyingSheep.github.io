<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>HPC基础：MPI+OPENMP | AFlyingSheep's Blog</title><meta name="keywords" content="HPC"><meta name="author" content="Johnson Shuangjian"><meta name="copyright" content="Johnson Shuangjian"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="高性能计算的编程基础，基于C++语言，入门HPC的第一站。">
<meta property="og:type" content="article">
<meta property="og:title" content="HPC基础：MPI+OPENMP">
<meta property="og:url" content="http://aflyingsheep.github.io/2022/08/05/mpi%20and%20openmp/openmp_MPI/index.html">
<meta property="og:site_name" content="AFlyingSheep&#39;s Blog">
<meta property="og:description" content="高性能计算的编程基础，基于C++语言，入门HPC的第一站。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://aflyingsheep.github.io/image/covers/hpc.png">
<meta property="article:published_time" content="2022-08-05T12:38:06.000Z">
<meta property="article:modified_time" content="2022-11-07T09:21:39.206Z">
<meta property="article:author" content="Johnson Shuangjian">
<meta property="article:tag" content="HPC">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://aflyingsheep.github.io/image/covers/hpc.png"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://aflyingsheep.github.io/2022/08/05/mpi%20and%20openmp/openmp_MPI/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://unpkg.com/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://unpkg.com/node-snackbar/dist/snackbar.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://unpkg.com/@fancyapps/ui/dist/fancybox.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#1f1f1f","position":"bottom-left"},
  source: {
    justifiedGallery: {
      js: 'https://unpkg.com/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://unpkg.com/flickr-justified-gallery/dist/fjGallery.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'HPC基础：MPI+OPENMP',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2022-11-07 17:21:39'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-math@4.0.0/dist/style.css">
<!-- hexo injector head_end end --><meta name="generator" content="Hexo 5.4.2"><link rel="alternate" href="/atom.xml" title="AFlyingSheep's Blog" type="application/atom+xml">
</head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/userhead.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">40</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">14</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">11</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/image/covers/picture/picture1.jpg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">AFlyingSheep's Blog</a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">HPC基础：MPI+OPENMP</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2022-08-05T12:38:06.000Z" title="发表于 2022-08-05 20:38:06">2022-08-05</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2022-11-07T09:21:39.206Z" title="更新于 2022-11-07 17:21:39">2022-11-07</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/CS/">CS</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/HPC/">HPC</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">5.7k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>27分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="HPC基础：MPI+OPENMP"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="mpi"><a class="markdownIt-Anchor" href="#mpi"></a> MPI</h1>
<h2 id="第一个并行程序"><a class="markdownIt-Anchor" href="#第一个并行程序"></a> 第一个并行程序</h2>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 第一个MPI程序</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">hello_world</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> greeting[MAX_STRING];</span><br><span class="line">    <span class="keyword">int</span> comm_sz; <span class="comment">// 进程核数</span></span><br><span class="line">    <span class="keyword">int</span> my_rank; <span class="comment">// 进程等级</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 进行所有必要的初始化设置，调用该函数前不得调用其他MPI函数</span></span><br><span class="line">    <span class="comment">// 同样存在MPI_Finalize()与其对应，在他们中间可以使用MPI函数</span></span><br><span class="line">    <span class="built_in">MPI_Init</span>(<span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Init的一个目的为用户启动程序时定义由用户启动所有进程所组成的通信子，成为MPI_COMM_WORLD</span></span><br><span class="line">    <span class="comment">// 注：下面两个函数第一个参数为通信子，第二个为输出</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回通信子进程数</span></span><br><span class="line">    <span class="built_in">MPI_Comm_size</span>(MPI_COMM_WORLD, &amp;comm_sz);</span><br><span class="line">    <span class="comment">// 返回正在调用进程在通信子中的进程号</span></span><br><span class="line">    <span class="built_in">MPI_Comm_rank</span>(MPI_COMM_WORLD, &amp;my_rank);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 消息发送与接收</span></span><br><span class="line">    <span class="comment">// 消息发送</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    int MPI_Send(</span></span><br><span class="line"><span class="comment">        void* msg_buf_p      , //指向包含信息内容的指针</span></span><br><span class="line"><span class="comment">        int   msg_size       ,</span></span><br><span class="line"><span class="comment">        MPI_Datatype msg_type, //数据量</span></span><br><span class="line"><span class="comment">        int   dest           , //目的</span></span><br><span class="line"><span class="comment">        int   tag            , //标签</span></span><br><span class="line"><span class="comment">        MPI_Comm communicator);//通信子</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="comment">// 消息接收</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    int MPI_Recv(</span></span><br><span class="line"><span class="comment">        void* msg_buf_p      ,</span></span><br><span class="line"><span class="comment">        int   buf_size       ,</span></span><br><span class="line"><span class="comment">        MPI_Datatype         ,</span></span><br><span class="line"><span class="comment">        int   source         ,</span></span><br><span class="line"><span class="comment">        int   tag            ,</span></span><br><span class="line"><span class="comment">        MPI_Comm communicator,</span></span><br><span class="line"><span class="comment">        MPI_Status* status_p //是一个输出！</span></span><br><span class="line"><span class="comment">        );</span></span><br><span class="line"><span class="comment">    )</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="comment">// 当recv_type = send_type &amp;&amp; recv_buf_sz &gt;= send_buf_sz，则可以被接受</span></span><br><span class="line">    <span class="comment">// 接收的SOURCE核TAG有通配符，但通信子没有。</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 0号进程用于接收信息并打印</span></span><br><span class="line">    <span class="keyword">if</span> (my_rank == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;I&#x27;m main process, greetings from process %d of %d!\n&quot;</span>, my_rank, comm_sz);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; comm_sz; i++) &#123;</span><br><span class="line">            <span class="comment">// 使用MPI_ANY_SOURCE保证按完成工作顺序打印,MPI_ANY_TAG同理</span></span><br><span class="line">            <span class="comment">//MPI_Recv(greeting, MAX_STRING, MPI_CHAR, i, 0, MPI_COMM_WORLD, MPI_STATUSES_IGNORE);</span></span><br><span class="line">            <span class="built_in">MPI_Recv</span>(greeting, MAX_STRING, MPI_CHAR, MPI_ANY_SOURCE, <span class="number">0</span>, MPI_COMM_WORLD, MPI_STATUSES_IGNORE);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, greeting);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 其他进程用于发送信息</span></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 输出信息到字符串greeting中</span></span><br><span class="line">        <span class="built_in">sprintf_s</span>(greeting, <span class="string">&quot;Greetings from process %d of %d!&quot;</span>, my_rank, comm_sz);</span><br><span class="line">        <span class="comment">// 将消息发送给0号进程</span></span><br><span class="line">        <span class="built_in">MPI_Send</span>(greeting, <span class="built_in">strlen</span>(greeting) + <span class="number">1</span>, MPI_CHAR, <span class="number">0</span>, <span class="number">0</span>, MPI_COMM_WORLD);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// MPI_Status 结构体，对其成员访问分别获取source和tag信息：</span></span><br><span class="line">    <span class="comment">// status.MPI_SOURCE</span></span><br><span class="line">    <span class="comment">// status.MPI_TAG</span></span><br><span class="line">    <span class="comment">// 通过MPI_Get_count(&amp;status, recv_type, &amp;count)获取到接受元素的数量（返回到count中）</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="built_in">MPI_Finalize</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="利用mpi实现梯形积分点对点通信"><a class="markdownIt-Anchor" href="#利用mpi实现梯形积分点对点通信"></a> 利用MPI实现梯形积分（点对点通信）</h2>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 2. 利用MPI实现梯形积分（点对点通信）</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    设计一个并行程序：</span></span><br><span class="line"><span class="comment">    1. 将问题划分为多个任务</span></span><br><span class="line"><span class="comment">    2. 在任务间识别出需要的通信信道</span></span><br><span class="line"><span class="comment">    3. 将任务聚合为复合任务</span></span><br><span class="line"><span class="comment">    4. 在核上分配任务</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">this_function</span><span class="params">(<span class="keyword">double</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    输入：只允许0号进程进行输入</span></span><br><span class="line"><span class="comment">    输出：可能乱序，需要自己进行编写</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">Trap</span><span class="params">(<span class="keyword">double</span> left, <span class="keyword">double</span> right, <span class="keyword">double</span> n, <span class="keyword">double</span> h)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">double</span> res = <span class="built_in">this_function</span>(left) / <span class="number">2</span> + <span class="built_in">this_function</span>(right) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        res += <span class="built_in">this_function</span>(left + h * i);</span><br><span class="line">    &#125;</span><br><span class="line">    res = res * h;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Trapezoids</span> <span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> my_rank, comm_sz, n;</span><br><span class="line">    <span class="built_in">MPI_Init</span>(<span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">int</span> left, right;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">MPI_Comm_size</span>(MPI_COMM_WORLD, &amp;comm_sz);</span><br><span class="line">    <span class="built_in">MPI_Comm_rank</span>(MPI_COMM_WORLD, &amp;my_rank);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 0号进程进行输入</span></span><br><span class="line">    <span class="keyword">if</span> (my_rank == <span class="number">0</span>) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Input a, b and n\n&quot;</span>;</span><br><span class="line">        cin &gt;&gt; left &gt;&gt; right &gt;&gt; n;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> dest = <span class="number">1</span>; dest &lt; comm_sz; dest++) &#123;</span><br><span class="line">            <span class="built_in">MPI_Send</span>(&amp;left, <span class="number">1</span>, MPI_INT, dest, <span class="number">0</span>, MPI_COMM_WORLD);</span><br><span class="line">            <span class="built_in">MPI_Send</span>(&amp;right, <span class="number">1</span>, MPI_INT, dest, <span class="number">0</span>, MPI_COMM_WORLD);</span><br><span class="line">            <span class="built_in">MPI_Send</span>(&amp;n, <span class="number">1</span>, MPI_INT, dest, <span class="number">0</span>, MPI_COMM_WORLD);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 其他进程读取输入</span></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">MPI_Recv</span>(&amp;left, <span class="number">1</span>, MPI_INT, <span class="number">0</span>, <span class="number">0</span>, MPI_COMM_WORLD, MPI_STATUS_IGNORE);</span><br><span class="line">        <span class="built_in">MPI_Recv</span>(&amp;right, <span class="number">1</span>, MPI_INT, <span class="number">0</span>, <span class="number">0</span>, MPI_COMM_WORLD, MPI_STATUS_IGNORE);</span><br><span class="line">        <span class="built_in">MPI_Recv</span>(&amp;n, <span class="number">1</span>, MPI_INT, <span class="number">0</span>, <span class="number">0</span>, MPI_COMM_WORLD, MPI_STATUS_IGNORE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算负责区域的左右区间、分段数量</span></span><br><span class="line">    <span class="keyword">int</span> h = (right - left) / n;</span><br><span class="line">    <span class="keyword">int</span> local_n = n / comm_sz;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> local_left = left + my_rank * h * local_n;</span><br><span class="line">    <span class="keyword">int</span> local_right = right + my_rank * h * local_n;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在负责区域进行串行计算</span></span><br><span class="line">    <span class="keyword">double</span> local_res = <span class="built_in">Trap</span>(local_left, local_right, local_n, h);</span><br><span class="line">    <span class="keyword">double</span> total_res = local_res;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回结果</span></span><br><span class="line">    <span class="keyword">if</span> (my_rank != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">MPI_Send</span>(&amp;local_res, <span class="number">1</span>, MPI_DOUBLE, <span class="number">0</span>, <span class="number">0</span>, MPI_COMM_WORLD);</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;I&#x27;m process &quot;</span> &lt;&lt; my_rank &lt;&lt; <span class="string">&quot;, I send the result&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; comm_sz; i++) &#123;</span><br><span class="line">            <span class="built_in">MPI_Recv</span>(&amp;local_res, <span class="number">1</span>, MPI_DOUBLE, i, <span class="number">0</span>, MPI_COMM_WORLD, MPI_STATUS_IGNORE);</span><br><span class="line">            total_res += local_res;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 0号进程输出结果</span></span><br><span class="line">    <span class="keyword">if</span> (my_rank == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;With n = %d trapezoids, our estimate\n&quot;</span>, n);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;of the integral from %f to %f = %.15e\n&quot;</span>, left, right, total_res);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">MPI_Finalize</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="集合通信"><a class="markdownIt-Anchor" href="#集合通信"></a> 集合通信</h2>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    集合通信：设计通信子中所有进程的通信函数</span></span><br><span class="line"><span class="comment">    点对点通信：MPI_Send类似</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    一些集合通信的注意事项：</span></span><br><span class="line"><span class="comment">    1. 通信子内所有进程必须调用相同的集合通信函数</span></span><br><span class="line"><span class="comment">    2. 参数必须相容，如dest_process都应该相同</span></span><br><span class="line"><span class="comment">    3. output_data_p只作用于dest_process</span></span><br><span class="line"><span class="comment">    4. 集合通信函数只通过通信子和调用顺序进行匹配！！！调用顺序很重要！P69表3-3</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 集合通信解决梯形积分</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">int MPI_Reduce(</span></span><br><span class="line"><span class="comment">    void*           input_data_p,</span></span><br><span class="line"><span class="comment">    void*           output_data_p,</span></span><br><span class="line"><span class="comment">    int             count,</span></span><br><span class="line"><span class="comment">    MPI_Datatype    datatype,</span></span><br><span class="line"><span class="comment">    MPI_Op          operator,</span></span><br><span class="line"><span class="comment">    int             dest_process,</span></span><br><span class="line"><span class="comment">    MPI_Comm        comm</span></span><br><span class="line"><span class="comment">)</span></span><br><span class="line"><span class="comment">    MPI_Allreduce 将计算的结果返回给所有进程，参数表同Reduce，但是没有dest</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    广播函数：MPI_Bcast(data_p(in/out), count, data_type, source_proc, comm)</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">// 使用广播函数获取输入并分发</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Get_input</span><span class="params">(<span class="keyword">int</span> my_rank, <span class="keyword">int</span> comm_sz, <span class="keyword">double</span>* a_p, <span class="keyword">double</span>* b_p, <span class="keyword">int</span>* n_p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (my_rank == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Input a, b and n.\n&quot;</span>);</span><br><span class="line">        <span class="built_in">scanf_s</span>(<span class="string">&quot;%lf%lf%d&quot;</span>, a_p, b_p, n_p);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">MPI_Bcast</span>(a_p, <span class="number">1</span>, MPI_DOUBLE, <span class="number">0</span>, MPI_COMM_WORLD);</span><br><span class="line">    <span class="built_in">MPI_Bcast</span>(b_p, <span class="number">1</span>, MPI_DOUBLE, <span class="number">0</span>, MPI_COMM_WORLD);</span><br><span class="line">    <span class="built_in">MPI_Bcast</span>(n_p, <span class="number">1</span>, MPI_INT, <span class="number">0</span>, MPI_COMM_WORLD);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    散射：MPI_Scatter()</span></span><br><span class="line"><span class="comment">    限制：块划分法+块大小相同</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">// 读取向量并划分分发</span></span><br><span class="line"><span class="comment">// 以下仅考虑可以整除的情况，习题3.13将讨论不可整除</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Read_vector</span><span class="params">(<span class="keyword">double</span> local_a[], <span class="keyword">int</span> local_n, <span class="keyword">int</span> n, </span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">char</span> vector_name[], <span class="keyword">int</span> my_rank, MPI_Comm comm)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">double</span>* a = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span> (my_rank == <span class="number">0</span>) &#123;</span><br><span class="line">        a = (<span class="keyword">double</span>*) <span class="built_in">malloc</span>(n * <span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">double</span>));</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="built_in">scanf_s</span>(<span class="string">&quot;%lf&quot;</span>, &amp;a[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">MPI_Scatter</span>(a, local_n, MPI_DOUBLE, local_a, local_n, MPI_DOUBLE, <span class="number">0</span>, comm);</span><br><span class="line">        <span class="built_in">free</span>(a);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">MPI_Scatter</span>(a, local_n, MPI_DOUBLE, local_a, local_n, MPI_DOUBLE, <span class="number">0</span>, comm);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    聚集：MPI_Gather()</span></span><br><span class="line"><span class="comment">    注：recv_count 指的是每个进程接收到的数据量</span></span><br><span class="line"><span class="comment">    限制：块划分法+块大小相同</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Print_vector</span><span class="params">(<span class="keyword">double</span> local_b[], <span class="keyword">int</span> local_n, <span class="keyword">int</span> n, <span class="keyword">char</span> title[], <span class="keyword">int</span> my_rank, MPI_Comm comm)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">double</span>* a = (<span class="keyword">double</span>*)<span class="built_in">malloc</span>(n * <span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">double</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (my_rank == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">MPI_Gather</span>(local_b, local_n, MPI_DOUBLE, a, local_n, MPI_DOUBLE, <span class="number">0</span>, MPI_COMM_WORLD);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, title);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) <span class="built_in">printf</span>(<span class="string">&quot;%lf &quot;</span>, a[i]);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">        <span class="built_in">free</span>(a);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">MPI_Gather</span>(local_b, local_n, MPI_DOUBLE, a, local_n, MPI_DOUBLE, <span class="number">0</span>, MPI_COMM_WORLD);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    全局聚集：MPI_Allgather()：相当于MPI_Gather + MPI_Bcast</span></span><br><span class="line"><span class="comment">    将每个进程Send_p的内容串联起来放到Recv_p中</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">// 矩阵与向量相乘</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Matirx_Mul_Vector</span><span class="params">(<span class="keyword">double</span> local_A[], <span class="keyword">double</span> local_x[], <span class="keyword">double</span> local_y[], </span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">int</span> local_m, <span class="keyword">int</span> n,<span class="keyword">int</span> local_n, <span class="keyword">int</span> my_rank, MPI_Comm comm)</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">double</span>* x;</span><br><span class="line"></span><br><span class="line">    x = (<span class="keyword">double</span>*)<span class="built_in">malloc</span>(n * <span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">double</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 因为此处，函数得到的是划分后的x，但是运算需要整个x向量，故需要Allgather进行向量补全</span></span><br><span class="line">    <span class="built_in">MPI_Allgather</span>(local_x, local_n, MPI_DOUBLE, x, local_n, MPI_DOUBLE, comm);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> local_i = <span class="number">0</span>; local_i &lt; local_m; local_i++) &#123;</span><br><span class="line">        local_y[local_i] = <span class="number">0.0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++)</span><br><span class="line">            local_y[local_i] += local_A[local_i * n + j] * x[j];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">free</span>(x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="信息整合"><a class="markdownIt-Anchor" href="#信息整合"></a> 信息整合</h2>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    MPI提供的三个整合多条消息数据的手段：</span></span><br><span class="line"><span class="comment">    1. count</span></span><br><span class="line"><span class="comment">    2. 派生数据类型</span></span><br><span class="line"><span class="comment">    3. pack/unpack</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 派生数据类型：如果发送数据的函数知道数据项的类型以及在内存中数据项集合的相对位置，</span></span><br><span class="line"><span class="comment">   就可以在数据项被发送出去之前在内存中将数据项聚集起来。</span></span><br><span class="line"><span class="comment">   组成：数据类型 + 偏移</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">   派生数据类型更像是将每一个指定位移的数据的偏移量记录下来，每次通信的时候传输这些数据</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">// 创建派生数据类型</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">int MPI_Type_create_struct(</span></span><br><span class="line"><span class="comment">    int count,                          // 数据类型中的元素个数，下面各个参数数组都有count个元素</span></span><br><span class="line"><span class="comment">    int array_of_blocklengths[],        // 允许单独数据项为数组或子数组，如第一个元素是一个含5个元素的数组，则aob[0] = 5</span></span><br><span class="line"><span class="comment">    MPI_Aint array_of_displacements[],  // 距离消息起始位置的偏移量,单位为字节</span></span><br><span class="line"><span class="comment">    MPI_Datatype array_of_types[],      // 数据类型</span></span><br><span class="line"><span class="comment">    MPI_Datatype* new_type_p    (out)</span></span><br><span class="line"><span class="comment">    )</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">// 使用前需要指定</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">int MPI_Type_commit(MPI_Datatype* new_type_p);</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用派生数据类型的Get_input</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">原：</span></span><br><span class="line"><span class="comment">void Get_input(int my_rank, int comm_sz, double* a_p, double* b_p, int* n_p) &#123;</span></span><br><span class="line"><span class="comment">    if (my_rank == 0) &#123;</span></span><br><span class="line"><span class="comment">        printf(&quot;Input a, b and n.\n&quot;);</span></span><br><span class="line"><span class="comment">        scanf_s(&quot;%lf%lf%d&quot;, a_p, b_p, n_p);</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    MPI_Bcast(a_p, 1, MPI_DOUBLE, 0, MPI_COMM_WORLD);</span></span><br><span class="line"><span class="comment">    MPI_Bcast(b_p, 1, MPI_DOUBLE, 0, MPI_COMM_WORLD);</span></span><br><span class="line"><span class="comment">    MPI_Bcast(n_p, 1, MPI_INT, 0, MPI_COMM_WORLD);</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    修改后</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Build_mpi_type</span><span class="params">(<span class="keyword">double</span>* a_p, <span class="keyword">double</span>* b_p, <span class="keyword">int</span>* n_p, MPI_Datatype* data_type)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> array_of_blocklengths[<span class="number">3</span>] = &#123; <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span> &#125;;</span><br><span class="line">    MPI_Datatype array_of_types[<span class="number">3</span>] = &#123; MPI_DOUBLE, MPI_DOUBLE, MPI_INT &#125;;</span><br><span class="line">    MPI_Aint a_addr, b_addr, n_addr;</span><br><span class="line">    MPI_Aint array_of_addr[<span class="number">3</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">MPI_Get_address</span>(a_p, &amp;a_addr);</span><br><span class="line">    <span class="built_in">MPI_Get_address</span>(b_p, &amp;b_addr);</span><br><span class="line">    <span class="built_in">MPI_Get_address</span>(n_p, &amp;n_addr);</span><br><span class="line"></span><br><span class="line">    array_of_addr[<span class="number">1</span>] = b_addr - a_addr;</span><br><span class="line">    array_of_addr[<span class="number">2</span>] = n_addr - b_addr;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">MPI_Type_create_struct</span>(<span class="number">3</span>, array_of_blocklengths, array_of_addr, array_of_types, data_type);</span><br><span class="line">    <span class="built_in">MPI_Type_commit</span>(data_type);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Get_input_new</span><span class="params">(<span class="keyword">int</span> my_rank, <span class="keyword">int</span> comm_sz, <span class="keyword">double</span>* a_p, <span class="keyword">double</span>* b_p, <span class="keyword">int</span>* n_p)</span> </span>&#123;</span><br><span class="line">    MPI_Datatype <span class="keyword">input_mpi_t</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Build_mpi_type</span>(a_p, b_p, n_p, &amp;<span class="keyword">input_mpi_t</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (my_rank == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Input a, b and n.\n&quot;</span>);</span><br><span class="line">        <span class="built_in">scanf_s</span>(<span class="string">&quot;%lf%lf%d&quot;</span>, a_p, b_p, n_p);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">MPI_Bcast</span>(a_p, <span class="number">1</span>, <span class="keyword">input_mpi_t</span>, <span class="number">0</span>, MPI_COMM_WORLD);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">MPI_Type_free</span>(&amp;<span class="keyword">input_mpi_t</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="并行排序算法分布式算法实现"><a class="markdownIt-Anchor" href="#并行排序算法分布式算法实现"></a> 并行排序算法——分布式算法实现</h2>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 冒泡排序变种——奇偶交换排序</span></span><br><span class="line"><span class="comment">// 找寻交换进程号</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ComputePartner</span><span class="params">(<span class="keyword">int</span> my_rank, <span class="keyword">int</span> comm_sz, <span class="keyword">int</span> phase, <span class="keyword">int</span>&amp; partner)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (phase % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (my_rank % <span class="number">2</span> == <span class="number">0</span>)</span><br><span class="line">            partner = my_rank + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> partner = my_rank - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (my_rank % <span class="number">2</span> == <span class="number">0</span>)</span><br><span class="line">            partner = my_rank - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> partner = my_rank + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (partner == <span class="number">-1</span> || partner == comm_sz)</span><br><span class="line">        <span class="comment">// 注：MPI_PROC_NULL作为源进程或目标进程进程号时，调用通信函数直接返回，不产生通信</span></span><br><span class="line">        partner = MPI_PROC_NULL;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注：MPI_Send有两种发送方式，如果数据量较大可能会造成阻塞发送，可能导致死锁。</span></span><br><span class="line"><span class="comment">// 问题：程序安全如何保证？使用MPI_Ssend（表示同步，发送如果没被接受便阻塞）</span></span><br><span class="line"><span class="comment">// 问题：怎么修改奇偶排序使其安全？重构通信。</span></span><br><span class="line"><span class="comment">// MPI_Sendrecv() 阻塞式发送接收，可以保证安全</span></span><br><span class="line"><span class="comment">// MPI_Sendrecv_replace() 发送和接受使用的是同一个缓冲区</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 奇偶冒泡</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Merge_low</span><span class="params">(<span class="keyword">int</span> my_keys[], <span class="keyword">int</span> recv_keys[], <span class="keyword">int</span> temp_keys[], <span class="keyword">int</span> local_n, <span class="keyword">bool</span> flag)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> m_i = <span class="number">0</span>, r_i = <span class="number">0</span>, t_i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (!flag) &#123;</span><br><span class="line">        m_i = local_n - <span class="number">1</span>;</span><br><span class="line">        r_i = local_n - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// flag为true时，交换代表前一个线程（取小），反之取大。</span></span><br><span class="line">    <span class="comment">// 每次前一线程取小，后一线程取大</span></span><br><span class="line">    <span class="keyword">while</span> (t_i &lt; local_n) &#123;</span><br><span class="line">        <span class="keyword">if</span> (flag) &#123;</span><br><span class="line">            <span class="keyword">if</span> (my_keys[m_i] &lt; recv_keys[r_i]) &#123;</span><br><span class="line">                temp_keys[t_i] = my_keys[m_i];</span><br><span class="line">                t_i++; m_i++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                temp_keys[t_i] = recv_keys[r_i];</span><br><span class="line">                t_i++; r_i++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (my_keys[m_i] &gt; recv_keys[r_i]) &#123;</span><br><span class="line">                temp_keys[t_i] = my_keys[m_i];</span><br><span class="line">                t_i++; m_i--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                temp_keys[t_i] = recv_keys[r_i];</span><br><span class="line">                t_i++; r_i--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (flag) <span class="keyword">for</span> (m_i = <span class="number">0</span>; m_i &lt; local_n; m_i++) my_keys[m_i] = temp_keys[m_i];</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">for</span> (m_i = local_n - <span class="number">1</span>; m_i &gt;= <span class="number">0</span>; m_i--) my_keys[local_n - m_i - <span class="number">1</span>] = temp_keys[m_i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">compare</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span>* e1, <span class="keyword">const</span> <span class="keyword">void</span>* e2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//将void*类型的指针e1和e2强制类型转换成int*型</span></span><br><span class="line">    <span class="keyword">return</span>  *((<span class="keyword">int</span>*)e1) - *((<span class="keyword">int</span>*)e2);</span><br><span class="line">    <span class="comment">//一定要强制类型转换，因为e1和e2都是void*指针，没有类型的指针</span></span><br><span class="line">    <span class="comment">//如果不想要升序排列，想要按降序排列，就可以return  *((int*)e2) - *((int *)e1);</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">My_Sort</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> my_rank, comm_sz, n;</span><br><span class="line">    <span class="keyword">int</span>* array = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="built_in">MPI_Init</span>(<span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">MPI_Comm_size</span>(MPI_COMM_WORLD, &amp;comm_sz);</span><br><span class="line">    <span class="built_in">MPI_Comm_rank</span>(MPI_COMM_WORLD, &amp;my_rank);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 进程0读入</span></span><br><span class="line">    <span class="keyword">if</span> (my_rank == <span class="number">0</span>) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Input size of array:&quot;</span>;</span><br><span class="line">        cin &gt;&gt; n;</span><br><span class="line"></span><br><span class="line">        array = (<span class="keyword">int</span>*)<span class="built_in">malloc</span>(<span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">int</span>) * n);</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            cin &gt;&gt; array[i];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 广播总个数</span></span><br><span class="line">    <span class="built_in">MPI_Bcast</span>(&amp;n, <span class="number">1</span>, MPI_INT, <span class="number">0</span>, MPI_COMM_WORLD);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// local_n代表每个进程分配的元素个数</span></span><br><span class="line">    <span class="keyword">int</span> local_n = n / comm_sz;</span><br><span class="line">    <span class="comment">// cout &lt;&lt; &quot;local_n&quot; &lt;&lt; local_n &lt;&lt; endl;</span></span><br><span class="line">    <span class="keyword">int</span>* local_array = (<span class="keyword">int</span>*)<span class="built_in">malloc</span>(<span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">int</span>) * local_n);</span><br><span class="line">    <span class="comment">// if (my_rank == 0) for (int i = 0; i &lt; local_n; i++) local_array[i] = array[i];</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 分配元素</span></span><br><span class="line">    <span class="built_in">MPI_Scatter</span>(array, local_n, MPI_INT, local_array, local_n, MPI_INT, <span class="number">0</span>, MPI_COMM_WORLD);</span><br><span class="line">    <span class="comment">//cout &lt;&lt; &quot;Process&quot; &lt;&lt; my_rank &lt;&lt; &quot; &#x27;s array is &quot; &lt;&lt; local_array[0] &lt;&lt; endl;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">101</span>; i++) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>* local_receive = (<span class="keyword">int</span>*)<span class="built_in">malloc</span>(<span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">int</span>) * local_n);</span><br><span class="line">        <span class="keyword">int</span>* local_temp = (<span class="keyword">int</span>*)<span class="built_in">malloc</span>(<span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">int</span>) * local_n);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> partner;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 计算本回合交换目标</span></span><br><span class="line">        <span class="built_in">ComputePartner</span>(my_rank, comm_sz, i, partner);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// cout &lt;&lt; &quot;epoch&quot; &lt;&lt; i &lt;&lt; &quot; &quot; &lt;&lt; &quot;Process&quot; &lt;&lt; my_rank &lt;&lt; &quot; &#x27;s partner is &quot; &lt;&lt; partner &lt;&lt; endl;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 本进程元素排序</span></span><br><span class="line">        <span class="built_in">qsort</span>(local_array, local_n, <span class="built_in"><span class="keyword">sizeof</span></span>(local_array[<span class="number">0</span>]), compare);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 互发元素元素</span></span><br><span class="line">        <span class="built_in">MPI_Sendrecv</span>(local_array, local_n, MPI_INT, partner, <span class="number">0</span>, </span><br><span class="line">            local_receive, local_n, MPI_INT, partner, <span class="number">0</span>, MPI_COMM_WORLD, MPI_STATUSES_IGNORE);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// cout &lt;&lt; &quot;epoch&quot; &lt;&lt; i &lt;&lt; &quot; &quot; &lt;&lt; &quot;Process&quot; &lt;&lt; my_rank &lt;&lt; &quot; &#x27;s recv is &quot; &lt;&lt; local_receive[0] &lt;&lt; &quot;and&quot; &lt;&lt; local_receive[1] &lt;&lt; endl;</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">bool</span> flag = (i % <span class="number">2</span> == <span class="number">0</span>) &amp;&amp; (my_rank % <span class="number">2</span> == <span class="number">0</span>) || (i % <span class="number">2</span> == <span class="number">1</span>) &amp;&amp; (my_rank % <span class="number">2</span> == <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (partner != MPI_PROC_NULL)</span><br><span class="line">            <span class="built_in">Merge_low</span>(local_array, local_receive, local_temp, local_n, flag);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// cout &lt;&lt; &quot;epoch&quot; &lt;&lt; i &lt;&lt; &quot; &quot; &lt;&lt; &quot;Process&quot; &lt;&lt; my_rank &lt;&lt; &quot; &#x27;s sorted array is &quot; &lt;&lt; local_array[0] &lt;&lt; &quot;and&quot; &lt;&lt; local_array[1] &lt;&lt; endl;</span></span><br><span class="line"></span><br><span class="line">        <span class="built_in">free</span>(local_receive);</span><br><span class="line">        <span class="built_in">free</span>(local_temp);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 收集最后结果</span></span><br><span class="line">    <span class="built_in">MPI_Gather</span>(local_array, local_n, MPI_INT, array, local_n, MPI_INT, <span class="number">0</span>, MPI_COMM_WORLD);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (my_rank == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) cout &lt;&lt; array[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    <span class="built_in">MPI_Finalize</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h1 id="openmp"><a class="markdownIt-Anchor" href="#openmp"></a> OpenMP</h1>
<h2 id="第一个openmp程序"><a class="markdownIt-Anchor" href="#第一个openmp程序"></a> 第一个OpenMP程序</h2>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> _OPENMP</span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">include</span><span class="meta-string">&lt;omp.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Hello_world</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span> </span>&#123;</span><br><span class="line">    <span class="comment">/* 得到线程数 */</span></span><br><span class="line">    <span class="keyword">int</span> thread_count = <span class="built_in">strtol</span>(argv[<span class="number">1</span>], <span class="literal">NULL</span>, <span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// #pragma 开头，代表预处理器指令，如果不支持pragma的编译器会忽略该指令</span></span><br><span class="line">    <span class="comment">// parallel代表结构化代码块，是一条C语句或一个入口和一个出口的复合C语句</span></span><br><span class="line">    <span class="comment">// parallel指令添加num_threads子句(子句是修改指令的文本)</span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">pragma</span> omp parallel num_threads(thread_count)</span></span><br><span class="line">    <span class="built_in">Hello_world</span>();</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        执行parallel指令后，thread_count - 1个线程被启动，</span></span><br><span class="line"><span class="comment">        原始线程成为主线程master,额外线程称为从线程slave</span></span><br><span class="line"><span class="comment">        master + slave称为线程组，线程组每个线程都执行parallel后的代码块</span></span><br><span class="line"><span class="comment">        该处存在一个隐式路障，当所有线程执行完代码块，从线程终止，主线程才继续执行</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Hello_world</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 得到自己的线程编号</span></span><br><span class="line">    <span class="keyword">int</span> my_rank = <span class="built_in">omp_get_thread_num</span>();</span><br><span class="line">    <span class="comment">// 得到线程组中的线程数</span></span><br><span class="line">    <span class="keyword">int</span> thread_count = <span class="built_in">omp_get_num_threads</span>();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Hello world from thread %d of %d\n&quot;</span>, my_rank, thread_count);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="openmp实现梯形积分法"><a class="markdownIt-Anchor" href="#openmp实现梯形积分法"></a> OpenMP实现梯形积分法</h2>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> _OPENMP</span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">include</span><span class="meta-string">&lt;omp.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Trap</span><span class="params">(<span class="keyword">double</span> a, <span class="keyword">double</span> b, <span class="keyword">int</span> n, </span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">double</span>* global_result_p)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">f</span><span class="params">(<span class="keyword">double</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">double</span> y = x;</span><br><span class="line">    <span class="keyword">return</span> y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">double</span> global_result = <span class="number">0.0</span>;</span><br><span class="line">    <span class="keyword">double</span> a, b;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">int</span> thread_count = <span class="built_in">strtol</span>(argv[<span class="number">1</span>], <span class="literal">NULL</span>, <span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Input a, b and n\n&quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%lf %lf %d&quot;</span>, &amp;a, &amp;b, &amp;n);</span><br><span class="line"></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">pragma</span> omp parallel num_threads(thread_count)</span></span><br><span class="line">    <span class="built_in">Trap</span>(a, b, n, &amp;global_result);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Estimate of the integral = %.14e\n&quot;</span>, global_result);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Trap</span><span class="params">(<span class="keyword">double</span> a, <span class="keyword">double</span> b, <span class="keyword">int</span> n, </span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">double</span>* global_result_p)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 注意，计算并没有检查n是否能被thread_num整除，如不能需要另加修改</span></span><br><span class="line">    <span class="keyword">double</span> h, x, my_result;</span><br><span class="line">    <span class="keyword">double</span> local_a, local_b;</span><br><span class="line">    <span class="keyword">int</span> i, local_n;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> my_rank = <span class="built_in">omp_get_thread_num</span>();</span><br><span class="line">    <span class="keyword">int</span> thread_count = <span class="built_in">omp_get_num_threads</span>();</span><br><span class="line"></span><br><span class="line">    h = (b - a) / n;</span><br><span class="line">    local_n = n / thread_count;</span><br><span class="line">    local_a = a + my_rank * local_n * h;</span><br><span class="line">    local_b = local_a + h * local_n;</span><br><span class="line"></span><br><span class="line">    my_result = (<span class="built_in">f</span>(local_a) + <span class="built_in">f</span>(local_b)) / <span class="number">2.0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= local_n - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        x = local_a + i * h;</span><br><span class="line">        my_result += <span class="built_in">f</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line">    my_result *= h;</span><br><span class="line"></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">pragma</span> omp critical</span></span><br><span class="line">    *global_result_p += my_result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注意：在parallel指令前已经被声明的变量拥有在线程组中共享作用域，</span></span><br><span class="line"><span class="comment">//      而在块中声明的变量（如函数中的局部变量）有私有作用域</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 加入规约子句的Trap版本</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 我们更加习惯于不使用指针来传递临界变量：</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">Local_trap</span><span class="params">(<span class="keyword">double</span> a, <span class="keyword">double</span> b, <span class="keyword">int</span> n)</span></span>;</span><br><span class="line"><span class="comment">// 而在调用的时候，会改变parallel块如下：</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">double global_result = 0.0;</span></span><br><span class="line"><span class="comment"># pragma omp parallel num_threads(thread.count)</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">    double my_result = 0.0;</span></span><br><span class="line"><span class="comment">    my_result += Local_trap(double a, double b, int n);</span></span><br><span class="line"><span class="comment">#   pragma omp critical</span></span><br><span class="line"><span class="comment">    global_result += my_result;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// OpenMP提供归约(将相同的归约操作符重复应用到操作数序列)操作符，</span></span><br><span class="line"><span class="comment">// 所有操作的中间结果储存在归约变量中</span></span><br><span class="line"><span class="comment">// 于是我们修改parallel块如下：</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">double global_result = 0.0;</span></span><br><span class="line"><span class="comment"># pragma omp parallel num_threads(thread.count) \</span></span><br><span class="line"><span class="comment">    reduction(+: global_result)</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">    global_result += Local_trap(double a, double b, int n);</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">// reduction子句的语法：reduction(&lt;operator&gt;: &lt;variable list&gt;)</span></span><br><span class="line"><span class="comment">// operator可以为：+ * - &amp; | ^ &amp;&amp; ||</span></span><br><span class="line"><span class="comment">// 注意：</span></span><br><span class="line"><span class="comment">// 1. - 不满足交换律和结合律，OpenMP不能保证正确运行</span></span><br><span class="line"><span class="comment">// 2. 归约变量如果为double or float，浮点数运算不满足结合律，可能会有不同</span></span><br><span class="line"><span class="comment">// 3. reduction中包含的变量是共享的，但是每个线程都会创建自己的私有变量（初始化为0或1（*）等情况）</span></span><br><span class="line"><span class="comment">//    当parallel块结束时会将私有变量的值整合到共享变量中</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// parallel for指令</span></span><br><span class="line"><span class="comment">// OpenMP提供parallel for 指令，能够并行化串行积分</span></span><br><span class="line"><span class="comment">// 串行积分改进：</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Serial_Trap</span><span class="params">(<span class="keyword">double</span> h, <span class="keyword">double</span> a, <span class="keyword">double</span> b, <span class="keyword">double</span> approx, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    h = (b - a) / n;</span><br><span class="line">    approx = (<span class="built_in">f</span>(a) + <span class="built_in">f</span>(b)) / <span class="number">2.0</span>;</span><br><span class="line"><span class="meta">#   <span class="meta-keyword">pragma</span> omp parallel for num_threads(thread_count) \</span></span><br><span class="line"><span class="meta">        reduction(+: approx)</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n - <span class="number">1</span>; i++)</span><br><span class="line">        approx += <span class="built_in">f</span>(a + i * h);</span><br><span class="line">    approx = h * approx;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// parallel for与parallel指令非常不同，</span></span><br><span class="line"><span class="comment">// 在parallel指令之前的块，其工作必须由线程本身在线程之间划分</span></span><br><span class="line"><span class="comment">// parallel for指令缺省划分方式由系统决定</span></span><br><span class="line"><span class="comment">// approx必须作为归约变量，否则approx += 将变成无保护临界区</span></span><br><span class="line"><span class="comment">// 注意：parallel for中循环变量缺省作用域是私有的</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 对于parallel for的警告</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    1. 只会并行化for循环，不会并行化while, do-while</span></span><br><span class="line"><span class="comment">    2. OpenMP只能并行化确定迭代次数的for循环</span></span><br><span class="line"><span class="comment">        - 由for语句本身确定</span></span><br><span class="line"><span class="comment">        - 在循环执行前确定</span></span><br><span class="line"><span class="comment">    3. OpenMP只能并行化典型结构for循环</span></span><br><span class="line"><span class="comment">        - index必须是整形或指针类型</span></span><br><span class="line"><span class="comment">        - start, end, incr必须有一个兼容类型</span></span><br><span class="line"><span class="comment">        - start, end, incr在循环执行期间不改变</span></span><br><span class="line"><span class="comment">        - index只能由for语句中增量表达式修改</span></span><br><span class="line"><span class="comment">    4. 唯一例外：循环体中可以有一个exit调用</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 数据依赖性</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    OpenMP编译器不检查被parallel for指令并行化的循环所包含的迭代间依赖关系</span></span><br><span class="line"><span class="comment">    当使用parallel for指令时要寻找循环依赖</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<h2 id="parallel-for的数据-循环依赖"><a class="markdownIt-Anchor" href="#parallel-for的数据-循环依赖"></a> parallel for的数据、循环依赖</h2>
<p>以估算<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>π</mi></mrow><annotation encoding="application/x-tex">\pi</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">π</span></span></span></span>为例：</p>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>π</mi><mo>=</mo><mn>4</mn><mo stretchy="false">[</mo><mn>1</mn><mo>−</mo><mstyle displaystyle="true" scriptlevel="0"><mfrac><mn>1</mn><mn>3</mn></mfrac></mstyle><mo>+</mo><mstyle displaystyle="true" scriptlevel="0"><mfrac><mn>1</mn><mn>5</mn></mfrac></mstyle><mo>−</mo><mstyle displaystyle="true" scriptlevel="0"><mfrac><mn>1</mn><mn>7</mn></mfrac></mstyle><mo>+</mo><mo>…</mo><mtext> </mtext><mo stretchy="false">]</mo><mo>=</mo><mn>4</mn><msubsup><mo>∑</mo><mrow><mi>k</mi><mo>=</mo><mn>0</mn></mrow><mi mathvariant="normal">∞</mi></msubsup><mstyle displaystyle="true" scriptlevel="0"><mfrac><mrow><mo stretchy="false">(</mo><mo>−</mo><mn>1</mn><msup><mo stretchy="false">)</mo><mi>k</mi></msup></mrow><mrow><mn>2</mn><mi>k</mi><mo>+</mo><mn>1</mn></mrow></mfrac></mstyle></mrow><annotation encoding="application/x-tex">\pi=4[1-\dfrac{1}{3}+\dfrac{1}{5}-\dfrac{1}{7}+\dots]=4\sum^{\infty}_{k=0}\dfrac{(-1)^k}{2k+1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">π</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">4</span><span class="mopen">[</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:2.00744em;vertical-align:-0.686em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.32144em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">3</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:2.00744em;vertical-align:-0.686em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.32144em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">5</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:2.00744em;vertical-align:-0.686em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.32144em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">7</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="minner">…</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.295438em;vertical-align:-0.7693300000000001em;"></span><span class="mord">4</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop"><span class="mop op-symbol small-op" style="position:relative;top:-0.0000050000000000050004em;">∑</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.804292em;"><span style="top:-2.40029em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span><span class="mrel mtight">=</span><span class="mord mtight">0</span></span></span></span><span style="top:-3.2029em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">∞</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.29971000000000003em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.526108em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">2</span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord">1</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mopen">(</span><span class="mord">−</span><span class="mord">1</span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.849108em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.7693300000000001em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 数据依赖性</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    OpenMP编译器不检查被parallel for指令并行化的循环所包含的迭代间依赖关系</span></span><br><span class="line"><span class="comment">    当使用parallel for指令时要寻找循环依赖</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> _OPENMP</span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">include</span><span class="meta-string">&lt;omp.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">serial_pai</span><span class="params">(<span class="keyword">int</span> thread_count, <span class="keyword">int</span> n)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">parallel_pai_1_0</span><span class="params">(<span class="keyword">int</span> thread_count, <span class="keyword">int</span> n)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">parallel_pai_1_1</span><span class="params">(<span class="keyword">int</span> thread_count, <span class="keyword">int</span> n)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">parallel_pai</span><span class="params">(<span class="keyword">int</span> thread_count, <span class="keyword">int</span> n)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> thread_count = <span class="built_in">strtol</span>(argv[<span class="number">1</span>], <span class="literal">NULL</span>, <span class="number">10</span>);</span><br><span class="line">    <span class="comment">// serial_pai(thread_count, 1000);</span></span><br><span class="line">    <span class="comment">// parallel_pai_1_0(thread_count, 1000);</span></span><br><span class="line">    <span class="comment">// parallel_pai_1_1(thread_count, 1000);</span></span><br><span class="line">    <span class="built_in">parallel_pai</span>(thread_count, <span class="number">1000</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 串行代码</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">serial_pai</span><span class="params">(<span class="keyword">int</span> thread_count, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">double</span> factor = <span class="number">1.0</span>;</span><br><span class="line">    <span class="keyword">double</span> sum = <span class="number">0.0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; n; k++) &#123;</span><br><span class="line">        sum += factor / (<span class="number">2</span> * k + <span class="number">1</span>);</span><br><span class="line">        factor = -factor;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">double</span> pi_approx = <span class="number">4.0</span> * sum;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;pai: %lf\n&quot;</span>, pi_approx);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 并行1.0</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">parallel_pai_1_0</span><span class="params">(<span class="keyword">int</span> thread_count,  <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">double</span> factor = <span class="number">1.0</span>;</span><br><span class="line">    <span class="keyword">double</span> sum = <span class="number">0.0</span>;</span><br><span class="line"><span class="meta">#   <span class="meta-keyword">pragma</span> omp parallel for num_threads(thread_count)\</span></span><br><span class="line"><span class="meta">        reduction(+: sum)</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; n; k++) &#123;</span><br><span class="line">        sum += factor / (<span class="number">2</span> * k + <span class="number">1</span>);</span><br><span class="line">        <span class="comment">// !!!该处存在数据依赖性，若k次迭代在一个线程，k+1次在另一个线程，</span></span><br><span class="line">        <span class="comment">// 会导致factor值错误</span></span><br><span class="line">        factor = -factor;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">double</span> pi_approx = <span class="number">4.0</span> * sum;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;pai: %lf\n&quot;</span>, pi_approx);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 并行1.1</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">parallel_pai_1_1</span><span class="params">(<span class="keyword">int</span> thread_count, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">double</span> factor = <span class="number">1.0</span>;</span><br><span class="line">    <span class="keyword">double</span> sum = <span class="number">0.0</span>;</span><br><span class="line"><span class="meta">#   <span class="meta-keyword">pragma</span> omp parallel for num_threads(thread_count)\</span></span><br><span class="line"><span class="meta">        reduction(+: sum)</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; n; k++) &#123;</span><br><span class="line">        factor = (k % <span class="number">2</span> == <span class="number">0</span>) ? <span class="number">1.0</span> : <span class="number">-1.0</span>;</span><br><span class="line">        sum += factor / (<span class="number">2</span> * k + <span class="number">1</span>);</span><br><span class="line">        <span class="comment">// factor = -factor;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">double</span> pi_approx = <span class="number">4.0</span> * sum;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;pai: %lf\n&quot;</span>, pi_approx);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 问题：</span></span><br><span class="line"><span class="comment">// 注意，缺省情况下任何在循环前声明的变量在线程间都是共享的</span></span><br><span class="line"><span class="comment">// 因此factor是共享的，可能存在线程间修改导致错误，因此要保证factor私有作用域</span></span><br><span class="line"><span class="comment">// 最终版本</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">parallel_pai</span><span class="params">(<span class="keyword">int</span> thread_count, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">double</span> factor = <span class="number">1.0</span>;</span><br><span class="line">    <span class="keyword">double</span> sum = <span class="number">0.0</span>;</span><br><span class="line"><span class="meta">#   <span class="meta-keyword">pragma</span> omp parallel for num_threads(thread_count)\</span></span><br><span class="line"><span class="meta">        reduction(+: sum) private(factor)</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; n; k++) &#123;</span><br><span class="line">        factor = (k % <span class="number">2</span> == <span class="number">0</span>) ? <span class="number">1.0</span> : <span class="number">-1.0</span>;</span><br><span class="line">        sum += factor / (<span class="number">2</span> * k + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">double</span> pi_approx = <span class="number">4.0</span> * sum;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;pai: %lf\n&quot;</span>, pi_approx);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Openmp提供一个子句default(none),要求用户明确每个变量的作用域</span></span><br><span class="line"><span class="comment">// 如对pai的计算可以修改为：</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">#   pragma omp parallel for num_threads(thread_count)\</span></span><br><span class="line"><span class="comment">        default(none) reduction(+: sum) private(k, factor)\</span></span><br><span class="line"><span class="comment">        shared(n)</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<h2 id="openmp实现奇偶排序"><a class="markdownIt-Anchor" href="#openmp实现奇偶排序"></a> OpenMP实现奇偶排序</h2>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="comment">// #ifdef _OPENMP</span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">include</span><span class="meta-string">&lt;omp.h&gt;</span></span></span><br><span class="line"><span class="comment">// #endif</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">serial_odd_even_order</span><span class="params">(<span class="keyword">int</span> thread_count, <span class="keyword">int</span> a[], <span class="keyword">int</span> n)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">parallel_odd_even_order</span><span class="params">(<span class="keyword">int</span> thread_count, <span class="keyword">int</span> a[], <span class="keyword">int</span> n)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">parallel_odd_even_order_2</span><span class="params">(<span class="keyword">int</span> thread_count, <span class="keyword">int</span> a[], <span class="keyword">int</span> n)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> &amp;a, <span class="keyword">int</span> &amp;b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t = a;</span><br><span class="line">    a = b;</span><br><span class="line">    b = t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a[<span class="number">10</span>] = &#123;<span class="number">2</span>, <span class="number">1</span>, <span class="number">16</span>, <span class="number">8</span>, <span class="number">6</span>, <span class="number">0</span>, <span class="number">7</span>, <span class="number">11</span>, <span class="number">12</span>, <span class="number">15</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> thread_num = <span class="built_in">strtol</span>(argv[<span class="number">1</span>], <span class="literal">NULL</span>, <span class="number">10</span>);</span><br><span class="line">    <span class="built_in">parallel_odd_even_order_2</span>(thread_num, a, <span class="number">10</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">serial_odd_even_order</span><span class="params">(<span class="keyword">int</span> thread_count, <span class="keyword">int</span> a[], <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> phase;</span><br><span class="line">    <span class="keyword">for</span> (phase = <span class="number">0</span>; phase &lt; n; phase++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (phase % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i += <span class="number">2</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (a[i - <span class="number">1</span>] &gt; a[i]) </span><br><span class="line">                    <span class="built_in">swap</span>(a[i - <span class="number">1</span>], a[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n - <span class="number">1</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (a[i] &gt; a[i + <span class="number">1</span>]) &#123;</span><br><span class="line">                    <span class="built_in">swap</span>(a[i], a[i + <span class="number">1</span>]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// parallel 1.0</span></span><br><span class="line"><span class="comment">// 我们发现，最外层的for循环具有循环依赖，并不适合并行化</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">parallel_odd_even_order</span><span class="params">(<span class="keyword">int</span> thread_count, <span class="keyword">int</span> a[], <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> phase;</span><br><span class="line">    <span class="keyword">for</span> (phase = <span class="number">0</span>; phase &lt; n; phase++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (phase % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="meta">#           <span class="meta-keyword">pragma</span> omp parallel for num_threads(thread_count) \</span></span><br><span class="line"><span class="meta">                default(none) shared(a, n)</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i += <span class="number">2</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (a[i - <span class="number">1</span>] &gt; a[i]) </span><br><span class="line">                    <span class="built_in">swap</span>(a[i - <span class="number">1</span>], a[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="meta">#           <span class="meta-keyword">pragma</span> omp parallel for num_threads(thread_count) \</span></span><br><span class="line"><span class="meta">                default(none) shared(a, n)</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n - <span class="number">1</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (a[i] &gt; a[i + <span class="number">1</span>]) &#123;</span><br><span class="line">                    <span class="built_in">swap</span>(a[i], a[i + <span class="number">1</span>]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// parallel 2.0</span></span><br><span class="line"><span class="comment">// parallel每进行一次外部循环都会创建和合并线程，产生开销</span></span><br><span class="line"><span class="comment">// 每次执行内部循环都会使用相同数量的线程，因此我们希望只创建一次线程，并在每次内部循环执行中重用</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">parallel_odd_even_order_2</span><span class="params">(<span class="keyword">int</span> thread_count, <span class="keyword">int</span> a[], <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> phase;</span><br><span class="line"><span class="meta">#   <span class="meta-keyword">pragma</span> omp parallel num_threads(thread_count) \</span></span><br><span class="line"><span class="meta">        default(none) shared(a, n) private(phase)</span></span><br><span class="line">    <span class="keyword">for</span> (phase = <span class="number">0</span>; phase &lt; n; phase++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (phase % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="meta">#           <span class="meta-keyword">pragma</span> omp for</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i += <span class="number">2</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (a[i - <span class="number">1</span>] &gt; a[i]) </span><br><span class="line">                    <span class="built_in">swap</span>(a[i - <span class="number">1</span>], a[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="meta">#           <span class="meta-keyword">pragma</span> omp for</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n - <span class="number">1</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (a[i] &gt; a[i + <span class="number">1</span>]) &#123;</span><br><span class="line">                    <span class="built_in">swap</span>(a[i], a[i + <span class="number">1</span>]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="线程调度子句schedule"><a class="markdownIt-Anchor" href="#线程调度子句schedule"></a> 线程调度子句schedule</h2>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> _OPENMP</span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">include</span><span class="meta-string">&lt;omp.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;math.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">function</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> j, start = i * (i + <span class="number">1</span>) / <span class="number">2</span>, finish = start + i;</span><br><span class="line">    <span class="keyword">double</span> return_val = <span class="number">0.0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (j = start; j &lt;= finish; j++) &#123;</span><br><span class="line">        return_val += <span class="built_in">sin</span>(j);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> return_val;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">    <span class="comment">// parallel for只是粗略的使用块分割，如果调用函数与需要时间成正比(function())</span></span><br><span class="line">    <span class="comment">// 这样的分配方式显然不佳。于是我们使用schedule子句实现好的迭代分配</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 下面是对于几种schedule的尝试</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 无调度</span></span><br><span class="line">    <span class="keyword">int</span> thread_count = <span class="built_in">strtol</span>(argv[<span class="number">1</span>], <span class="literal">NULL</span>, <span class="number">10</span>);</span><br><span class="line">    <span class="keyword">double</span> result_sum = <span class="number">0.0</span>;</span><br><span class="line">    <span class="keyword">int</span> n = <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">double</span> start_time = (<span class="keyword">double</span>) <span class="built_in">clock</span>();</span><br><span class="line"><span class="meta">#   <span class="meta-keyword">pragma</span> opt parallel for num_threads(thread_count) \</span></span><br><span class="line"><span class="meta">        reduction(+: result_sum) shared(n)</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        result_sum += <span class="built_in">function</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">double</span> end_time = (<span class="keyword">double</span>) <span class="built_in">clock</span>();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;No schedule, time is %.4lf, result is %.4lf\n&quot;</span>, end_time - start_time, result_sum);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// dynamic调度</span></span><br><span class="line">    result_sum = <span class="number">0.0</span>;</span><br><span class="line">    start_time = (<span class="keyword">double</span>) <span class="built_in">clock</span>();</span><br><span class="line">    <span class="meta">#   <span class="meta-keyword">pragma</span> opt parallel for num_threads(thread_count) \</span></span><br><span class="line"><span class="meta">        reduction(+: result_sum) shared(n) schedule(dynamic)</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        result_sum += <span class="built_in">function</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">     end_time = (<span class="keyword">double</span>) <span class="built_in">clock</span>();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Dynamic schedule, time is %.4lf, result is %.4lf\n&quot;</span>, end_time - start_time, result_sum);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// guided调度</span></span><br><span class="line">    result_sum = <span class="number">0.0</span>;</span><br><span class="line">    start_time = (<span class="keyword">double</span>) <span class="built_in">clock</span>();</span><br><span class="line">    <span class="meta">#   <span class="meta-keyword">pragma</span> opt parallel for num_threads(thread_count) \</span></span><br><span class="line"><span class="meta">        reduction(+: result_sum) shared(n) schedule(guided)</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        result_sum += <span class="built_in">function</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">     end_time = (<span class="keyword">double</span>) <span class="built_in">clock</span>();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Guided schedule, time is %.4lf, result is %.4lf\n&quot;</span>, end_time - start_time, result_sum);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// runtime调度</span></span><br><span class="line">    result_sum = <span class="number">0.0</span>;</span><br><span class="line">    start_time = (<span class="keyword">double</span>) <span class="built_in">clock</span>();</span><br><span class="line">    <span class="meta">#   <span class="meta-keyword">pragma</span> opt parallel for num_threads(thread_count) \</span></span><br><span class="line"><span class="meta">        reduction(+: result_sum) shared(n) schedule(runtime)</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        result_sum += <span class="built_in">function</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">     end_time = (<span class="keyword">double</span>) <span class="built_in">clock</span>();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Runtime schedule, time is %.4lf, result is %.4lf\n&quot;</span>, end_time - start_time, result_sum);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 自动调度</span></span><br><span class="line">    result_sum = <span class="number">0.0</span>;</span><br><span class="line">    start_time = (<span class="keyword">double</span>) <span class="built_in">clock</span>();</span><br><span class="line">    <span class="meta">#   <span class="meta-keyword">pragma</span> opt parallel for num_threads(thread_count) \</span></span><br><span class="line"><span class="meta">        reduction(+: result_sum) shared(n) schedule(auto)</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        result_sum += <span class="built_in">function</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">     end_time = (<span class="keyword">double</span>) <span class="built_in">clock</span>();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Auto schedule, time is %.4lf, result is %.4lf\n&quot;</span>, end_time - start_time, result_sum);</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// eg. 三个线程，12个任务</span></span><br><span class="line"><span class="comment">// 调度方式：</span></span><br><span class="line"><span class="comment">// 1. static: 以轮转方式分配chunksize个线程给每个线程（chunksize 默认近似为total_iterations / thread_count)</span></span><br><span class="line"><span class="comment">// chunksize = 2</span></span><br><span class="line"><span class="comment">// Thread0: 0 1 6 7</span></span><br><span class="line"><span class="comment">// Thread1: 2 3 8 9</span></span><br><span class="line"><span class="comment">// Thread2: 4 5 10 11</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. dynamic: 迭代被分为chunksize个连续块，每个线程执行一块，执行完再向系统申请(chunksize默认为1)</span></span><br><span class="line"><span class="comment">// 3. guided: 类似于dynamic, 每个线程执行完一块后，向系统请求另一块，但是新块会变小</span></span><br><span class="line"><span class="comment">// guided如下图</span></span><br><span class="line"><span class="comment">// 4. runtime: 需要自己配置环境变量指定</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 调度选择</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    系统开销: guided &gt; dynamic &gt; static</span></span><br><span class="line"><span class="comment">    1. 如果每次迭代计算量几乎相同，默认调度方式性能最好</span></span><br><span class="line"><span class="comment">    2. 若计算量线性递增或递减，采用比较小的chunksize的static比较好</span></span><br><span class="line"><span class="comment">    3. 如果每次迭代事先不确定，需要进行调参，可以通过配置环境变量来比较不同调度策略下性能</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p><img src="/image/openmp/1.png" alt="1" /></p>
<h2 id="小结"><a class="markdownIt-Anchor" href="#小结"></a> 小结</h2>
<p><img src="/image/openmp/2.png" alt="1" /></p>
<p><img src="/image/openmp/3.png" alt="1" /></p>
<p><img src="/image/openmp/4.png" alt="1" /></p>
<p><img src="/image/openmp/5.png" alt="1" /></p>
<p><img src="/image/openmp/6.png" alt="1" /></p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="http://aflyingsheep.github.io">Johnson Shuangjian</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://aflyingsheep.github.io/2022/08/05/mpi%20and%20openmp/openmp_MPI/">http://aflyingsheep.github.io/2022/08/05/mpi%20and%20openmp/openmp_MPI/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://aflyingsheep.github.io" target="_blank">AFlyingSheep's Blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/HPC/">HPC</a></div><div class="post_share"><div class="social-share" data-image="/image/covers/hpc.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://unpkg.com/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://unpkg.com/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2022/10/31/linux/tasklet/"><img class="prev-cover" src="/image/tasklet/1.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">软中断、tasklet和工作队列详解</div></div></a></div><div class="next-post pull-right"><a href="/2022/06/30/algorithm/median_problem(for_top_stack)/"><img class="next-cover" src="/image/covers/duiding.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">中位数问题（对顶堆的应用）</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2022/12/31/science_research/Codelet/" title="Codelet调度模型与Swdarts"><img class="cover" src="/image/codelet/1.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-12-31</div><div class="title">Codelet调度模型与Swdarts</div></div></a></div><div><a href="/2022/10/31/linux/aotomic_and_memory_order/" title="C++11:原子操作与memory_order"><img class="cover" src="/image/aotomic/cover.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-10-31</div><div class="title">C++11:原子操作与memory_order</div></div></a></div><div><a href="/2022/10/31/linux/CAS/" title="Compare And Swap(CAS)原理分析"><img class="cover" src="/image/CAS/1.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-10-31</div><div class="title">Compare And Swap(CAS)原理分析</div></div></a></div></div></div><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div class="vcomment" id="vcomment"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/userhead.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Johnson Shuangjian</div><div class="author-info__description">小阳的博客，记录学习、娱乐与日常！</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">40</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">14</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">11</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/aflyingsheep"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="mailto:xxxxxx@gmail.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a><a class="social-icon" href="https://github.com/AFlyingSheep" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:Johnsonshuangjian@gmail.com" target="_blank" title="Outlook"><i class="fas fa-envelope-open-text"></i></a><a class="social-icon" href="tencent://message?uin=398287312" target="_blank" title="QQ"><i class="fab fa-qq"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#mpi"><span class="toc-number">1.</span> <span class="toc-text"> MPI</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%B9%B6%E8%A1%8C%E7%A8%8B%E5%BA%8F"><span class="toc-number">1.1.</span> <span class="toc-text"> 第一个并行程序</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%A9%E7%94%A8mpi%E5%AE%9E%E7%8E%B0%E6%A2%AF%E5%BD%A2%E7%A7%AF%E5%88%86%E7%82%B9%E5%AF%B9%E7%82%B9%E9%80%9A%E4%BF%A1"><span class="toc-number">1.2.</span> <span class="toc-text"> 利用MPI实现梯形积分（点对点通信）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9B%86%E5%90%88%E9%80%9A%E4%BF%A1"><span class="toc-number">1.3.</span> <span class="toc-text"> 集合通信</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BF%A1%E6%81%AF%E6%95%B4%E5%90%88"><span class="toc-number">1.4.</span> <span class="toc-text"> 信息整合</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B9%B6%E8%A1%8C%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E5%88%86%E5%B8%83%E5%BC%8F%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0"><span class="toc-number">1.5.</span> <span class="toc-text"> 并行排序算法——分布式算法实现</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#openmp"><span class="toc-number">2.</span> <span class="toc-text"> OpenMP</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E4%B8%80%E4%B8%AAopenmp%E7%A8%8B%E5%BA%8F"><span class="toc-number">2.1.</span> <span class="toc-text"> 第一个OpenMP程序</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#openmp%E5%AE%9E%E7%8E%B0%E6%A2%AF%E5%BD%A2%E7%A7%AF%E5%88%86%E6%B3%95"><span class="toc-number">2.2.</span> <span class="toc-text"> OpenMP实现梯形积分法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#parallel-for%E7%9A%84%E6%95%B0%E6%8D%AE-%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96"><span class="toc-number">2.3.</span> <span class="toc-text"> parallel for的数据、循环依赖</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#openmp%E5%AE%9E%E7%8E%B0%E5%A5%87%E5%81%B6%E6%8E%92%E5%BA%8F"><span class="toc-number">2.4.</span> <span class="toc-text"> OpenMP实现奇偶排序</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E8%B0%83%E5%BA%A6%E5%AD%90%E5%8F%A5schedule"><span class="toc-number">2.5.</span> <span class="toc-text"> 线程调度子句schedule</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B0%8F%E7%BB%93"><span class="toc-number">2.6.</span> <span class="toc-text"> 小结</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2023/02/10/math/sor/" title="线性方程组的迭代式求解方法"><img src="/image/j_gs_sor/top.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="线性方程组的迭代式求解方法"/></a><div class="content"><a class="title" href="/2023/02/10/math/sor/" title="线性方程组的迭代式求解方法">线性方程组的迭代式求解方法</a><time datetime="2023-02-10T12:22:06.000Z" title="发表于 2023-02-10 20:22:06">2023-02-10</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/01/30/linux/cmake/" title="cmake学习笔记"><img src="/image/cmake/cover.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="cmake学习笔记"/></a><div class="content"><a class="title" href="/2023/01/30/linux/cmake/" title="cmake学习笔记">cmake学习笔记</a><time datetime="2023-01-30T13:27:06.000Z" title="发表于 2023-01-30 21:27:06">2023-01-30</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/01/08/cpp/template_and_static/" title="C++：模板类和静态成员变量"><img src="/image/cpp/cover_2.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="C++：模板类和静态成员变量"/></a><div class="content"><a class="title" href="/2023/01/08/cpp/template_and_static/" title="C++：模板类和静态成员变量">C++：模板类和静态成员变量</a><time datetime="2023-01-08T08:57:06.000Z" title="发表于 2023-01-08 16:57:06">2023-01-08</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/01/05/cpp/%E6%9D%82%E7%83%A9/" title="C++杂谈笔记"><img src="/image/cpp/cover.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="C++杂谈笔记"/></a><div class="content"><a class="title" href="/2023/01/05/cpp/%E6%9D%82%E7%83%A9/" title="C++杂谈笔记">C++杂谈笔记</a><time datetime="2023-01-05T13:27:06.000Z" title="发表于 2023-01-05 21:27:06">2023-01-05</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/12/31/science_research/Codelet/" title="Codelet调度模型与Swdarts"><img src="/image/codelet/1.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Codelet调度模型与Swdarts"/></a><div class="content"><a class="title" href="/2022/12/31/science_research/Codelet/" title="Codelet调度模型与Swdarts">Codelet调度模型与Swdarts</a><time datetime="2022-12-31T10:27:06.000Z" title="发表于 2022-12-31 18:27:06">2022-12-31</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2023 By Johnson Shuangjian</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://unpkg.com/@fancyapps/ui/dist/fancybox.umd.js"></script><script src="https://unpkg.com/node-snackbar/dist/snackbar.min.js"></script><script>var preloader = {
  endLoading: () => {
    document.body.style.overflow = 'auto';
    document.getElementById('loading-box').classList.add("loaded")
  },
  initLoading: () => {
    document.body.style.overflow = '';
    document.getElementById('loading-box').classList.remove("loaded")

  }
}
window.addEventListener('load',preloader.endLoading())</script><div class="js-pjax"><script>if (!window.MathJax) {
  window.MathJax = {
    tex: {
      inlineMath: [ ['$','$'], ["\\(","\\)"]],
      tags: 'ams'
    },
    chtml: {
      scale: 1.2
    },
    options: {
      renderActions: {
        findScript: [10, doc => {
          for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
            const display = !!node.type.match(/; *mode=display/)
            const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display)
            const text = document.createTextNode('')
            node.parentNode.replaceChild(text, node)
            math.start = {node: text, delim: '', n: 0}
            math.end = {node: text, delim: '', n: 0}
            doc.math.push(math)
          }
        }, ''],
        insertScript: [200, () => {
          document.querySelectorAll('mjx-container:not\([display]\)').forEach(node => {
            const target = node.parentNode
            if (target.nodeName.toLowerCase() === 'li') {
              target.parentNode.classList.add('has-jax')
            } else {
              target.classList.add('has-jax')
            }
          });
        }, '', false]
      }
    }
  }
  
  const script = document.createElement('script')
  script.src = 'https://unpkg.com/mathjax/es5/tex-mml-chtml.js'
  script.id = 'MathJax-script'
  script.async = true
  document.head.appendChild(script)
} else {
  MathJax.startup.document.state(0)
  MathJax.texReset()
  MathJax.typeset()
}</script><script>function loadValine () {
  function initValine () {
    const valine = new Valine(Object.assign({
      el: '#vcomment',
      appId: '45rLw57nAW4RPBI6unvz50nc-gzGzoHsz',
      appKey: 'PvsOoxvyj5yqCSzBb7lnWBD8',
      avatar: 'monsterid',
      serverURLs: '',
      emojiMaps: "",
      path: window.location.pathname,
      visitor: false
    }, null))
  }

  if (typeof Valine === 'function') initValine() 
  else getScript('https://unpkg.com/valine/dist/Valine.min.js').then(initValine)
}

if ('Valine' === 'Valine' || !false) {
  if (false) btf.loadComment(document.getElementById('vcomment'),loadValine)
  else setTimeout(loadValine, 0)
} else {
  function loadOtherComment () {
    loadValine()
  }
}</script></div><script defer="defer" id="fluttering_ribbon" mobile="true" src="https://unpkg.com/butterfly-extsrc/dist/canvas-fluttering-ribbon.min.js"></script><script src="https://unpkg.com/butterfly-extsrc/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = false;
POWERMODE.mobile = false;
document.body.addEventListener('input', POWERMODE);
</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"debug":false,"model":{"scale":1,"hHeadPos":0.5,"vHeadPos":0.618,"jsonPath":"/live2dw/assets/koharu.model.json"},"display":{"superSample":2,"width":150,"height":300,"position":"left","hOffset":-5,"vOffset":-5},"mobile":{"show":false,"scale":0.5},"react":{"opacityDefault":0.7,"opacityOnHover":0.2},"log":false});</script></body></html>