<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>操作系统（一） | AFlyingSheep's Blog</title><meta name="keywords" content="Courses"><meta name="author" content="Johnson Shuangjian"><meta name="copyright" content="Johnson Shuangjian"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="计算机专业课《操作系统》笔记，包括第一~三章。主讲教师：杨志豪。">
<meta property="og:type" content="article">
<meta property="og:title" content="操作系统（一）">
<meta property="og:url" content="http://aflyingsheep.github.io/2022/06/07/Review%20notes/OS1/index.html">
<meta property="og:site_name" content="AFlyingSheep&#39;s Blog">
<meta property="og:description" content="计算机专业课《操作系统》笔记，包括第一~三章。主讲教师：杨志豪。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://aflyingsheep.github.io/image/OS/cover.png">
<meta property="article:published_time" content="2022-06-07T15:06:07.000Z">
<meta property="article:modified_time" content="2023-02-11T13:38:06.412Z">
<meta property="article:author" content="Johnson Shuangjian">
<meta property="article:tag" content="Courses">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://aflyingsheep.github.io/image/OS/cover.png"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://aflyingsheep.github.io/2022/06/07/Review%20notes/OS1/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://unpkg.com/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://unpkg.com/node-snackbar/dist/snackbar.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://unpkg.com/@fancyapps/ui/dist/fancybox.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#1f1f1f","position":"bottom-left"},
  source: {
    justifiedGallery: {
      js: 'https://unpkg.com/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://unpkg.com/flickr-justified-gallery/dist/fjGallery.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '操作系统（一）',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-02-11 21:38:06'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-math@4.0.0/dist/style.css">
<!-- hexo injector head_end end --><meta name="generator" content="Hexo 5.4.2"><link rel="alternate" href="/atom.xml" title="AFlyingSheep's Blog" type="application/atom+xml">
</head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/userhead.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">40</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">14</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">11</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/image/OS/cover.png')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">AFlyingSheep's Blog</a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">操作系统（一）</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2022-06-07T15:06:07.000Z" title="发表于 2022-06-07 23:06:07">2022-06-07</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-02-11T13:38:06.412Z" title="更新于 2023-02-11 21:38:06">2023-02-11</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Courses/">Courses</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">11.3k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>33分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="操作系统（一）"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="操作系统引论"><a class="markdownIt-Anchor" href="#操作系统引论"></a> 操作系统引论</h1>
<h2 id="操作系统的定义"><a class="markdownIt-Anchor" href="#操作系统的定义"></a> 操作系统的定义</h2>
<ol>
<li>从资源管理的观点：操作系统是控制和管理计算机的软、硬件资源，合理组织计算机的工作流程，以方便用户的程序集合</li>
<li>从用户的观点：操作系统是配置计算机硬件上的第一层软件，是对硬件系统的第一次扩充</li>
<li>操作系统的目标：
<ol>
<li>有效性：提高系统资源利用率、提高系统吞吐量</li>
<li>方便性：方便用户通过OS操纵计算机系统</li>
<li>可扩充性：适应计算机硬件、体系结构以及应用的发展</li>
<li>开放性：遵循世界标准规范</li>
</ol>
</li>
<li>操作系统的作用
<ol>
<li>作为用户与计算机硬件系统之间的接口
<ul>
<li>用户可通过三种方式使用计算机：命令方式、系统调用方式、图形窗口方式</li>
</ul>
</li>
<li>作为计算机系统资源的管理者
<ul>
<li>四类资源：处理机管理、存储器管理、I/O设备管理、文件管理</li>
<li>处理机可执行的指令分为：特权指令（只能由操作系统使用）、非特权指令</li>
<li>处理机状态划分为：管态、目态</li>
<li>处理机状态保证了特权指令的正确使用，把OS与用户程序区分开来</li>
</ul>
</li>
<li>实现了计算机资源的抽象
<ul>
<li>裸机上覆盖上一层I/O设备管理软件，隐藏I/O设备操作的细节</li>
</ul>
</li>
</ol>
</li>
<li>操作系统发展的主要动力：
<ol>
<li>不断提高计算机资源的利用率</li>
<li>方便用户</li>
<li>器件的不断更新迭代</li>
<li>计算机体系结构的不断发展</li>
</ol>
</li>
</ol>
<h2 id="操作系统的发展过程"><a class="markdownIt-Anchor" href="#操作系统的发展过程"></a> 操作系统的发展过程</h2>
<ol>
<li>
<p>无操作系统的计算机系统</p>
<ol>
<li>
<p>人工操作方式：打孔纸带</p>
<p>缺点：用户独占全机、CPU等待人工操作</p>
</li>
<li>
<p>脱机输入输出：解决人机矛盾及CPU和I/O设备速度不匹配的矛盾。将装有用户程序和数据的纸带(或卡片)装入纸带输入机(或卡片机)，在一台外围机的控制下，把纸带(卡片)上的数据(程序)输入到磁带上。当CPU需要这些程序和数据时，再从磁带上将其高速地调入内存。</p>
<p>减少了CPU空闲时间，提高了I/O速度。</p>
</li>
</ol>
</li>
<li>
<p>单道批处理系统</p>
<ul>
<li>把一批作业以脱机方式输入到磁带上，并在系统中配上监督程序(Monitor)，在它的控制下使这批作业能一个接一个地连续处理。</li>
</ul>
<img src="/image/OS/image-20220610174529383.png" alt="image-20220610174529383" style="zoom:50%;" />
<ul>
<li>特征：自动性、顺序性、单道性</li>
</ul>
</li>
<li>
<p>多道批处理系统</p>
<ul>
<li>
<p>在该系统中，用户所提交的作业都先存放在外存上并排成一个队列，称为“后备队列”；然后，由作业调度程序按一定的算法从后备队列中选择若干个作业调入内存，使它们共享CPU和系统中的各种资源。</p>
<img src="/image/OS/image-20220610174938219.png" alt="image-20220610174938219" style="zoom:40%;" />
</li>
<li>
<p>优点：提高CPU利用率、提高内存和I/O设备利用率、增加系统吞吐量</p>
</li>
<li>
<p>特点：资源利用率高、系统吞吐量大、平均周转时间长、五交互能力</p>
</li>
<li>
<p>需要解决的问题：处理机管理问题、内存管理问题、I/O管理问题、文件管理问题、作业管理问题</p>
</li>
</ul>
</li>
<li>
<p>分时系统</p>
<ol>
<li>概念
<ol>
<li>分时：CPU时间分段处理</li>
<li>时间片：CPU的时间段</li>
<li>响应时间：从终端发出请求到系统给予回答所经历的时间</li>
</ol>
</li>
<li>分时系统的产生：分时系统(Time Sharing System)与多道批处理系统之间有着截然不同的性能差别，它能很好地将一台计算机提供给多个用户同时使用，提高计算机的利用率。用户的需求具体表现在以下几个方面：
<ol>
<li>人机交互</li>
<li>共享主机</li>
<li>便于用户上机</li>
</ol>
</li>
<li>分时系统实现中的关键问题
<ol>
<li>及时接收：配备多路卡，用于主机同时接受各用户从终端输入的数据。配置缓冲区缓存用户键入指令</li>
<li>及时处理：人机交互关键，使用户键入命令后能及时控制自己作业运行。所以各个用户作业都必须在内存中。</li>
</ol>
</li>
<li>分时系统特征：多路性、独立性、及时性、交互性</li>
</ol>
</li>
<li>
<p>实时系统</p>
<p>实时系统是指系统能及时(或即时)响应外部事件的请求，在规定的时间内完成对该事件的处理，并控制所有实时任务协调一致地运行。</p>
<ol>
<li>
<p>实时任务</p>
<ol>
<li>按任务执行时是否呈现周期性来划分：周期性实时任务、非周期性实时任务</li>
<li>根据对截止时间的要求来划分：硬实时任务、软实时任务</li>
</ol>
</li>
<li>
<p>实时系统与分时系统特征比较</p>
<ol>
<li>多路性：实时控制系统的多路性则主要表现在<strong>系统周期性地对多路现场信息进行采集，以及对多个对象或多个执行机构进行控制</strong>。而分时系统中的多路性则<strong>与用户情况有关</strong>，时多时少。</li>
<li>独立性</li>
<li>交互性：实时信息处理系统虽然也具有交互性，但这里人与系统的交互仅限于访问系统中某些特定的专用服务程序。它不像分时系统那样能向终端用户提供数据处理和资源共享等服务</li>
<li>及时性</li>
<li>可靠性：实时系统要求较高</li>
</ol>
<img src="/image/OS/image-20220610181108184.png" alt="image-20220610181108184" style="zoom:50%;" />
</li>
</ol>
</li>
</ol>
<h2 id="操作系统的基本特性"><a class="markdownIt-Anchor" href="#操作系统的基本特性"></a> 操作系统的基本特性</h2>
<p>并发性、共享性、虚拟性、异步性。并发和共享是操作系统两个最基本的特征。</p>
<ol>
<li>并发性
<ol>
<li>并行性是指两个或多个事件在同一时刻发生；而并发性是指两个或多个事件在同一时间间隔内发生。</li>
<li>多道程序环境下，并发性指在一段时间内，宏观上多个程序同时执行，但微观上每一时刻只有一个程序执行</li>
<li>进程：是指在系统中能独立运行并作为资源分配的基本单位。引入进程的目的：使多个程序能够并发执行</li>
<li>线程：在一个进程中可以包含若干个线程，可以利用进程拥有的资源。</li>
<li>OS中，将进程作为资源分配的基本单位，将线程作为独立运行、调度的基本单位。</li>
</ol>
</li>
<li>共享性
<ol>
<li>互斥共享方式：一段时间只允许一个进程（线程）访问资源，如打印机。</li>
<li>同时访问方式：进程可以交替对该资源进行访问，如磁盘设备。</li>
</ol>
</li>
<li>虚拟性
<ol>
<li>时间复用技术
<ol>
<li>虚拟处理机技术：利用多道程序设计技术，为每道程序建立一个进程，多道程序并发执行，以此分时使用一台处理机。</li>
<li>虚拟设备技术：将一台I/O设备虚拟为多台逻辑上的I/O设备，允许每个用户占用一台逻辑上的I/O设备。</li>
</ol>
</li>
<li>空分复用技术：将一个频率范围非常宽的信道，划分成多个频率范围较窄的信道，其中的任何一个频带都只供一对用户通话。在计算机中也使用了空分复用技术来<strong>提高存储空间的利用率</strong>。
<ol>
<li>虚拟磁盘技术：一台磁盘虚拟为多台虚拟磁盘</li>
<li>虚拟存储器技术：空分复用可以利用存储器的空闲空间来存放其它的程序，以提高内存的利用率。虚拟存储技术本质上是内存分时使用，通过时分复用方式，在远小于程序的内存空间中运行。</li>
</ol>
</li>
</ol>
</li>
<li>异步性：在单处理机环境下，由于系统中只有一台处理机，因而每次只允许一个进程执行，其余进程只能等待。由于资源等因素的限制，使进程的执行通常都不是“一气呵成”，而是以“停停走走”的方式运行。</li>
</ol>
<h2 id="操作系统的主要功能"><a class="markdownIt-Anchor" href="#操作系统的主要功能"></a> 操作系统的主要功能</h2>
<ol>
<li>处理机管理功能：进程控制、进程同步（互斥、同步）、进程通信、进程与作业调度</li>
<li>存储器管理功能：内存分配、内存保护、地址映射、内存扩充（虚拟技术）</li>
<li>设备管理功能：缓冲管理、设备分配、设备处理、I/O控制、磁盘调度</li>
<li>文件管理：文件存储空间的管理、目录管理、文件读写管理和保护</li>
<li>操作系统与用户之间的接口：命令接口（联机命令接口、脱机命令接口、图形用户界面）、程序接口（也称系统调用）</li>
</ol>
<h2 id="操作系统设计"><a class="markdownIt-Anchor" href="#操作系统设计"></a> 操作系统设计</h2>
<ol>
<li>
<p>传统操作系统结构</p>
<ol>
<li>
<p>无结构操作系统</p>
</li>
<li>
<p>模块化结构OS：将OS按其功能精心地划分为若干个具有一定独立性和大小的模块；每个模块具有某方面的管理功能。仔细地规定好各模块间的接口，使各模块之间能通过该接口实现交互；进一步将各模块细分为若干个具有一定功能的子模块。</p>
<p>优点：提高OS设计的正确性、可理解性和可维护性；增强OS适应性、加速OS开发过程</p>
<p>缺点：模块间接口难满足实际需求；开发无序。</p>
<img src="/image/OS/image-20220610185210097.png" alt="image-20220610185210097" style="zoom:50%;" />
</li>
<li>
<p>分层式结构OS：为了将模块-接口法中“决定顺序”的无序性变为有序性，引入了有序分层法。</p>
<p>在目标系统An和裸机系统A0之间铺设若干层次软件，最终能在A0上运行。常采用自底向上法铺设。</p>
<p>优点：易证明正确性、易扩充和维护；缺点：系统效率降低。</p>
<img src="/image/OS/image-20220610185623932.png" alt="image-20220610185623932" style="zoom:50%;" />
</li>
</ol>
</li>
<li>
<p>客户/服务器模式（C/S模式）</p>
<ol>
<li>组成：客户机（在一个LAN网络上连接多台网络工作站）、服务器（规模较大的机器）、网络系统（用于连接所有客户机和服务器）</li>
<li>C/S模式优点：数据的分布处理和存储；便于集中管理；灵活性和可扩充性；易于改编应用软件</li>
</ol>
</li>
<li>
<p>面向对象的程序设计</p>
</li>
<li>
<p>微内核OS结构</p>
<ol>
<li>足够小的内核：微内核并非是一个完整的OS，而只是操作系统中最基本的部分，它通常用于：① 实现与硬件紧密相关的处理；② 实现一些较基本的功能；③ 负责客户和服务器之间的通信。它们只是为构建通用OS提供一个重要基础，这样就可以确保把操作系统内核做得很小。</li>
<li>基于客户/服务器模式</li>
<li>应用机制与策略分离原理</li>
<li>采用面向对象技术</li>
</ol>
<p>微内核的基本功能：进程管理、低级存储器管理、中断和陷入处理</p>
<img src="/image/OS/image-20220610190801483.png" alt="image-20220610190801483" style="zoom:50%;" />
</li>
</ol>
<h2 id="习题"><a class="markdownIt-Anchor" href="#习题"></a> 习题</h2>
<ol>
<li>
<p>在计算机系统中配置操作系统的主要目的是(A)，操作系统的主要功能是管理计算机系统中的(B)，包括©和(D)，以及文件和设备。这里©的管理主要是对进程进行管理。</p>
<p>A (1) 增强计算机系统的功能 (2) 提高系统资源的利用率 (3) 提高系统运行速度 (4) 合理组织系统的工作流程以提高吞吐量</p>
<p>B (1) 程序和数据 (2) 进程 (3) 资源 (4) 作业 (5) 软件 (6) 硬件</p>
<p>C, D (1) 存储器 (2) 虚拟存储器 (3) 运算器 (4) 处理机 (5) 控制器</p>
</li>
<li>
<p>操作系统是一种系统软件，它负责为用户和用户程序完成(A)的工作。</p>
<p>A (1) 与硬件无关并与应用无关 (2) 与硬件相关而与应用无关 (3) 与硬件无关而与应用相关 (4) 与硬件相关并与应用相关</p>
</li>
<li>
<p>在多道批处理系统中，为了充分利用各种资源，系统总是优先选择(A)多个作业投入运行；为了提高吞吐量，系统总是想方设法缩短用户作业的(B)</p>
<p>A (1) 适应于内存容量的 (2) 计算量大的 (3) I/O量大的 (4) 计算型和I/O型均衡的</p>
<p>B (1) 周转时间 (2) 运行时间 (3) 提交时间 (4) 阻塞时间</p>
</li>
<li>
<p>分时系统响应时间（及时性）主要是根据(A)确定的，而实时系统的响应时间则是由(B)确定的。</p>
<p>A, B (1) 时间片大小 (2) 用户数目 (3) 计算机运行速度 (4) 用户所能接受的等待时间 (5) 控制对象所能接受的时延 (6) 实时调度</p>
</li>
<li>
<p>分时系统和实时系统都有交互性，实时系统的交互性允许用户访问(A)，分时系统的交互性允许用户请求系统提供(B)。</p>
<p>A (1) 文字编辑程序 (2) 专用服务程序 (3) 专用硬件 (4) 数据处理程序</p>
<p>B (1) 数据处理服务 (2) 资源共享服务 (3) 数据通信服务 (4) 多方面的服务</p>
</li>
</ol>
<p>答案：1. A(2) B(3) C(4) D(1) 2. A(2) 3. A(4) B(1) 4. A(4) B(5) 5. A(2) B(4)</p>
<h1 id="进程管理"><a class="markdownIt-Anchor" href="#进程管理"></a> 进程管理</h1>
<h2 id="进程的基本概念"><a class="markdownIt-Anchor" href="#进程的基本概念"></a> 进程的基本概念</h2>
<ol>
<li>
<p>程序的顺序执行：在各程序段之间，必须按照某种先后次序顺序执行</p>
<p>程序顺序执行的特征：顺序性、封闭性（程序一旦开始，执行结果不受外界影响）、可再现性</p>
</li>
<li>
<p>程序的并发执行</p>
<ol>
<li>并发程序：是指两道或两道以上程序同时装入内存中运行，这些程序的执行在时间上互相有重叠，即在一个程序执行结束之前，另一个程序已经开始执行。</li>
<li>特征：间断性、失去封闭性、不可再现性</li>
</ol>
</li>
<li>
<p>进程的特征和定义</p>
<p>在多道程序环境下，程序的执行属于并发执行，此时它们将失去其封闭性，并具有间断性及不可再现性的特征。为使程序能并发执行，且为了对并发执行的程序加以描述和控制，人们引入了“进程”的概念。</p>
<ol>
<li>
<p>进程的定义</p>
<ul>
<li>进程是程序的一次执行</li>
<li>进程是一个程序及其数据在处理机上顺序执行所发生的活动</li>
<li>进程是程序在一个数据集合上运行的过程，它是系统进行资源分配和调度的一个独立单位</li>
</ul>
</li>
<li>
<p>进程的特征：</p>
<ul>
<li>结构性：通常程序无法并行执行，为使程序能独立运行，应配置一个进程控制块（PCB）；由程序段、相关数据和PCB构成了进程实体。创建进程：创建进程实体中的PCB。撤销便是撤销进程的PCB。</li>
<li>动态性</li>
<li>并发性</li>
<li>独立性</li>
<li>异步性</li>
</ul>
</li>
<li>
<p>进程的基本状态：就绪、执行（单处理机系统只有一个进程处于执行状态）、阻塞</p>
<img src="/image/OS/image-20220611101211062.png" alt="image-20220611101211062" style="zoom:50%;" />
</li>
<li>
<p>挂起状态：某进程在计算机操作系统中暂时被调离出内存的状况。</p>
<ol>
<li>
<p>引入挂起状态的原因：终端用户的请求；父进程请求；负荷调节的需要；操作系统的需要</p>
<img src="/image/OS/image-20220611101436073.png" alt="image-20220611101436073" style="zoom:50%;" />
</li>
</ol>
</li>
<li>
<p>创建状态和终止状态</p>
<ol>
<li>
<p>创建状态：创建一个进程一般要通过两个步骤：首先，为一个新进程创建PCB，并填写必要的管理信息；其次，把该进程转入就绪状态并插入就绪队列之中。</p>
<p>当一个新进程被创建时，系统已为其分配了PCB，填写了进程标识等信息，但由于该进程所必需的资源或其它信息，如主存资源尚未分配等，一般而言，此时的进程已拥有了自己的PCB，但进程自身还未进入主存，<strong>即创建工作尚未完成</strong>，<strong>进程还不能被调度运行</strong>，其所处的状态就是创建状态。</p>
</li>
<li>
<p>终止状态：当一个进程到达了自然结束点，或是出现了无法克服的错误，或是被操作系统所终结，或是被其他有终止权的进程所终结，它将进入终止状态。</p>
<p>进程的终止也要通过两个步骤：首先等待操作系统进行善后处理，然后将其PCB清零，并将PCB空间返还系统。</p>
<p>进入终止态的进程以后不能再执行，但在操作系统中依然保留一个记录，其中保存状态码和一些计时统计数据，供其它进程收集。一旦其它进程完成了对终止状态进程的信息提取之后，操作系统将删除该进程。</p>
<img src="/image/OS/image-20220611101850019.png" alt="image-20220611101850019" style="zoom:50%;" />
<img src="/image/OS/image-20220611101900085.png" alt="image-20220611101900085" style="zoom:50%;" />
<p>当系统资源足够时，进程创建后便给其分配资源，进入活动就绪状态；当系统资源和性能不足时，并不分配给新建进程所需资源（特别是主存），进程状态为静止就绪状态，换到外存，不参与调度。</p>
</li>
</ol>
</li>
<li>
<p>进程控制块PCB</p>
<ol>
<li>
<p>作用：为了描述和控制进程的运行，系统为每个进程定义了一个数据结构——进程控制块PCB，它是进程实体的一部分，是操作系统中最重要的记录型数据结构。作用是使一个在多道程序环境下不能独立运行的程序(含数据)，成为一个能独立运行的基本单位，一个能与其它进程并发执行的进程。</p>
</li>
<li>
<p>系统总是通过PCB对进程进行控制：</p>
<ul>
<li>OS调度某进程执行时，要从该进程PCB中查出先行状态及优先级</li>
<li>调度到某进程后，要根据其PCB中所保存的处理及状态信息，设置该进程恢复运行的现场，根据PCB中程序和数据的内存始址，找出其程序和数据</li>
<li>进程执行过程中，需要和与之合作的进程同步、通信或访问文件时，也需要访问PCB</li>
<li>进程由于某种原因暂停执行时，需将断点的处理机环境保存在PCB中</li>
</ul>
</li>
<li>
<p>进程常驻内存，放在OS专门开辟的PCB区内。</p>
</li>
<li>
<p>进程控制块中的信息</p>
<ol>
<li>进程标识信息：内部标识符（PID）、外部标识符</li>
<li>处理机状态信息：通用寄存器、PC、PSW、用户栈指针</li>
<li>进程调度信息：进程状态、优先级、调度所需其他信息</li>
<li>进程控制信息：程序和数据地址、进程同步和通信机制、资源清单、链接指针</li>
</ol>
</li>
<li>
<p>PCB的组织方式</p>
<ol>
<li>
<p>链接方式：把具有同一状态的PCB，用其中的链接字链接成一个队列。这样，可以形成就绪队列、若干个阻塞队列和空白队列等。</p>
<img src="/image/OS/image-20220611103320670.png" alt="image-20220611103320670" style="zoom:50%;" />
</li>
<li>
<p>索引方式：系统根据所有进程的状态建立几张索引表，并把各索引表在内存的首地址记录在内存的一些专用单元中。</p>
<img src="/image/OS/image-20220611103400450.png" alt="image-20220611103400450" style="zoom:50%;" />
</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
</ol>
<h2 id="进程控制"><a class="markdownIt-Anchor" href="#进程控制"></a> 进程控制</h2>
<p>进程控制是进程管理中最基本的功能。它用于<strong>创建一个新进程</strong>，<strong>终止一个已完成的进程</strong>，或<strong>终止一个因出现某事件而使其无法运行下去的进程</strong>，还可负责进程运行中的状态转换。</p>
<ol>
<li>
<p>原语：机器语言编写、常驻内存、不可中断（下图为四个控制原语）</p>
<img src="/image/OS/image-20220611104308381.png" alt="image-20220611104308381" style="zoom:33%;" />
</li>
<li>
<p>进程控制</p>
<ol>
<li>
<p>进程图：用于描述一个进程的家族关系的有向树</p>
<img src="/image/OS/image-20220611104350316.png" alt="image-20220611104350316" style="zoom:33%;" />
</li>
<li>
<p>引起创建进程的事件：用户登录、作业调度（批处理系统，调度到某作业时，装入内存、分配资源、创建线程、插入到就绪队列）、提高服务（用户程序提出某种请求）、应用请求</p>
<p>进程创建原语：Create():申请空白PCB、为新进程分配资源、初始化PCB、插入到就绪队列</p>
</li>
<li>
<p>引起进程终止的事件：正常结束、异常结束（越界错误、保护错-访问不允许访问或不适当方式访问、非法指令等）、外界干预</p>
<p>进程终止原语：termination():根据被终止进程的标识符，取出PCB读出状态、若处于执行态立刻终止、终止子孙进程、归还被终止进程资源、将被终止进程PCB从队列移除</p>
</li>
<li>
<p>引起进程阻塞或唤醒事件：请求系统服务（阻塞）、启动某种操作（阻塞）、新数据尚未到达（阻塞）、无新工作可做（阻塞）</p>
<p>进程阻塞原语：Block() 进程唤醒原语：Wakeup()</p>
<ul>
<li>Block(): 1. 进程停止执行 2. PCB现行状态执行变为阻塞 3. PCB插入阻塞队列 4. 调用调度程序重新调度</li>
<li>Wakeup(): 1. 将被阻塞进程从阻塞队列移除 2. PCB现行状态变为就绪 3. PCB插入就绪队列</li>
<li>Suspend() 1. 检查被挂起进程状态，若处于活动就绪则改为静止就绪；若处于活动阻塞则改为静止阻塞 2. PCB复制到内存区域 3. 若被挂起进程正在执行则重新调度</li>
</ul>
</li>
</ol>
</li>
</ol>
<h2 id="进程同步"><a class="markdownIt-Anchor" href="#进程同步"></a> 进程同步</h2>
<ol>
<li>
<p>进程同步基本概念</p>
<ol>
<li>
<p>并发进程之间的制约关系：间接制约关系（共享某种资源）、直接制约关系（进程间合作）</p>
<img src="/image/OS/image-20220611110140013.png" alt="image-20220611110140013" style="zoom:50%;" />
</li>
<li>
<p>临界资源：一次只允许一个进程使用的资源</p>
</li>
<li>
<p>临界区：包含临界资源的程序段。每个进程在进入临界区之前，应先对欲访问的临界资源进行检查，看它是否正被访问。必须在临界区前面增加一段用于进行上述检查的代码，把这段代码称为进入区(entry section)。相应地，在临界区后面也要加上一段称为退出区(exit section)的代码，用于将临界区正被访问的标志恢复为未被访问的标志。</p>
</li>
<li>
<p><strong>同步机制遵循原则（临界区调度原则）</strong></p>
<ol>
<li>空闲让进</li>
<li>忙则等待</li>
<li>有限等待：对要求访问临界资源的进程应保证在有限时间内进入</li>
<li>让权等待：不能进入自己临界区时应立即释放</li>
</ol>
</li>
<li>
<p>信号量机制</p>
<ol>
<li>
<p>整形信号量：一个用于表示资源数目的整型量S，仅能通过原语Wait(s)和signal(s)操作。</p>
<p>wait操作当S≤0时会一直测试，不遵循让权等待。</p>
</li>
<li>
<p>记录形信号量：增加进程链表L，链接所有等待进程。</p>
<p>S.value初值表示系统中某类资源的数目。每次Wait操作都意味着进程请求一个单位的该类资源，当S.value＜0时，表示该类资源已分配完毕，应调用block()自我阻塞。</p>
<p>每次signal代表释放一个，当释放以后S.value仍然≤0，应该wakeup唤醒S.L第一个等待的进程。</p>
<p>当初值为1代表互斥信号量。</p>
</li>
<li>
<p>AND型信号量：将进程在整个运行过程中需要的所有资源，一次性全部地分配给进程，待进程使用完后再一起释放。只要尚有一个资源未能分配给进程，其它所有可能为之分配的资源也不分配给它。</p>
<p>Swait(Dmutex, Emutex)和Ssignal(Dmutex, Emutex)</p>
</li>
<li>
<p>信号量集：Swait(S1，t1，d1，…，Sn，tn，dn)操作可描述如下，其中S为信号量，d为需求值，而t为下限值。</p>
<ul>
<li>Swait(S，d，d)。此时，在信号量集中只有一个信号量S，但允许它每次申请d个资源，当现有资源数少于d时，不予分配。</li>
<li>Swait(S，1，1)。此时的信号量集已蜕化为一般的记录型信号量(S&gt;1时)或互斥信号量(S=1时)。</li>
<li>Swait(S，1，0)。这是一种很特殊且很有用的信号量操作。当S≥1时，允许多个进程进入某特定区；当S变为0后，将阻止任何进程进入特定区。换言之，它相当于一个可控开关。</li>
</ul>
</li>
</ol>
</li>
<li>
<p>管程：代表共享资源的数据结构，以及由对该共享数据结构实施操作的一组过程所组成的资源管理程序，共同构成了一个操作系统的资源管理模块。</p>
<ol>
<li>
<p>管程的组成：管程名称、局部于管程内部的共享数据结构说明、对该数据结构进行操作的一组过<br />
程、对局部于管程内部的共享数据设置初始值的语句。</p>
<img src="/image/OS/image-20220611112957353.png" alt="image-20220611112957353" style="zoom:50%;" />
</li>
<li>
<p>管程特性：模块化、抽象数据类型、信息掩蔽</p>
</li>
<li>
<p>管程和进程的区别</p>
<ul>
<li>进程定义的是私有数据结构PCB，管程定义公有数据结构</li>
<li>进程是由顺序程序执行有关操作，管程主要进行进程同步和初始化操作</li>
<li>设置进程目的：实现系统并发行；设置管程目的：解决共享资源互斥使用</li>
<li>管程：被动工作；进程：主动工作</li>
<li>进程之间并发执行；管程不可与调用者并发</li>
<li>进程具有动态性，创建、撤销；管程是OS中资源管理模块，供进程使用。</li>
</ul>
</li>
<li>
<p>条件变量：</p>
<ol>
<li>x.wait：正在调用管程的进程因x条件需要被阻塞或挂起，则调用x.wait将自己插入到x条件的等待队列上，并释放管程，直到x条件变化。此时其它进程可以使用该管程。</li>
<li>x.signal：正在调用管程的进程发现x条件发生了变化，则调用x.signal，唤醒一个因x条件而阻塞或挂起的进程。如果存在多个这样的进程，则选择其中的一个，如果没有，则继续执行原进程，而不产生任何结果。（这与信号量机制中的signal操作不同，因为后者总是要执行s:=s+1操作，因而总会改变信号量的状态。）</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
</ol>
<h2 id="经典进程同步问题"><a class="markdownIt-Anchor" href="#经典进程同步问题"></a> 经典进程同步问题</h2>
<p>生产者消费者、读者写者、哲学家吃饭</p>
<h2 id="进程通信"><a class="markdownIt-Anchor" href="#进程通信"></a> 进程通信</h2>
<p>进程之间有两种信息需要交换：低级通信（传递控制信息）、高级信息（传递数据）</p>
<p>目前，高级通信机制归结为三大类：共享存储器系统、信息传递系统和管道通信系统</p>
<ol>
<li>
<p>共享存储器系统：相互通信的进程共享某些数据结构或共享存储区，进程便可以通过这些空间通信。</p>
<ol>
<li>基于共享数据结构的通信方式：要求进程公用某些数据结构，借以实现诸进程间的信息交换。如在生产者—消费者问题中，就是用有界缓冲区这种数据结构来实现通信的。低效、只适合传递少量数据。</li>
<li>基于共享存储区的通信方式。为了传输大量数据，在存储器中划出了一块共享存储区，进程可通过对共享存储区中数据的读写来实现通信。需要程序员自己设置同步和互斥措施才能保证实现正确的通信。</li>
</ol>
</li>
<li>
<p>消息传递系统：进程间的数据交换是以格式化的消息为单位的；程序员直接利用操作系统提供的一组通信命令(原语)。</p>
<ol>
<li>直接通信方式：原语——Send(Receiver, message), Receive(Sender, message)</li>
<li>间接通信方式：利用邮箱通信方式，可实现实时和非实时通信。提供若干原语：
<ol>
<li>创建、撤销邮箱</li>
<li>发送、接受消息 Send(mailbox, message), Receive(mailbox, message)</li>
<li>三种信箱：私用信箱（单向）、公用信箱（双向，操作系统创建）、共享信箱（创建时期指明共享，同时指出共享进程）</li>
</ol>
</li>
</ol>
</li>
<li>
<p>管道通信</p>
<ol>
<li>
<p>所谓“管道”，是指用于连接一个读进程和一个写进程以实现它们之间通信的一个共享文件，又名pipe文件。</p>
</li>
<li>
<p>写进程以<strong>字符流</strong>形式将大量数据送入管道，读数据读走。</p>
</li>
<li>
<p>管道机制必须提供以下三方面协调能力：</p>
<ol>
<li>互斥：一个进程对管道读写，另一进程须等待</li>
<li>同步：写进程写入pipe后去睡眠等待，直至读进程取走在唤醒；读进程读空pipe后也应等待，写进程写入管道后再唤醒。</li>
<li>确定对方是否存在：确定已存在才能进行通信。</li>
</ol>
<img src="/image/OS/image-20220611161200234.png" alt="image-20220611161200234" style="zoom:50%;" />
</li>
</ol>
</li>
<li>
<p>信息传递的实现</p>
<ol>
<li>通信链路：
<ol>
<li>两种方式建立：显式建立（建立连接原语请求建立，需要显示拆除）、自动建立（利用系统发送原语，系统自动建立，主要用于单机）</li>
<li>根据连接方式分为两类：点对点、多点连接链路</li>
<li>根据通信方式分为两类：单向、双向链路</li>
<li>根据链路容量分为两类：无容量（没有缓冲区）、有容量链路</li>
</ol>
</li>
<li>消息格式
<ol>
<li>可以分为消息头+消息正文。</li>
<li>定长消息格式、变长消息格式</li>
</ol>
</li>
<li>进程同步方式
<ol>
<li>发送进程阻塞，接收进程阻塞</li>
<li>发送进程不阻塞，接受进程阻塞（常用）</li>
<li>发送和接收进程均不阻塞（较常见）</li>
</ol>
</li>
</ol>
</li>
<li>
<p>消息缓冲队列通信机制</p>
<ol>
<li>消息缓冲区</li>
<li>PCB中有关通信的数据项：增加消息队列首指针，用于对消息队列进行操作</li>
<li>发送、接受原语</li>
</ol>
<h2 id="线程"><a class="markdownIt-Anchor" href="#线程"></a> 线程</h2>
</li>
</ol>
<img src="/image/OS/image-20220611161354461.png" alt="image-20220611161354461" style="zoom:40%;" />
<ol>
<li>
<p>线程的基本概念：</p>
<ol>
<li>调度：引入线程的OS中，把<strong>线程</strong>作为<strong>调度和分派</strong>的基本单位，把<strong>进程</strong>作为<strong>资源拥有</strong>的基本单位。</li>
<li>并发性：引入线程的OS中，不仅进程之间可以并发执行，一个进程内的<strong>多个线程之间也可以并发执行</strong></li>
<li>拥有资源：线程自己不拥有系统资源，但它可以访问其隶属进程的资源</li>
<li>系统开销：线程切换的代价远低于进程</li>
<li>此外，一个进程中的多个线程具有相同的地址空间，在同步和通信的实现方面线程也比进程容易。</li>
</ol>
</li>
<li>
<p>线程的属性</p>
<ol>
<li>轻型实体：不拥有系统资源，只有必不可少、能保证其独立运行的资源（如TCB）</li>
<li>独立调度和分配的基本单位</li>
<li>可并发执行</li>
<li>共享进程资源</li>
</ol>
</li>
<li>
<p>线程的状态</p>
<ol>
<li>状态参数：寄存器状态、堆栈、线程运行状态、优先级、线程专有存储器、信号屏蔽</li>
<li>运行状态：执行、就绪、阻塞状态</li>
</ol>
</li>
<li>
<p>线程的创建和终止</p>
<ol>
<li>应用程序在启动时，通常仅有一个线程在执行，该线程被人们称为“初始化线程”。它可根据需要再去创建若干个线程。</li>
</ol>
</li>
<li>
<p>多线程OS中的进程</p>
<ol>
<li>作为系统资源分配的基本单位</li>
<li>可包含多个线程</li>
<li>进程不是一个可执行的实体</li>
</ol>
</li>
<li>
<p>线程实现方式</p>
<ol>
<li>
<p>内核支持线程：不论什么进程，都是在操作系统内核支持下运行的，与内核紧密相关。内核支持线程中，无论是系统还是用户进程中的线程，创建、撤销、切换均由内核完成。</p>
<p>优点：内核能够同时调度同一进程的多个线程并行执行；进程中一个线程被阻塞了，内核可以调度当前进程或其他进程的线程执行；线程切换快；可采用多线程技术。</p>
<p>缺点：用户的线程切换开销较大。（需要在管态和目态切换）</p>
</li>
<li>
<p>用户级线程：对于这种线程的创建、撤消、线程之间的同步与通信等功能，都无须利用系统调用来实现。</p>
<p>优点：线程切换不需要转到内核空间；调度算法可以是进程专用的；用户级线程的实现与操作系统无关。</p>
<p>缺点：系统调用的阻塞问题（线程执行一个系统调用后，该线程所属进程的全部线程均被阻塞）；多线程应用不能利用多处理机进行多重处理。</p>
</li>
<li>
<p>组合方式：内核支持KST线程建立、调度和管理，也允许用户应用程序建立、调度和管理用户级线程；同一个进程内的多个线程可以同时在多处理器上并行执行，而且在阻塞一个线程时，并不需要将整个进程阻塞。</p>
<img src="/image/OS/image-20220611163842026.png" alt="image-20220611163842026" style="zoom:50%;" />
</li>
<li>
<p>用户级线程与内核控制线程的连接</p>
<ol>
<li>
<p>一对一模型：为每一个用户线程都设置一个内核控制线程与之连接，当一个线程阻塞时，允许调度另一个线程运行。在多处理机系统中，则有多个线程并行执行。</p>
</li>
<li>
<p>多对一模型：将多个用户线程映射到一个内核控制线程，为了管理方便，这些用户线程一般属于一个进程，运行在该进程的用户空间，对这些线程的调度和管理也是在该进程的用户空间中完成。当用户线程需要访问内核时，才将其映射到一个内核控制线程上，但每次只允许一个线程进行映射。</p>
<p>线程管理开销小、效率高，但一个线程访问内核阻塞，整个进程都阻塞。同时在多处理机系统中，一个进程的多个线程无法实现并行。</p>
</li>
<li>
<p>多对多模型：该模型结合上述两种模型的优点，将多个用户线程映射到多个内核控制线程，内核控制线程的数目可以根据应用进程和系统的不同而变化，可以比用户线程少，也可以与之相同。</p>
</li>
</ol>
</li>
</ol>
</li>
</ol>
<h2 id="习题-2"><a class="markdownIt-Anchor" href="#习题-2"></a> 习题</h2>
<ol>
<li>
<p>若进程正处于执行状态时，因终端请求而停下来以便研究其运行状况，此时进程应转变为(A)状态。</p>
</li>
<li>
<img src="/image/OS/image-20220611234353131.png" alt="image-20220611234353131" style="zoom:50%;" />
</li>
<li>
<p>批处理系统中，导致进程创建的典型事件是(A)</p>
<p>A (1) 作业录入 (2) 作业调度 (3) 进程调度 (4) 中级调度</p>
</li>
<li>
<img src="/image/OS/image-20220611234632211.png" alt="image-20220611234632211" style="zoom:50%;" />
</li>
</ol>
<p>答案：1. 静止就绪 2. A(1) B(3) C(5) D 中断 3. A(2) 4. A.(4) B. (3) C.(2) D.(5) E.(5)</p>
<h1 id="处理机调度与死锁"><a class="markdownIt-Anchor" href="#处理机调度与死锁"></a> 处理机调度与死锁</h1>
<h2 id="处理机调度的层次"><a class="markdownIt-Anchor" href="#处理机调度的层次"></a> 处理机调度的层次</h2>
<p>调度分为三个层次：高级调度（作业调度）、中级调度（交换调度）、低级调度（进程调度）</p>
<ol>
<li>
<p>高级调度</p>
<ol>
<li>
<p>作业：比程序更广泛的概念，作业 = JCB + 作业说明书 + 程序 + 数据。批处理系统中以作业为基本单位从外存调入内存。</p>
<p>作业步：每个作业在运行期间都会经过若干独立的加工步骤，我们将每一个加工步骤成为作业步。</p>
<p>典型的作业分为三个作业步：编译作业步、连结装配作业步、运行作业步</p>
</li>
<li>
<p>作业控制块PCB：多道批处理系统中为每个作业设置了一个作业控制块，它是作业在系统中存在的标志，其中保存了系统对作业进行管理和调度所需的全部信息。</p>
<p>每个作业进入系统时，系统为每个作业建立一个JCB，根据作业类型将它插入相应的<strong>后备队列</strong>中。</p>
<p><strong>作业调度程序</strong>依据一定的调度算法来调度它们，被调度到的作业将会装入内存。在作业运行期间，系统就按照JCB中的信息对作业进行控制。当一个作业执行结束进入完成状态时，系统负责回收分配给它的资源，撤消它的作业控制块。</p>
</li>
<li>
<p>作业状态</p>
<img src="/image/OS/image-20220611191420351.png" alt="image-20220611191420351" style="zoom:50%;" />
<ul>
<li>
<p>作业提交：作业的输入（从输入设备到外存）；</p>
</li>
<li>
<p>作业收容（就绪）：作业输入（到外存）完成，系统为其建立JCB，等待调度运行；</p>
</li>
<li>
<p>作业执行：分配资源，送入内存，被调度运行；</p>
</li>
<li>
<p>作业完成：释放资源，完成作业输出；</p>
<img src="/image/OS/image-20220611191733863.png" alt="image-20220611191733863" style="zoom:50%;" />
</li>
</ul>
</li>
<li>
<p>作业调度</p>
<ol>
<li>作业调度的主要功能：<strong>根据作业控制块中的信息，审查系统能否满足用户作业的资源需求，以及按照一定的算法，从外存的后备队列中选取某些作业调入内存，并为它们创建进程、分配必要的资源。然后再将新创建的进程插入就绪队列，准备执行。</strong></li>
<li>周转时间 = 完成时间 - 提交时间 =  等待时间 + 运行时间</li>
<li>四种调度模型：FIFO、短作业优先、响应比高优先、基于作业优先级</li>
</ol>
</li>
</ol>
</li>
<li>
<p>低级调度</p>
<p>通常也把低级调度(Low Level Scheduling)称为进程调度或短程调度，它所调度的对象是<strong>进程(或内核级线程)</strong>。进程调度是最基本的一种调度，在多道批处理、分时和实时三种类型的OS中，都必须配置这级调度。</p>
<ol>
<li>低级调度的功能：保存处理机现场信息、按某种算法选取进程、把处理机分配给进程</li>
<li>低级调度三个基本机制：排队器、分派器、上下文切换机制（切换的主要开销）</li>
<li>进程调度方式：
<ol>
<li>非抢占式方式：实时要求比较严格的实时系统中，不宜采用这种调度方式。</li>
<li>抢占方式：优先权原则、短作业优先原则、时间片原则</li>
</ol>
</li>
</ol>
</li>
<li>
<p>中级调度</p>
<p>选择在外存上的那些具备运行条件的就绪进程，将它们重新调入内存，并修改其状态为就绪状态，挂在就绪队列上等待进程调度。</p>
<ol>
<li>
<p>中级调度实际上就是存储器管理中的对换功能。</p>
</li>
<li>
<p>引入目的：提高内存利用率和吞吐量。</p>
<img src="/image/OS/image-20220611194114021.png" alt="image-20220611194114021" style="zoom:50%;" />
</li>
</ol>
</li>
</ol>
<h2 id="调度队列模型和调度准则"><a class="markdownIt-Anchor" href="#调度队列模型和调度准则"></a> 调度队列模型和调度准则</h2>
<ol>
<li>
<p>调度队列模型</p>
<ol>
<li>
<p>仅有进程调度的调度队列模型：时间片</p>
<img src="/image/OS/image-20220611194539240.png" alt="image-20220611194539240" style="zoom:50%;" />
</li>
<li>
<p>具有高级和低级调度的调度队列模型</p>
<ul>
<li>作业调度按一定的作业调度算法，从外存的后备队列中选择一批作业调入内存，并为它们建立进程，送入就绪队列，然后才由进程调度按照一定的进程调度算法选择一个进程，把处理机分配给该进程。</li>
<li>就绪队列的形式。在批处理系统中，最常用的是最高优先权优先调度算法，相应地，最常用的就绪队列形式是优先权队列。</li>
</ul>
<img src="/image/OS/image-20220611194635546.png" alt="image-20220611194635546" style="zoom:50%;" />
</li>
<li>
<p>具有三级调度的调度队列模型</p>
<img src="/image/OS/image-20220611194916457.png" alt="image-20220611194916457" style="zoom:50%;" />
</li>
</ol>
</li>
<li>
<p>面向用户的准则：周转时间短、响应时间快、截止时间保证、优先权准则</p>
<ul>
<li>平均周转时间  <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>T</mi><mo>=</mo><mstyle displaystyle="true" scriptlevel="0"><mfrac><mn>1</mn><mi>n</mi></mfrac></mstyle><mo stretchy="false">[</mo><msubsup><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>n</mi></msubsup><msub><mi>T</mi><mi>i</mi></msub><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">T=\dfrac{1}{n}[\sum_{i=1}^nT_i]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.00744em;vertical-align:-0.686em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.32144em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal">n</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mopen">[</span><span class="mop"><span class="mop op-symbol small-op" style="position:relative;top:-0.0000050000000000050004em;">∑</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.804292em;"><span style="top:-2.40029em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.2029em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.29971000000000003em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">]</span></span></span></span></li>
<li>带权周转时间 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>W</mi><mo>=</mo><mstyle displaystyle="true" scriptlevel="0"><mfrac><mi>T</mi><msub><mi>T</mi><mi>s</mi></msub></mfrac></mstyle></mrow><annotation encoding="application/x-tex">W=\dfrac{T}{T_s}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">W</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.19633em;vertical-align:-0.8360000000000001em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.36033em;"><span style="top:-2.3139999999999996em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">s</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">T</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.8360000000000001em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></li>
<li>平均带权周转时间 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>W</mi><mo>=</mo><mstyle displaystyle="true" scriptlevel="0"><mfrac><mn>1</mn><mi>n</mi></mfrac></mstyle><mo stretchy="false">[</mo><msubsup><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>n</mi></msubsup><mstyle displaystyle="true" scriptlevel="0"><mfrac><msub><mi>T</mi><mi>i</mi></msub><msub><mi>T</mi><mi>s</mi></msub></mfrac></mstyle><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">W=\dfrac{1}{n}[\sum_{i=1}^n\dfrac{T_i}{T_s}]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">W</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.19633em;vertical-align:-0.8360000000000001em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.32144em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal">n</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mopen">[</span><span class="mop"><span class="mop op-symbol small-op" style="position:relative;top:-0.0000050000000000050004em;">∑</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.804292em;"><span style="top:-2.40029em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.2029em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.29971000000000003em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.36033em;"><span style="top:-2.3139999999999996em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">s</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.8360000000000001em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mclose">]</span></span></span></span></li>
</ul>
</li>
<li>
<p>面向系统的准则：系统吞吐量高、处理机利用率好、各类资源的平衡利用</p>
</li>
</ol>
<h2 id="调度算法"><a class="markdownIt-Anchor" href="#调度算法"></a> 调度算法</h2>
<ol>
<li>
<p>先来先服务：适合作业调度和进程调度。有利于长作业，不适合短作业。</p>
</li>
<li>
<p>短作业优先调度：可以用于作业调度和进程调度。对长作业不利，无法保证紧迫性作业。服务时间由用户估计，无法保证真正的短作业优先。</p>
</li>
<li>
<p>高优先权优先调度算法</p>
<ol>
<li>
<p>优先权调度算法类型：非抢占式优先权算法（用于批处理系统、对实时性要求不高的系统）、抢占式优先权调度算法（常用于比较严格的实时系统中，以及对性能要求较高的批处理和分时处理系统中）</p>
</li>
<li>
<p>优先权类型：静态优先权、动态优先权</p>
</li>
<li>
<p>高响应比优先调度算法：</p>
<p><span class='katex-error' title='ParseError: KaTeX parse error: Undefined control sequence: \mbox at position 1: \̲m̲b̲o̲x̲{优先权}=\dfrac{\m…'>\mbox{优先权}=\dfrac{\mbox{等待时间}+\mbox{要求服务时间}}{\mbox{要求服务时间}}=\dfrac{\mbox{响应时间}}{\mbox{要求服务时间}}</span></p>
</li>
</ol>
</li>
<li>
<p>基于时间片的轮转调度算法</p>
<ol>
<li>
<p>时间片轮转法（分时系统）</p>
<p>每个时刻，先把到来的任务插入队尾，然后再把这一时刻执行完的任务放到队尾。</p>
</li>
<li>
<p>多级反馈队列调度算法</p>
<img src="/image/OS/image-20220611203143858.png" alt="image-20220611203143858" style="zoom:50%;" />
<p>设置多个就绪队列，每次时间片到没执行完就放入优先级低的队列（时间片更长）。</p>
<p>仅当前一个队列空闲时，调度程序才调度下一队列的进程运行。</p>
</li>
</ol>
</li>
</ol>
<h2 id="实时调度"><a class="markdownIt-Anchor" href="#实时调度"></a> 实时调度</h2>
<p>实时系统中调度提出某些特殊的要求，前面的算法不能很好满足。</p>
<ol>
<li>
<p>实现实时调度的基本条件</p>
<ol>
<li>系统提供必要信息：就绪时间；开始和完成的截止时间；处理时间；资源要求；优先级。</li>
<li>系统处理能力强：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msubsup><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>m</mi></msubsup><mstyle displaystyle="true" scriptlevel="0"><mfrac><msub><mi>C</mi><mi>i</mi></msub><msub><mi>P</mi><mi>i</mi></msub></mfrac></mstyle><mo>≤</mo><mi>N</mi></mrow><annotation encoding="application/x-tex">\sum_{i=1}^m\dfrac{C_i}{P_i}\le N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:2.19633em;vertical-align:-0.8360000000000001em;"></span><span class="mop"><span class="mop op-symbol small-op" style="position:relative;top:-0.0000050000000000050004em;">∑</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.804292em;"><span style="top:-2.40029em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.2029em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">m</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.29971000000000003em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.36033em;"><span style="top:-2.3139999999999996em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.07153em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.8360000000000001em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span></span>，其中<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>C</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">C_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.07153em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>为处理时间，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>P</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">P_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>为周期时间，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span></span>为处理机数。</li>
<li>采取抢占式调度机制</li>
<li>具有快速切换机制：对外部中断快速响应、快速的任务分派能力</li>
</ol>
</li>
<li>
<p>非抢占式调度算法：非抢占式轮转/优先调度算法</p>
</li>
<li>
<p>抢占式调度算法：基于时钟中断的抢占式优先权调度算法（抢占需等待时钟到来）、立即抢占的优先权调度算法</p>
<img src="/image/OS/image-20220611205410899.png" alt="image-20220611205410899" style="zoom:70%;" />
</li>
</ol>
<h2 id="产生死锁的原因和必要条件"><a class="markdownIt-Anchor" href="#产生死锁的原因和必要条件"></a> 产生死锁的原因和必要条件</h2>
<ol>
<li>
<p>产生死锁的原因：竞争资源、进程间推进顺序非法</p>
</li>
<li>
<p>产生死锁的必要条件</p>
<ul>
<li>互斥条件：某资源只能由一个进程占用，其他进程请求该资源只能等待，直至占有该资源的进程释放</li>
<li>请求和保持条件：进程已经保持了至少一个资源，又提出了新的资源请求，而该资源又被其他进程占有，此时请求进程阻塞但对占有资源不放。</li>
<li>不剥夺条件：进程已获得的资源，在未使用完前不能被剥夺。</li>
<li>环路等待条件：发生死锁时，必然存在一个进程-资源的环形链。</li>
</ul>
<img src="/image/OS/image-20220611211049820.png" alt="image-20220611211049820" style="zoom:50%;" />
</li>
<li>
<p>处理死锁的基本方法</p>
<ol>
<li>预防死锁：设置限制条件去防止，但是可能会导致系统资源利用率和系统吞吐量降低。</li>
<li>避免死锁：资源动态分配过程中，用某种方法防止系统进入不安全状态。实现上有一定难度。</li>
<li>检测死锁：不采用任何措施，在运行过程中发现死锁。</li>
<li>解除死锁：与检测死锁相配套。实施方法：撤销或挂起一些进程回收资源。</li>
</ol>
</li>
</ol>
<h2 id="预防死锁的方法"><a class="markdownIt-Anchor" href="#预防死锁的方法"></a> 预防死锁的方法</h2>
<ol>
<li>
<p>预防死锁</p>
<ol>
<li>摒弃”请求和保持“条件：必须一次性申请整个运行过程中的全部资源。缺点：资源严重浪费、进程延迟运行。</li>
<li>摒弃”不剥夺“条件：当一个已经保持了某些资源的进程，再提出新的资源请求而不能立即得到满足时，必须释放它已经保持了的所有资源，待以后需要时再重新申请。实现起来比较复杂，且要付出很大的代价。</li>
<li>摒弃”环路等待“条件：资源有序分配。</li>
</ol>
</li>
<li>
<p>系统安全状态：安全状态，是指系统能按某种进程顺序(P1，P2，…，Pn)(称〈P1，P2，…，Pn〉序列为安全序列)，来为每个进程Pi分配其所需资源，直至满足每个进程对资源的最大需求，使每个进程都可顺利地完成。如果系统无法找到这样一个安全序列，则称系统处于不安全状态。</p>
<p><strong>不安全不一定死锁，死锁必定不安全</strong>。</p>
</li>
<li>
<p>银行家算法：略</p>
</li>
</ol>
<h2 id="死锁的检测与解除"><a class="markdownIt-Anchor" href="#死锁的检测与解除"></a> 死锁的检测与解除</h2>
<ol>
<li>
<p>死锁的检测：允许死锁发生；保存有关资源的请求和分配信息；提供检测算法。检测时机也很重要。</p>
</li>
<li>
<p>资源分配图：</p>
<img src="/image/OS/image-20220611212934686.png" alt="image-20220611212934686" style="zoom:50%;" />
<p>r1已经将资源分配给P1、P2各一个，P2想要一个r1但尚未满足；P1想要一个r2尚未满足；r2已经将资源分配给P2一个。</p>
</li>
<li>
<p>死锁定理：把资源分配图加以简化的方法，检测系统处于S状态时是否处于死锁状态。</p>
<ol>
<li>找出一个既<strong>不阻塞又非孤立</strong>的进程结点Pi，释放所占有的全部资源</li>
<li>重复释放，最后若能消去所有的边，则说明没有死锁；否则说明存在死锁。</li>
</ol>
</li>
<li>
<p>死锁的解除：</p>
<ol>
<li>
<p>剥夺资源：从其它进程剥夺足够数量的资源给死锁进程，以解除死锁状态。</p>
</li>
<li>
<p>撤销进程：最简单的撤消进程的方法是使全部死锁进程都夭折掉；稍微温和一点的方法是按照某种顺序逐个地撤消进程，直至有足够的资源可用，使死锁状态消除为止。</p>
<p>同样可以采用策略撤销，如撤销进程付出代价最小等。</p>
</li>
</ol>
</li>
</ol>
<h2 id="调度算法小结以及习题"><a class="markdownIt-Anchor" href="#调度算法小结以及习题"></a> 调度算法小结以及习题</h2>
<img src="/image/OS/image-20220611213512833.png" alt="image-20220611213512833" style="zoom:50%;" />
<img src="/image/OS/image-20220611213521570.png" alt="image-20220611213521570" style="zoom:50%;" />
<ol>
<li>
<img src="/image/OS/image-20220611235910274.png" alt="image-20220611235910274" style="zoom:50%;" />
</li>
<li>
<p>为了使作业的平均周转时间最短，应采用(A)算法。</p>
</li>
<li>
<img src="/image/OS/image-20220612000005412.png" alt="image-20220612000005412" style="zoom:50%;" />
</li>
</ol>
<p>答案：1. A(3) B(2) C(4) D(5) 2. A(3) B(1) C(2) D(4) 3. A.短作业优先 4. A(2) B(1)</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="http://aflyingsheep.github.io">Johnson Shuangjian</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://aflyingsheep.github.io/2022/06/07/Review%20notes/OS1/">http://aflyingsheep.github.io/2022/06/07/Review%20notes/OS1/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://aflyingsheep.github.io" target="_blank">AFlyingSheep's Blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Courses/">Courses</a></div><div class="post_share"><div class="social-share" data-image="/image/OS/cover.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://unpkg.com/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://unpkg.com/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2022/06/07/Review%20notes/OS/"><img class="prev-cover" src="/image/OS/cover.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">操作系统（二）</div></div></a></div><div class="next-post pull-right"><a href="/2022/06/07/Review%20notes/CC/"><img class="next-cover" src="/image/CC/cover.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">计算机组成原理</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2022/06/24/Review%20notes/compilation_principle/" title="编译原理"><img class="cover" src="/image/Compile/cover.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-06-24</div><div class="title">编译原理</div></div></a></div><div><a href="/2022/06/20/Review%20notes/computer_networking/" title="计算机网络"><img class="cover" src="/image/ComputerNetwork/cover.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-06-20</div><div class="title">计算机网络</div></div></a></div><div><a href="/2022/06/18/Review%20notes/discrete_math/" title="离散数学"><img class="cover" src="/image/covers/discrete_math.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-06-18</div><div class="title">离散数学</div></div></a></div></div></div><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div class="vcomment" id="vcomment"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/userhead.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Johnson Shuangjian</div><div class="author-info__description">小阳的博客，记录学习、娱乐与日常！</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">40</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">14</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">11</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/aflyingsheep"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="mailto:xxxxxx@gmail.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a><a class="social-icon" href="https://github.com/AFlyingSheep" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:Johnsonshuangjian@gmail.com" target="_blank" title="Outlook"><i class="fas fa-envelope-open-text"></i></a><a class="social-icon" href="tencent://message?uin=398287312" target="_blank" title="QQ"><i class="fab fa-qq"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%BC%95%E8%AE%BA"><span class="toc-number">1.</span> <span class="toc-text"> 操作系统引论</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="toc-number">1.1.</span> <span class="toc-text"> 操作系统的定义</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%8F%91%E5%B1%95%E8%BF%87%E7%A8%8B"><span class="toc-number">1.2.</span> <span class="toc-text"> 操作系统的发展过程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%89%B9%E6%80%A7"><span class="toc-number">1.3.</span> <span class="toc-text"> 操作系统的基本特性</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E4%B8%BB%E8%A6%81%E5%8A%9F%E8%83%BD"><span class="toc-number">1.4.</span> <span class="toc-text"> 操作系统的主要功能</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1"><span class="toc-number">1.5.</span> <span class="toc-text"> 操作系统设计</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B9%A0%E9%A2%98"><span class="toc-number">1.6.</span> <span class="toc-text"> 习题</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86"><span class="toc-number">2.</span> <span class="toc-text"> 进程管理</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-number">2.1.</span> <span class="toc-text"> 进程的基本概念</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E6%8E%A7%E5%88%B6"><span class="toc-number">2.2.</span> <span class="toc-text"> 进程控制</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E5%90%8C%E6%AD%A5"><span class="toc-number">2.3.</span> <span class="toc-text"> 进程同步</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%8F%E5%85%B8%E8%BF%9B%E7%A8%8B%E5%90%8C%E6%AD%A5%E9%97%AE%E9%A2%98"><span class="toc-number">2.4.</span> <span class="toc-text"> 经典进程同步问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E9%80%9A%E4%BF%A1"><span class="toc-number">2.5.</span> <span class="toc-text"> 进程通信</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B"><span class="toc-number">2.6.</span> <span class="toc-text"> 线程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B9%A0%E9%A2%98-2"><span class="toc-number">2.7.</span> <span class="toc-text"> 习题</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%A4%84%E7%90%86%E6%9C%BA%E8%B0%83%E5%BA%A6%E4%B8%8E%E6%AD%BB%E9%94%81"><span class="toc-number">3.</span> <span class="toc-text"> 处理机调度与死锁</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%84%E7%90%86%E6%9C%BA%E8%B0%83%E5%BA%A6%E7%9A%84%E5%B1%82%E6%AC%A1"><span class="toc-number">3.1.</span> <span class="toc-text"> 处理机调度的层次</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B0%83%E5%BA%A6%E9%98%9F%E5%88%97%E6%A8%A1%E5%9E%8B%E5%92%8C%E8%B0%83%E5%BA%A6%E5%87%86%E5%88%99"><span class="toc-number">3.2.</span> <span class="toc-text"> 调度队列模型和调度准则</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95"><span class="toc-number">3.3.</span> <span class="toc-text"> 调度算法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9E%E6%97%B6%E8%B0%83%E5%BA%A6"><span class="toc-number">3.4.</span> <span class="toc-text"> 实时调度</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%A7%E7%94%9F%E6%AD%BB%E9%94%81%E7%9A%84%E5%8E%9F%E5%9B%A0%E5%92%8C%E5%BF%85%E8%A6%81%E6%9D%A1%E4%BB%B6"><span class="toc-number">3.5.</span> <span class="toc-text"> 产生死锁的原因和必要条件</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A2%84%E9%98%B2%E6%AD%BB%E9%94%81%E7%9A%84%E6%96%B9%E6%B3%95"><span class="toc-number">3.6.</span> <span class="toc-text"> 预防死锁的方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%AD%BB%E9%94%81%E7%9A%84%E6%A3%80%E6%B5%8B%E4%B8%8E%E8%A7%A3%E9%99%A4"><span class="toc-number">3.7.</span> <span class="toc-text"> 死锁的检测与解除</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95%E5%B0%8F%E7%BB%93%E4%BB%A5%E5%8F%8A%E4%B9%A0%E9%A2%98"><span class="toc-number">3.8.</span> <span class="toc-text"> 调度算法小结以及习题</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2023/02/10/math/sor/" title="线性方程组的迭代式求解方法"><img src="/image/j_gs_sor/top.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="线性方程组的迭代式求解方法"/></a><div class="content"><a class="title" href="/2023/02/10/math/sor/" title="线性方程组的迭代式求解方法">线性方程组的迭代式求解方法</a><time datetime="2023-02-10T12:22:06.000Z" title="发表于 2023-02-10 20:22:06">2023-02-10</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/01/30/linux/cmake/" title="cmake学习笔记"><img src="/image/cmake/cover.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="cmake学习笔记"/></a><div class="content"><a class="title" href="/2023/01/30/linux/cmake/" title="cmake学习笔记">cmake学习笔记</a><time datetime="2023-01-30T13:27:06.000Z" title="发表于 2023-01-30 21:27:06">2023-01-30</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/01/08/cpp/template_and_static/" title="C++：模板类和静态成员变量"><img src="/image/cpp/cover_2.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="C++：模板类和静态成员变量"/></a><div class="content"><a class="title" href="/2023/01/08/cpp/template_and_static/" title="C++：模板类和静态成员变量">C++：模板类和静态成员变量</a><time datetime="2023-01-08T08:57:06.000Z" title="发表于 2023-01-08 16:57:06">2023-01-08</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/01/05/cpp/%E6%9D%82%E7%83%A9/" title="C++杂谈笔记"><img src="/image/cpp/cover.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="C++杂谈笔记"/></a><div class="content"><a class="title" href="/2023/01/05/cpp/%E6%9D%82%E7%83%A9/" title="C++杂谈笔记">C++杂谈笔记</a><time datetime="2023-01-05T13:27:06.000Z" title="发表于 2023-01-05 21:27:06">2023-01-05</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/12/31/science_research/Codelet/" title="Codelet调度模型与Swdarts"><img src="/image/codelet/1.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Codelet调度模型与Swdarts"/></a><div class="content"><a class="title" href="/2022/12/31/science_research/Codelet/" title="Codelet调度模型与Swdarts">Codelet调度模型与Swdarts</a><time datetime="2022-12-31T10:27:06.000Z" title="发表于 2022-12-31 18:27:06">2022-12-31</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2023 By Johnson Shuangjian</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://unpkg.com/@fancyapps/ui/dist/fancybox.umd.js"></script><script src="https://unpkg.com/node-snackbar/dist/snackbar.min.js"></script><script>var preloader = {
  endLoading: () => {
    document.body.style.overflow = 'auto';
    document.getElementById('loading-box').classList.add("loaded")
  },
  initLoading: () => {
    document.body.style.overflow = '';
    document.getElementById('loading-box').classList.remove("loaded")

  }
}
window.addEventListener('load',preloader.endLoading())</script><div class="js-pjax"><script>if (!window.MathJax) {
  window.MathJax = {
    tex: {
      inlineMath: [ ['$','$'], ["\\(","\\)"]],
      tags: 'ams'
    },
    chtml: {
      scale: 1.2
    },
    options: {
      renderActions: {
        findScript: [10, doc => {
          for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
            const display = !!node.type.match(/; *mode=display/)
            const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display)
            const text = document.createTextNode('')
            node.parentNode.replaceChild(text, node)
            math.start = {node: text, delim: '', n: 0}
            math.end = {node: text, delim: '', n: 0}
            doc.math.push(math)
          }
        }, ''],
        insertScript: [200, () => {
          document.querySelectorAll('mjx-container:not\([display]\)').forEach(node => {
            const target = node.parentNode
            if (target.nodeName.toLowerCase() === 'li') {
              target.parentNode.classList.add('has-jax')
            } else {
              target.classList.add('has-jax')
            }
          });
        }, '', false]
      }
    }
  }
  
  const script = document.createElement('script')
  script.src = 'https://unpkg.com/mathjax/es5/tex-mml-chtml.js'
  script.id = 'MathJax-script'
  script.async = true
  document.head.appendChild(script)
} else {
  MathJax.startup.document.state(0)
  MathJax.texReset()
  MathJax.typeset()
}</script><script>function loadValine () {
  function initValine () {
    const valine = new Valine(Object.assign({
      el: '#vcomment',
      appId: '45rLw57nAW4RPBI6unvz50nc-gzGzoHsz',
      appKey: 'PvsOoxvyj5yqCSzBb7lnWBD8',
      avatar: 'monsterid',
      serverURLs: '',
      emojiMaps: "",
      path: window.location.pathname,
      visitor: false
    }, null))
  }

  if (typeof Valine === 'function') initValine() 
  else getScript('https://unpkg.com/valine/dist/Valine.min.js').then(initValine)
}

if ('Valine' === 'Valine' || !false) {
  if (false) btf.loadComment(document.getElementById('vcomment'),loadValine)
  else setTimeout(loadValine, 0)
} else {
  function loadOtherComment () {
    loadValine()
  }
}</script></div><script defer="defer" id="fluttering_ribbon" mobile="true" src="https://unpkg.com/butterfly-extsrc/dist/canvas-fluttering-ribbon.min.js"></script><script src="https://unpkg.com/butterfly-extsrc/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = false;
POWERMODE.mobile = false;
document.body.addEventListener('input', POWERMODE);
</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"debug":false,"model":{"scale":1,"hHeadPos":0.5,"vHeadPos":0.618,"jsonPath":"/live2dw/assets/koharu.model.json"},"display":{"superSample":2,"width":150,"height":300,"position":"left","hOffset":-5,"vOffset":-5},"mobile":{"show":false,"scale":0.5},"react":{"opacityDefault":0.7,"opacityOnHover":0.2},"log":false});</script></body></html>