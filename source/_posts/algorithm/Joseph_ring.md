---
title: 约瑟夫环问题
date: 2022-05-04 10:59:50
tags:
- Algorithm
categories: 
- Algorithm
description: 基于leetcode-1823. 找出游戏的获胜者，探寻约瑟夫环的解决思路。
top_img: 
cover: /image/covers/yuesefu.png
---

# Leetcode 1823 找出游戏的获胜者

## 题目描述

共有 n 名小伙伴一起做游戏。小伙伴们围成一圈，按 顺时针顺序 从 1 到 n 编号。确切地说，从第 i 名小伙伴顺时针移动一位会到达第 (i+1) 名小伙伴的位置，其中 1 <= i < n ，从第 n 名小伙伴顺时针移动一位会回到第 1 名小伙伴的位置。

游戏遵循如下规则：

1. 从第 1 名小伙伴所在位置 开始 。
2. 沿着顺时针方向数 k 名小伙伴，计数时需要 包含 起始时的那位小伙伴。逐个绕圈进行计数，一些小伙伴可能会被数过不止一次。
3. 你数到的最后一名小伙伴需要离开圈子，并视作输掉游戏。
4. 如果圈子中仍然有不止一名小伙伴，从刚刚输掉的小伙伴的 顺时针下一位 小伙伴 开始，回到步骤 2 继续执行。
5. 否则，圈子中最后一名小伙伴赢得游戏。

给你参与游戏的小伙伴总数 n ，和一个整数 k ，返回游戏的获胜者。



```c++
//输入：
n = 5, k = 2
//输出：
3
/*
解释：游戏运行步骤如下：
1) 从小伙伴 1 开始。
2) 顺时针数 2 名小伙伴，也就是小伙伴 1 和 2 。
3) 小伙伴 2 离开圈子。下一次从小伙伴 3 开始。
4) 顺时针数 2 名小伙伴，也就是小伙伴 3 和 4 。
5) 小伙伴 4 离开圈子。下一次从小伙伴 5 开始。
6) 顺时针数 2 名小伙伴，也就是小伙伴 5 和 1 。
7) 小伙伴 1 离开圈子。下一次从小伙伴 3 开始。
8) 顺时针数 2 名小伙伴，也就是小伙伴 3 和 5 。
9) 小伙伴 5 离开圈子。只剩下小伙伴 3 。所以小伙伴 3 是游戏的获胜者。
*/
```

# 递归公式解决约瑟夫问题

对于模拟过程，用求余可以解决m比n大很多很多的情况(即理论上需要转很多很多圈的情况)。但是还可能存在n本身就很大的情况，无论是顺序表ArrayList还是链表LinkedList去频繁查询、删除都是很低效的。

先给出公式：$f(n,m)=(f(n-1,m)+m)%n$

其中，$f(n,m)$指$n$个人，报第$m$个编号出列最终编号

我们举个例子，有```0 1 2 3 4 5 6 7 8 9```十个数字，假设m为3,最后结果可以先记成f(10,3)，即使我们不知道它是多少。

当进行第一次时候，找到元素2 删除，此时还剩9个元素，但起始位置已经变成元素3。等价成```3 4 5 6 7 8 9 0 1```这9个数字重写开始找。

![f(10,3)删除第一个数](https://pic.leetcode-cn.com/1620465222-bNINmu-file_1620465222660)

此时这个序列最终剩下的一个值即为f(10,3)，这个序列的值和f(9,3)不同，但是都是9个数且m等于3，所以其删除位置是相同的，即算法大体流程是一致的，只是各位置上的数字不一样。所以我们需要做的事情是找找这个序列上和f(9,3)值上有没有什么联系。

寻找过程中别忘记两点，首先可通过**%符号**对数字有效扩充，即我们可以将```3 4 5 6 7 8 9 0 1```这个序列看成```(3,4,5,6,7,8,9,10,11)%10```.这里的10即为此时的n数值。

另外数值如果是连续的，那么最终一个结果的话是可以找到联系的(差值为一个定制)。所以我们可以就找到f(10,3)和f(9,3)值之间结果的关系，可以看下图：

![f(10,3)删除一次和f(9,3)](https://pic.leetcode-cn.com/1620465222-EZkOOc-file_1620465222663)

所以f(10,3)的结果就可以转化为f(9,3)的表达,后面也是同理

```f(10,3)=(f(9,3)+3)%10 f(9,3)=(f(8,3)+3)%9 …… f(2,3)=(f(1,3)+3)%2 f(1,3)=0```

# 代码

```c++
// 如果是从1开始
class Solution {
public:
    int findTheWinner(int n, int k) {
        if (n <= 1) return 1;
        return (k + findTheWinner(n - 1, k) - 1) % n + 1;
    }
};

// 如果是从0开始
class Solution {
    public int findTheWinner(int n, int m) {
         if(n == 1) return 0;      
        return (findTheWinner(n - 1, m) + m) % n;
    }
}
```

参考：[约瑟夫环问题的三种解法讲解 - 力扣（LeetCode） (leetcode-cn.com)](https://leetcode-cn.com/circle/article/BOoxAL/)
