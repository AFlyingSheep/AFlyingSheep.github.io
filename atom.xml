<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>AFlyingSheep&#39;s Blog</title>
  
  <subtitle>Keep coding, keep thinking.</subtitle>
  <link href="http://aflyingsheep.github.io/atom.xml" rel="self"/>
  
  <link href="http://aflyingsheep.github.io/"/>
  <updated>2023-02-27T15:57:36.729Z</updated>
  <id>http://aflyingsheep.github.io/</id>
  
  <author>
    <name>Johnson Shuangjian</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>C++11：引用折叠和完美转发(巨NB)</title>
    <link href="http://aflyingsheep.github.io/2023/02/27/cpp/forward/"/>
    <id>http://aflyingsheep.github.io/2023/02/27/cpp/forward/</id>
    <published>2023-02-27T14:55:06.000Z</published>
    <updated>2023-02-27T15:57:36.729Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="引用折叠"><a class="markdownIt-Anchor" href="#引用折叠"></a> 引用折叠</h1><p><strong>引用</strong>的意思众所周知，当我们使用某个对象的别名的时候就好像直接使用了该对象，这也就是引用的含义。在C++11中，新加入了右值的概念。所以引用的类型就有两种形式：左值引用<code>T&amp;</code>和右值引用<code>T&amp;&amp;</code>。</p><p>所谓的折叠，就是多个的意思。上面介绍引用分为左值引用和右值引用两种，那么将这两种类型进行排列组合，就有四种情况：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- 左值-左值 T&amp; &amp;</span><br><span class="line">- 左值-右值 T&amp; &amp;&amp;</span><br><span class="line">- 右值-左值 T&amp;&amp; &amp;</span><br><span class="line">- 右值-右值 T&amp;&amp; &amp;&amp;</span><br></pre></td></tr></table></figure><p>下面我们介绍引用折叠在模板中的应用：<em>完美转发</em>。在介绍完美转发之前，我们先介绍一下<em>万能引用</em>。</p><h1 id="万能引用"><a class="markdownIt-Anchor" href="#万能引用"></a> 万能引用</h1><p><strong>万能引用</strong>并不是C<ins>的语法特性，而是我们利用现有的C</ins>语法，自己实现的一个功能。因为这个功能既能接受左值类型的参数，也能接受右值类型的参数。所以叫做万能引用。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function">ReturnType <span class="title">Function</span><span class="params">(T&amp;&amp; parem)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 函数功能实现</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来，我们看一下为什么上面这个函数能<strong>万能引用</strong>不同类型的参数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;boost/type_index.hpp&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> boost::typeindex::type_id_with_cvr;  </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PrintType</span><span class="params">(T&amp;&amp; param)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 利用Boost库打印模板推导出来的 T 类型</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;T type：&quot;</span> &lt;&lt; type_id_with_cvr&lt;T&gt;().<span class="built_in">pretty_name</span>() &lt;&lt; endl; </span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 利用Boost库打印形参的类型</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;param type:&quot;</span> &lt;&lt; type_id_with_cvr&lt;<span class="keyword">decltype</span>(param)&gt;().<span class="built_in">pretty_name</span>() &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> a = <span class="number">0</span>;                              <span class="comment">// 左值</span></span><br><span class="line"><span class="built_in">PrintType</span>(a);                           <span class="comment">// 传入左值</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> &amp;lvalue_refence_a = a;              <span class="comment">// 左值引用</span></span><br><span class="line"><span class="built_in">PrintType</span>(lvalue_refence_a);            <span class="comment">// 传入左值引用</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">PrintType</span>(<span class="built_in"><span class="keyword">int</span></span>(<span class="number">2</span>));                      <span class="comment">// 传入右值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>boost库用于看到模板内参数类型。</p><p>通过上面的代码可以清楚的看到，<code>void PrintType(T&amp;&amp; param)</code>可以接受任何类型的参数。下面，我们来仔细观察并分析一下<code>main</code>函数中对<code>PrintType()</code>的各个调用结果。</p><ol><li>传入左值</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">0</span>;                              <span class="comment">// 左值</span></span><br><span class="line"><span class="built_in">PrintType</span>(a);                           <span class="comment">// 传入左值</span></span><br><span class="line"><span class="comment">/***************************************************/</span></span><br><span class="line">输出：T type      : <span class="keyword">int</span> &amp;</span><br><span class="line">      param type  : <span class="keyword">int</span> &amp;</span><br></pre></td></tr></table></figure><p>我们将T的推导类型<code>int&amp;</code>带入模板，得到实例化的类型：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PrintType</span><span class="params">(<span class="keyword">int</span>&amp; &amp;&amp; param)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注：所有的引用折叠最终都代表一个引用，要么是左值引用，要么是右值引用。规则就是：如果任一引用为左值引用，则结果为左值引用。否则（即两个都是右值引用），结果为右值引用。</p><p><strong>编译器将T推导为 int&amp; 类型。当我们用 int&amp; 替换掉 T 后，得到 int &amp; &amp;&amp;。也就是说，<code>int&amp; &amp;&amp;</code>等价于<code>int &amp;</code>。<code>void PrintType(int&amp; &amp;&amp; param)</code> == <code>void PrintType(int&amp; param)</code></strong></p><p>所以传入右值之后，函数模板推导的最终版本就是：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PrintType</span><span class="params">(<span class="keyword">int</span>&amp; param)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>剩下的几个调用结果就很明显了：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> &amp;lvalue_refence_a = a;              <span class="comment">//左值引用</span></span><br><span class="line"><span class="built_in">PrintType</span>(lvalue_refence_a);            <span class="comment">// 传入左值引用</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * T type      : int &amp;</span></span><br><span class="line"><span class="comment"> * T &amp;&amp;        : int &amp; &amp;&amp;</span></span><br><span class="line"><span class="comment"> * param type  : int &amp;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">PrintType</span>(<span class="built_in"><span class="keyword">int</span></span>(<span class="number">2</span>));                      <span class="comment">// 传入右值</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * T type      : int</span></span><br><span class="line"><span class="comment"> * T &amp;&amp;        : int &amp;&amp;</span></span><br><span class="line"><span class="comment"> * param type  : int &amp;&amp;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h1 id="完美转发"><a class="markdownIt-Anchor" href="#完美转发"></a> 完美转发</h1><p>有了万能引用。当我们既需要接收左值类型，又需要接收右值类型的时候，再也不用分开写两个重载函数了。那么，什么情况下，我们需要一个函数，既能接收左值，又能接收右值呢？</p><p>答案就是：转发的时候。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 万能引用，转发接收到的参数 param</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PrintType</span><span class="params">(T&amp;&amp; param)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">f</span>(param);  <span class="comment">// 将参数param转发给函数 void f()</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 接收左值的函数 f()</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(T &amp;)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;f(T &amp;)&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 接收右值的函数f()</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(T &amp;&amp;)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;f(T &amp;&amp;)&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> a = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">PrintType</span>(a);<span class="comment">//传入左值</span></span><br><span class="line"><span class="built_in">PrintType</span>(<span class="built_in"><span class="keyword">int</span></span>(<span class="number">0</span>));<span class="comment">//传入右值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们执行上面的代码，按照预想，在main中我们给 PrintType 分别传入一个左值和一个右值。PrintType将参数转发给 f() 函数。f()有两个重载，分别接收左值和右值。</p><p>正常的情况下,<code>PrintType(a);</code>应该打印<code>f(T&amp;)</code>,<code>PrintType(int());</code>应该打印<code>f(T&amp;&amp;)</code>。</p><p><strong>但是</strong>，真实的输出结果是</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">f</span>(T &amp;);</span><br><span class="line"><span class="built_in">f</span>(T &amp;);</span><br></pre></td></tr></table></figure><p><strong>当外部传入参数给 PrintType 函数时，param既可以被初始化为左值引用，也可以被初始化为右值引用，取决于我们传递给 PrintType 函数的实参类型。但是，当我们在函数 PrintType 内部，将param传递给另一个函数的时候，此时，param是被当作左值进行传递的。</strong> <em>应为这里的 param 是个具名的对象。我们不进行详细的探讨了。大家只需要己住，任何的函数内部，对形参的直接使用，都是按照左值进行的。</em></p><p><strong>我们可以通过一些其它的手段改变这个情况，比如使用 std::forward 。</strong></p><p>使用万能引用的时候，如果传入的实参是个<strong>右值(包括右值引用)</strong>，那么，<strong>模板类型 T 被推导为 实参的类型（没有引用属性）</strong>，如果传入实参是个左值，T被推导为左值引用。<strong>也就是说，模板中的 T 保存着传递进来的实参的信息，我们可以利用 T 的信息来强制类型转换我们的 param 使它和实参的类型一致。</strong></p><p>具体的做法就是，将模板函数<code>void PrintType(T&amp;&amp; param)</code>中对<code>f(param)</code>的调用，改为<code>f(std::forward&lt;T&gt;(param));</code>然后重新运行一下程序。输出如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">f</span>(T &amp;);</span><br><span class="line"><span class="built_in">f</span>(T &amp;&amp;);</span><br></pre></td></tr></table></figure><h2 id="完美转发原理"><a class="markdownIt-Anchor" href="#完美转发原理"></a> 完美转发原理</h2><p><code>std::forward</code>是怎么利用到 T 的信息的呢？</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *  精简了标准库的代码，在细节上可能不完全正确，但是足以让我们了解转发函数 forward 的了</span></span><br><span class="line"><span class="comment"> */</span> </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function">T&amp;&amp; <span class="title">forward</span><span class="params">(T &amp;param)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">static_cast</span>&lt;T&amp;&amp;&gt;(param);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>我们可以看到，不管T是值类型，还是左值引用，还是右值引用，T&amp;经过引用折叠，都将是左值引用类型。也就是forward 以左值引用的形式接收参数 param, 然后 通过将param进行强制类型转换 static_cast&lt;T&amp;&amp;&gt; （），最终再以一个 T&amp;&amp;返回</strong></p><ol><li><p>传入 PrintType 实参是右值类型：</p><p>根据以上的分析，可以知道T将被推导为值类型，也就是不带有引用属性，假设为 int 。那么，将T = int 带入forward。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span>&amp;&amp; <span class="title">forward</span><span class="params">(<span class="keyword">int</span> &amp;param)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&amp;&amp;&gt;(param);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>param</code>在forward内被强制类型转换为 int &amp;&amp;<em>(static_cast&lt;int&amp;&amp;&gt;(param))</em>, 然后按照int &amp;&amp; 返回，两个右值引用最终还是右值引用。最终保持了实参的右值属性，转发正确。</p></li><li><p>传入 PrintType 实参是左值类型：</p><p>根据以上的分析，可以知道T将被推导为左值引用类型，假设为int&amp;。那么，将T = int&amp; 带入forward。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span>&amp; &amp;&amp; <span class="title">forward</span><span class="params">(<span class="keyword">int</span>&amp; &amp;param)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&amp; &amp;&amp;&gt;(param);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>引用折叠一下就是：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span>&amp; <span class="title">forward</span><span class="params">(<span class="keyword">int</span>&amp; param)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&amp;&gt;(param);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>传递给 PrintType 左值，forward返回一个左值引用，保留了实参的左值属性，转发正确。</p></li></ol>]]></content>
    
    
    <summary type="html">引用折叠、万能引用和完美转发，摘录自知乎ReFantasy。</summary>
    
    
    
    <category term="CS" scheme="http://aflyingsheep.github.io/categories/CS/"/>
    
    
    <category term="CS" scheme="http://aflyingsheep.github.io/tags/CS/"/>
    
    <category term="C/C++" scheme="http://aflyingsheep.github.io/tags/C-C/"/>
    
  </entry>
  
  <entry>
    <title>C++11：新特性</title>
    <link href="http://aflyingsheep.github.io/2023/02/27/cpp/cpp11/"/>
    <id>http://aflyingsheep.github.io/2023/02/27/cpp/cpp11/</id>
    <published>2023-02-27T07:55:06.000Z</published>
    <updated>2023-02-27T15:59:13.277Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="auto-decltype"><a class="markdownIt-Anchor" href="#auto-decltype"></a> auto &amp; decltype</h1><ul><li>auto：让编译器在编译器就推导出变量的类型，可以通过=右边的类型推导出变量的类型。</li><li>decltype：相对于auto用于推导变量类型，而decltype则用于推导表达式类型，这里只用于编译器分析表达式的类型，表达式实际不会进行运算。</li></ul><ol><li><p>auto的限制：</p><ol><li>auto的使用必须马上初始化，否则无法推导出类型</li><li>auto在一行定义多个变量时，各个变量的推导不能产生二义性，否则编译失败</li><li>auto不能用作函数参数</li><li>在类中auto不能用作非静态成员变量</li><li>auto不能定义数组，可以定义指针</li><li>auto无法推导出模板参数</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">auto</span> a = i, &amp;b = i, *c = &amp;i; <span class="comment">// a是int，b是i的引用，c是i的指针，auto就相当于int</span></span><br><span class="line"><span class="keyword">auto</span> d = <span class="number">0</span>, f = <span class="number">1.0</span>; <span class="comment">// error，0和1.0类型不同，对于编译器有二义性，没法推导</span></span><br><span class="line"><span class="keyword">auto</span> e; <span class="comment">// error，使用auto必须马上初始化，否则无法推导类型</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">auto</span> value)</span> </span>&#123;&#125; <span class="comment">// error，auto不能用作函数参数</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line">    <span class="keyword">auto</span> a = <span class="number">1</span>; <span class="comment">// error，在类中auto不能用作非静态成员变量</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">auto</span> b = <span class="number">1</span>; <span class="comment">// error，这里与auto无关，正常static int b = 1也不可以</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">auto</span> c = <span class="number">1</span>; <span class="comment">// ok</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a[<span class="number">10</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">auto</span> b = a; <span class="comment">// ok</span></span><br><span class="line">    <span class="keyword">auto</span> c[<span class="number">10</span>] = a; <span class="comment">// error，auto不能定义数组，可以定义指针</span></span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; d;</span><br><span class="line">    vector&lt;<span class="keyword">auto</span>&gt; f = d; <span class="comment">// error，auto无法推导出模板参数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>auto与const, volatile</p><ol><li>在不声明为引用或指针时，auto会忽略等号右边的引用类型和cv限定</li><li>在声明为引用或者指针时，auto会保留等号右边的引用和cv属性</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">auto</span> *a = &amp;i; <span class="comment">// a是int*</span></span><br><span class="line"><span class="keyword">auto</span> &amp;b = i; <span class="comment">// b是int&amp;</span></span><br><span class="line"><span class="keyword">auto</span> c = b; <span class="comment">// c是int，忽略了引用</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">auto</span> d = i; <span class="comment">// d是const int</span></span><br><span class="line"><span class="keyword">auto</span> e = d; <span class="comment">// e是int</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">auto</span>&amp; f = e; <span class="comment">// f是const int&amp;</span></span><br><span class="line"><span class="keyword">auto</span> &amp;g = f; <span class="comment">// g是const int&amp;</span></span><br></pre></td></tr></table></figure></li><li><p>decltype: decltype则用于推导表达式类型，这里只用于编译器分析表达式的类型，表达式实际不会进行运算</p><p>若exp是左值，decltype(exp)是exp类型的左值引用。</p><p>如: <code>decltype(a += b) d = c</code>中的d即为int&amp;, 因为<code>a += b</code>是一个左值。</p></li><li><p>auto和decltype的配合使用</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> U&gt;</span></span><br><span class="line"><span class="function">return_value <span class="title">add</span><span class="params">(T t, U u)</span> </span>&#123;<span class="comment">// t和v类型不确定，无法推导出return_value类型</span></span><br><span class="line">    <span class="keyword">return</span> t + u;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> U&gt;</span></span><br><span class="line"><span class="function"><span class="title">decltype</span><span class="params">(t + u)</span> <span class="title">add</span><span class="params">(T t, U u)</span> </span>&#123; <span class="comment">// t和u尚未定义</span></span><br><span class="line">    <span class="keyword">return</span> t + u;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回类型后置的配合使用方法，为了解决函数返回值类型依赖于参数却难以确定返回值类型的问题</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> U&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">add</span><span class="params">(T t, U u)</span> -&gt; <span class="title">decltype</span><span class="params">(t + u)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> t + u;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h1 id="左值引用-右值引用-移动语义-完美转发"><a class="markdownIt-Anchor" href="#左值引用-右值引用-移动语义-完美转发"></a> 左值引用、右值引用、移动语义、完美转发</h1><p><a href="https://zhuanlan.zhihu.com/p/137662465">左值引用、右值引用、移动语义、完美转发，你知道的不知道的都在这里 - 知乎 (zhihu.com)</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 右值引用</span></span><br><span class="line"><span class="keyword">int</span> a = <span class="number">4</span>;</span><br><span class="line"><span class="keyword">int</span> &amp;&amp;b = a;<span class="comment">// error! a是左值</span></span><br><span class="line"><span class="keyword">int</span> &amp;&amp;c = std::<span class="built_in">move</span>(a);<span class="comment">// ok</span></span><br></pre></td></tr></table></figure><ol><li><p>移动语义：转移所有权，对于别人的一块资源转为自己拥有，别人不再拥有也不再使用。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 移动方法：移动构造函数</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">A</span>(A&amp;&amp; a) &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;data_ = a.data_;</span><br><span class="line">        a.data_ = <span class="literal">nullptr</span>;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;move&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> *data_;</span><br><span class="line">    <span class="keyword">int</span> size_;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// main</span></span><br><span class="line"><span class="function">A <span class="title">a</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line">A b = a;<span class="comment">// 浅拷贝</span></span><br><span class="line">A c = std::<span class="built_in">move</span>(a);<span class="comment">// 调用移动构造函数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// C++所有的STL都实现了移动语义；</span></span><br><span class="line"><span class="comment">// 移动语义仅针对于那些实现了移动构造函数的类的对象，对于那种基本类型int、float等没有任何优化作用，还是会拷贝，因为它们实现没有对应的移动构造函数。</span></span><br></pre></td></tr></table></figure></li><li><p>完美转发：可以写一个接受任意实参的函数模板，并转发到其它函数，目标函数会收到与转发函数完全相同的实参，转发函数实参是左值那目标函数实参也是左值，转发函数实参是右值那目标函数实参也是右值。</p></li></ol>]]></content>
    
    
    <summary type="html">C++11新特性。</summary>
    
    
    
    <category term="CS" scheme="http://aflyingsheep.github.io/categories/CS/"/>
    
    
    <category term="CS" scheme="http://aflyingsheep.github.io/tags/CS/"/>
    
    <category term="C/C++" scheme="http://aflyingsheep.github.io/tags/C-C/"/>
    
  </entry>
  
  <entry>
    <title>C++函数指针</title>
    <link href="http://aflyingsheep.github.io/2023/02/27/cpp/function_pointer/"/>
    <id>http://aflyingsheep.github.io/2023/02/27/cpp/function_pointer/</id>
    <published>2023-02-27T05:46:08.000Z</published>
    <updated>2023-02-27T06:07:14.808Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>函数指针是指指向函数而非指向对象的指针。像其他指针一样，函数指针也指向某个特定的类型。函数类型由其返回类型以及形参表确定， 而与函数名无关：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// pf points to function returning bool that takes two const string references</span></span><br><span class="line"><span class="built_in"><span class="keyword">bool</span></span> (*pf)(<span class="keyword">const</span> string &amp;, <span class="keyword">const</span> string &amp;);</span><br></pre></td></tr></table></figure><p>这个语句将 pf 声明为指向函数的指针，它所指向的函数带有两个 const string&amp; 类型的形参和 bool 类型的返回值。</p><p>*pf 两侧的圆括号是必需的：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// declares a function named pf that returns a bool*</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> *<span class="title">pf</span><span class="params">(<span class="keyword">const</span> string &amp;, <span class="keyword">const</span> string &amp;)</span></span>;</span><br></pre></td></tr></table></figure><h2 id="用-typedef-简化函数指针的定义"><a class="markdownIt-Anchor" href="#用-typedef-简化函数指针的定义"></a> 用 typedef 简化函数指针的定义</h2><p>函数指针类型相当地冗长。使用 typedef 为指针类型定义同义词，可将函数指针的使用大大简化：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">bool</span> <span class="params">(*cmpFcn)</span><span class="params">(<span class="keyword">const</span> string &amp;, <span class="keyword">const</span> string &amp;)</span></span>;</span><br></pre></td></tr></table></figure><p>该定义表示 cmpFcn 是一种指向函数的指针类型的名字。该指针类型为“指向返回 bool 类型并带有两个 const string 引用形参的函数的指针”。在要使用这种函数指针类型时，只需直接使用 cmpFcn 即可，不必每次都把整个类型声明全部写出来。</p><h2 id="指向函数的指针的初始化和赋值"><a class="markdownIt-Anchor" href="#指向函数的指针的初始化和赋值"></a> 指向函数的指针的初始化和赋值</h2><p>在引用函数名但又没有调用该函数时，函数名将被自动解释为指向函数的指针。假设有函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// compares lengths of two strings</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">lengthCompare</span><span class="params">(<span class="keyword">const</span> string &amp;, <span class="keyword">const</span> string &amp;)</span></span>;</span><br></pre></td></tr></table></figure><p>除了用作函数调用的左操作数以外，对 lengthCompare 的任何使用都被解释为如下类型的指针：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in"><span class="keyword">bool</span></span> (*)(<span class="keyword">const</span> string &amp;, <span class="keyword">const</span> string &amp;);</span><br></pre></td></tr></table></figure><p>此时，直接引用函数名等效于在函数名上应用取地址操作符：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cmpFcn pf1 = lengthCompare;</span><br><span class="line">cmpFcn pf2 = &amp;lengthCompare;</span><br></pre></td></tr></table></figure><p>函数指针只能通过同类型的函数或函数指针或 0 值常量表达式进行初始化或赋值。</p><p>将函数指针初始化为 0，表示该指针不指向任何函数。</p><p>指向不同函数类型的指针之间不存在转换。</p><h2 id="通过指针调用函数"><a class="markdownIt-Anchor" href="#通过指针调用函数"></a> 通过指针调用函数</h2><p>指向函数的指针可用于调用它所指向的函数。可以不需要使用解引用操作符，直接通过指针调用函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cmpFcn pf = lengthCompare;</span><br><span class="line"><span class="built_in">lengthCompare</span>(<span class="string">&quot;hi&quot;</span>, <span class="string">&quot;bye&quot;</span>); <span class="comment">// direct call</span></span><br><span class="line"><span class="built_in">pf</span>(<span class="string">&quot;hi&quot;</span>, <span class="string">&quot;bye&quot;</span>); <span class="comment">// equivalent call: pf1 implicitly dereferenced</span></span><br><span class="line">(*pf)(<span class="string">&quot;hi&quot;</span>, <span class="string">&quot;bye&quot;</span>); <span class="comment">// equivalent call: pf1 explicitly dereferenced</span></span><br></pre></td></tr></table></figure><p>如果指向函数的指针没有初始化，或者具有 0 值，则该指针不能在函数调用中使用。只有当指针已经初始化，或被赋值为指向某个函数，方能安全地用来调用函数。</p><h2 id="函数指针的形参"><a class="markdownIt-Anchor" href="#函数指针的形参"></a> 函数指针的形参</h2><p>函数的形参可以是指向函数的指针。这种形参可以用以下两种形式编写：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">useBigger</span><span class="params">(<span class="keyword">const</span> string &amp;, <span class="keyword">const</span> string &amp;,<span class="keyword">bool</span>(<span class="keyword">const</span> string &amp;, <span class="keyword">const</span> string &amp;))</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">useBigger</span><span class="params">(<span class="keyword">const</span> string &amp;, <span class="keyword">const</span> string &amp;,<span class="keyword">bool</span> (*)(<span class="keyword">const</span> string &amp;, <span class="keyword">const</span> string &amp;))</span></span>;</span><br></pre></td></tr></table></figure><h2 id="返回指向函数的指针"><a class="markdownIt-Anchor" href="#返回指向函数的指针"></a> 返回指向函数的指针</h2><p>函数可以返回指向函数的指针，但是，正确写出这种返回类型相当不容易：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in"><span class="keyword">int</span></span> (*<span class="built_in">ff</span>(<span class="keyword">int</span>))(<span class="keyword">int</span>*, <span class="keyword">int</span>);</span><br></pre></td></tr></table></figure><p>它是一个指向函数的指针，所指向的函数返回 int 型并带有两个分别是int* 型和 int 型的形参。</p><p>使用 typedef 可使该定义更简明易懂：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">int</span> <span class="params">(*PF)</span><span class="params">(<span class="keyword">int</span>*, <span class="keyword">int</span>)</span></span>;</span><br><span class="line"><span class="function">PF <span class="title">ff</span><span class="params">(<span class="keyword">int</span>)</span></span>; <span class="comment">// ff returns a pointer to function</span></span><br></pre></td></tr></table></figure><p>允许将形参定义为函数类型，但函数的返回类型则必须是指向函数的指针，而不能是函数。</p><p>具有函数类型的形参所对应的实参将被自动转换为指向相应函数类型的指针。但是，当返回的是函数时，同样的转换操作则无法实现：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// func is a function type, not a pointer to function!</span></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="keyword">int</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span>*, <span class="keyword">int</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f1</span><span class="params">(func)</span></span>; <span class="comment">// ok: f1 has a parameter of function type</span></span><br><span class="line"><span class="function">func <span class="title">f2</span><span class="params">(<span class="keyword">int</span>)</span></span>; <span class="comment">// error: f2 has a return type of function type</span></span><br><span class="line"><span class="function">func *<span class="title">f3</span><span class="params">(<span class="keyword">int</span>)</span></span>; <span class="comment">// ok: f3 returns a pointer to function type</span></span><br></pre></td></tr></table></figure><h2 id="指向重载函数的指针"><a class="markdownIt-Anchor" href="#指向重载函数的指针"></a> 指向重载函数的指针</h2><p>C++ 语言允许使用函数指针指向重载的函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">void</span> <span class="title">ff</span><span class="params">(vector&lt;<span class="keyword">double</span>&gt;)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">void</span> <span class="title">ff</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span>)</span></span>;</span><br></pre></td></tr></table></figure><p>指针的类型必须与重载函数的一个版本精确匹配。如果没有精确匹配的函数，则对该指针的初始化或赋值都将导致编译错误：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// error: no match: invalid parameter list</span></span><br><span class="line"><span class="built_in"><span class="keyword">void</span></span> (*pf2)(<span class="keyword">int</span>) = &amp;ff;</span><br><span class="line"><span class="comment">// error: no match: invalid return type</span></span><br><span class="line"><span class="built_in"><span class="keyword">double</span></span> (*pf3)(vector&lt;<span class="keyword">double</span>&gt;);</span><br><span class="line">pf3 = &amp;ff;</span><br></pre></td></tr></table></figure><h2 id="decltype用于函数指针类型"><a class="markdownIt-Anchor" href="#decltype用于函数指针类型"></a> decltype用于函数指针类型</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">string::size_type <span class="title">sumLength</span><span class="params">(<span class="keyword">const</span> string&amp;,<span class="keyword">const</span> string&amp;)</span></span>;</span><br><span class="line"><span class="keyword">decltype</span>(sumLength) *<span class="built_in">getFcn</span>(<span class="keyword">const</span> string&amp;)</span><br></pre></td></tr></table></figure><p>使用decltype得到的是某个函数类型而非指针类型，因此需要显示的加上指针。</p>]]></content>
    
    
    <summary type="html">函数指针是指指向函数而非指向对象的指针。像其他指针一样，函数指针也指向某个特定的类型。函数类型由其返回类型以及形参表确定,而与函数名无关.</summary>
    
    
    
    <category term="CS" scheme="http://aflyingsheep.github.io/categories/CS/"/>
    
    
    <category term="CS" scheme="http://aflyingsheep.github.io/tags/CS/"/>
    
    <category term="C/C++" scheme="http://aflyingsheep.github.io/tags/C-C/"/>
    
  </entry>
  
  <entry>
    <title>C++ Primer</title>
    <link href="http://aflyingsheep.github.io/2023/02/24/cpp/cpp_primer/"/>
    <id>http://aflyingsheep.github.io/2023/02/24/cpp/cpp_primer/</id>
    <published>2023-02-24T13:22:06.000Z</published>
    <updated>2023-02-27T07:44:46.903Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="顺序容器"><a class="markdownIt-Anchor" href="#顺序容器"></a> 顺序容器</h1><ol><li><p>容器的元素类型必须满足以下两个约束：元素类型必须支持赋值运算、元素类型的对象必须可以复制。</p></li><li><p>不要存储end操作返回的迭代器。添加或删除deque或vector容器内的元素都会导致存储的迭代器失效。</p></li><li><p>vector提供了两个类成员函数: capacity和reserve。capacity用于获取容器需要分配更多的储存空间之前能够存储的元素总数；reserve操作告诉vector容器应该预留多少个元素的储存空间。</p></li><li><p>deque提供更复杂的数据结构，从队列两端插入和删除非常快，在中间操作代价更高。</p><p>deque支持对所有元素的随机访问。</p><p>deque在首尾插入元素不会使迭代器失效，在首位删除或在中间插入删除都会使迭代器失效。</p></li><li><p>适配器：</p><ol><li>默认的stack和queue基于deque容器实现，priority_queue在vector容器上实现。</li><li>stack可以建立在vector, list, deque容器上；queue只能建立在list上，不能建立在vector上(要提供push_front运算)；priority_queue可以建立在vector, deque上，不能建立在list上(要提供随机访问)。</li><li>优先队列：允许用户为队列中存储的元素设置优先级</li></ol></li></ol><h1 id="关联容器"><a class="markdownIt-Anchor" href="#关联容器"></a> 关联容器</h1><ol><li><p>标准库定义了make_pair函数，由传递给它的两个实参生成一个新的pair对象</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">pair&lt;string, string&gt; next_auth;</span><br><span class="line">string first, second;</span><br><span class="line"><span class="keyword">while</span> (cin &gt;&gt; first &gt;&gt; second) &#123;</span><br><span class="line">    next_auth = <span class="built_in">make_pair</span>(first, second);</span><br><span class="line">    <span class="comment">// process pair</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>关联容器的键不但有一个类型，还有一个比较函数，默认情况下为键类型定义的 &lt; 操作符实现比较。</p></li><li><p>map.insert(e)返回pair&lt;map&lt;&gt;::iterator, bool&gt;, 如果键已在map中则关联值保持不变，返回的迭代器指向该pair并返回false；如果不在则插入新元素并返回迭代器和true；</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// insert重写单词统计</span></span><br><span class="line">map&lt;string, <span class="keyword">int</span>&gt; word_count;</span><br><span class="line">string word;</span><br><span class="line"><span class="keyword">while</span> (cin&gt;&gt; word) &#123;</span><br><span class="line">    pair&lt;map&lt;string, <span class="keyword">int</span>&gt;::iterator, <span class="keyword">bool</span>&gt; ret = word_count.<span class="built_in">insert</span>(make_pair&lt;word, <span class="number">1</span>&gt;);</span><br><span class="line">    <span class="keyword">if</span> (!ret.second) &#123;</span><br><span class="line">        ++ret.first-&gt;second;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>set.insert(e)同样返回pair&lt;set&lt;&gt;::iterator, bool&gt;，与map类似，bool表示是否存在，迭代器指向插入或存在的值。</p></li><li><p>在multimap与multiset中查找元素，可以在同一个键上调用<code>lower_bound, upper_bound</code>，分别返回该键关联的第一个元素与最后一个元素的下一位置。如果不存在，则<code>lower_bound == upper_bound</code>并且指向应该插入的位置。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 查找作者写的所有的书</span></span><br><span class="line"><span class="function">string <span class="title">search_item</span><span class="params">(<span class="string">&quot;Tom&quot;</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">authors_it begin = authors.<span class="built_in">lower_bound</span>(search_item),</span><br><span class="line">end = authors.<span class="built_in">upper_bound</span>(search_item);</span><br><span class="line"><span class="keyword">while</span> (begin != end) &#123;</span><br><span class="line">    std::cout &lt;&lt; begin.second &lt;&lt; std::endl;</span><br><span class="line">    ++begin;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>更直接的，可以直接调用equal_range函数取代以上两个函数，返回一对迭代器的pair对象。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 查找作者写的所有的书</span></span><br><span class="line"><span class="function">string <span class="title">search_item</span><span class="params">(<span class="string">&quot;Tom&quot;</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">pair&lt;authors_it, authors_it&gt; pos = authors.<span class="built_in">equal_range</span>(search_item);</span><br><span class="line"><span class="keyword">while</span> (pos.first != pos.second) &#123;</span><br><span class="line">    std::cout &lt;&lt; pos.second &lt;&lt; std::endl;</span><br><span class="line">    ++pos.first;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h1 id="类"><a class="markdownIt-Anchor" href="#类"></a> 类</h1><h2 id="初始化表"><a class="markdownIt-Anchor" href="#初始化表"></a> 初始化表</h2><ol><li>必须对任何const或引用类型成员以及没有默认构造函数的类类型的任何成员使用初始化式。</li><li>成员被初始化的顺序是定义成员的次序，而不是初始化表的顺序。</li></ol><h2 id="隐式类型转换"><a class="markdownIt-Anchor" href="#隐式类型转换"></a> 隐式类型转换</h2><ol><li>将构造函数声明为explicit，防止需要隐式转换的上下文中使用构造函数。</li></ol><h2 id="static类成员"><a class="markdownIt-Anchor" href="#static类成员"></a> static类成员</h2><h2 id="类类型对象"><a class="markdownIt-Anchor" href="#类类型对象"></a> 类类型对象</h2><p>在 C++ 中，我们可以使用类名后加上一对括号来创建一个类的对象，同时可以使用类名和作用域解析运算符（<code>::</code>）来访问类的静态成员和静态函数。然而，当我们使用类名后加上一对括号时，编译器无法确定我们是要创建一个类的对象还是访问类的类型对象。因此，为了区分类对象和类类型对象，我们需要在类名后面添加关键字<code>class</code>。</p><p>例如，假设我们有以下的 C++ 代码，其中定义了一个名为<code>MyClass</code>的类和一个类类型对象<code>myClassObj</code>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> count;</span><br><span class="line">    <span class="built_in">MyClass</span>() &#123;</span><br><span class="line">        count++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> MyClass::count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    MyClass obj1;</span><br><span class="line">    MyClass::count = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// create a class object</span></span><br><span class="line">    MyClass obj2;</span><br><span class="line">    obj2.x = <span class="number">42</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// create a class type object</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> <span class="title">myClassObj</span>;</span></span><br><span class="line">    myClassObj.count = <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;obj1.count = &quot;</span> &lt;&lt; obj1.count &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;obj2.x = &quot;</span> &lt;&lt; obj2.x &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;myClassObj.count = &quot;</span> &lt;&lt; myClassObj.count &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面的示例中，我们在创建类类型对象<code>myClassObj</code>时，在类名<code>MyClass</code>前面加上了关键字<code>class</code>。这样，编译器就可以确定我们要创建一个表示<code>MyClass</code>类本身的对象。</p><p>使用关键字<code>class</code>声明类类型对象是一种好习惯，可以让代码更加清晰明了。另外，需要注意的是，关键字<code>class</code>只在初始化类类型对象时需要使用，在访问类的静态成员和静态函数时不需要使用。</p><h1 id="复制控制"><a class="markdownIt-Anchor" href="#复制控制"></a> 复制控制</h1><h2 id="复制构造函数"><a class="markdownIt-Anchor" href="#复制构造函数"></a> 复制构造函数</h2><ol><li><p>复制构造函数：只有单个形参，且形参是本类类型对象的引用。</p></li><li><p>C++支持两种初始化形式：直接初始化(将初始化式放在括号内，调用实参匹配的构造函数)、复制初始化(用&quot;=&quot;符号，调用复制构造函数)。复制构造函数首先使用指定构造函数创建一个临时对象，然后用复制构造函数将临时对象复制到正在创建的对象。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 构造函数初始化举例</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> std::string;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Sales_item</span> &#123;</span></span><br><span class="line">string x;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Sales_item</span>(string input) : <span class="built_in">x</span>(input) &#123;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;构造函数被调用&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">Sales_item</span>(<span class="keyword">const</span> Sales_item&amp; other) &#123;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;复制构造函数被调用&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">x = other.x;</span><br><span class="line">&#125;</span><br><span class="line">&#125;; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//std::pair &lt;int, double&gt; p;</span></span><br><span class="line"><span class="comment">//p = std::make_pair(1.2, 1);</span></span><br><span class="line"><span class="comment">//std::cout &lt;&lt; p.first &lt;&lt; std::endl &lt;&lt; p.second;</span></span><br><span class="line">string s = <span class="string">&quot;000&quot;</span>;</span><br><span class="line"><span class="comment">// Sales_item si(s);</span></span><br><span class="line">Sales_item si = <span class="built_in">string</span>(<span class="string">&quot;000&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">输出结果：</span></span><br><span class="line"><span class="comment">构造函数被调用</span></span><br><span class="line"><span class="comment">复制构造函数被调用</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>注：如果构造函数是explicit，则<code>Sales_item si = string(&quot;000&quot;);</code>失效。</p></li><li><p>复制构造函数是接受单个类类型引用形参(通常const)修饰的构造函数，一般不应设置为<code>explicit</code>。为了防止复制，类必须显式声明其复制构造函数为<code>private</code>。为防止友元和成员进行复制，可以声明一个<code>private</code>的复制构造函数但不定义，这样任何使用未定义的成员的任何尝试都会导致链接失败，编译时便会出错。</p></li></ol><h2 id="赋值操作符"><a class="markdownIt-Anchor" href="#赋值操作符"></a> 赋值操作符</h2><ol><li><p>赋值操作符声明可以为：（右操作数一般作为const引用传递）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Sales_item</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Sales_item&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> Sales_item&amp;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol><h1 id="重载操作符"><a class="markdownIt-Anchor" href="#重载操作符"></a> 重载操作符</h1><ol><li>操作符定义为非成员函数时，通常必须将它们设置为所操作类的友元，以访问类的私有部分。</li></ol><h2 id="重载操作符设计"><a class="markdownIt-Anchor" href="#重载操作符设计"></a> 重载操作符设计</h2><ol><li>不要重置具有内置含义的操作符：重载逗号、取地址、逻辑与或等都不是好做法，这些操作符有内置含义。</li><li>大多数操作符对类对象没有意义。可以考虑逻辑映射到操作符操作，如相等测试重载<code>==</code>，输入输出重载移位操作符，测试对象为空重载非操作符。</li><li>复合赋值操作符。如重载<code>+</code>也要重载<code>+=</code>。</li><li>相等和关系操作符。<strong>将要用作关联容器键类型的类应该定义<code>&lt;</code>和<code>==</code>操作符</strong>。如果定义了相等操作符，也应该定义<code>!=</code>操作符。</li><li>选择类函数或普通非成员函数的指导原则：<ol><li>赋值、下标、调用、成员访问箭头(<code>=, [], (), -&gt;</code>)等操作符必须定义为成员。</li><li>复合操作符通常定义为类的成员。</li><li>改变对象状态或与给定类型紧密联系的其他一些操作符，如自增，自减，解引用，一般定义为类的成员。</li><li>对称操作符最好定义为普通非成员函数，如算数操作符、相等操作符、关系操作符和位操作符。</li></ol></li></ol><h2 id="输入输出操作符重载"><a class="markdownIt-Anchor" href="#输入输出操作符重载"></a> 输入输出操作符重载</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 重载输出操作符定义：</span></span><br><span class="line">ostream&amp;</span><br><span class="line">    <span class="keyword">operator</span> &lt;&lt;(ostream&amp; os, <span class="keyword">const</span> ClassType&amp; object) &#123;</span><br><span class="line">    <span class="comment">// prepare object</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// output</span></span><br><span class="line">    os &lt;&lt; ...</span><br><span class="line">    <span class="keyword">return</span> os;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 如Sales_item</span></span><br><span class="line">ostream&amp;</span><br><span class="line">    <span class="keyword">operator</span> &lt;&lt;(ostream&amp; os, <span class="keyword">const</span> Sales_item&amp; s) &#123;</span><br><span class="line">    os &lt;&lt; s.isbn &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> os;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输入操作符</span></span><br><span class="line"><span class="comment">// 重要！！！输入操作符必须处理错误和文件结束的可能性</span></span><br><span class="line">istream&amp;</span><br><span class="line">    <span class="keyword">operator</span> &gt;&gt;(istream&amp; in, Sales_item&amp; s) &#123;</span><br><span class="line"> <span class="keyword">double</span> price;</span><br><span class="line">    in &gt;&gt; s.isbn &gt;&gt; s.units_sold &gt;&gt; price;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (in) s.revenue = s.units_sold * price;</span><br><span class="line">    <span class="comment">// if input error, reset Sales_item</span></span><br><span class="line">    <span class="keyword">else</span> s = <span class="built_in">Sales_item</span>();</span><br><span class="line">    <span class="keyword">return</span> in;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注：IO操作符必须为非成员函数，因为成员函数只能隐藏左操作数，所以预达到目标只能重载<code>ostream</code>，但是<code>ostream</code>却是在标准库中的，不能乱动…</p><h2 id="下标操作符"><a class="markdownIt-Anchor" href="#下标操作符"></a> 下标操作符</h2><p>类定义下标操作符时，一般需要定义两个版本：一个为非const成员并返回引用，另一个为const成员并返回const引用。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> &amp;<span class="keyword">operator</span>[] (<span class="keyword">const</span> <span class="keyword">size_t</span>);</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> &amp;<span class="keyword">operator</span> [](<span class="keyword">const</span> <span class="keyword">size_t</span>) <span class="keyword">const</span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; data;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span>&amp; <span class="keyword">operator</span> [](<span class="keyword">const</span> <span class="keyword">size_t</span> index) &#123;</span><br><span class="line">    <span class="keyword">return</span> data[index];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span>&amp; <span class="keyword">operator</span> [](<span class="keyword">const</span> <span class="keyword">size_t</span> index) <span class="keyword">const</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> data[index];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="成员访问操作符"><a class="markdownIt-Anchor" href="#成员访问操作符"></a> 成员访问操作符</h2><p>指针支持的基本操作有解引用操作和箭头操作，我们的类可以定义：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ScreenPtr</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// constructor and copy control memberes as before</span></span><br><span class="line">    Screen &amp;<span class="keyword">operator</span> *() &#123; <span class="keyword">return</span> *ptr-&gt;sp &#125;;</span><br><span class="line">    Screen *<span class="keyword">operator</span> -&gt;() &#123; <span class="keyword">return</span> ptr-&gt;sp &#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">const</span> Screen &amp;<span class="keyword">operator</span> *() <span class="keyword">const</span> &#123; <span class="keyword">return</span> *ptr-&gt;sp &#125;;</span><br><span class="line">    <span class="keyword">const</span> Screen *<span class="keyword">operator</span> -&gt;() <span class="keyword">const</span> &#123; <span class="keyword">return</span> ptr-&gt;sp &#125;;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    ScrPtr *ptr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="重载箭头操作符"><a class="markdownIt-Anchor" href="#重载箭头操作符"></a> 重载箭头操作符</h2><p><code>-&gt;</code>表现为接受一个对象和一个成员名。由编译器处理获得成员的工作。所以，当我们编写如下代码：</p><p><code>point -&gt; action()</code></p><p>等价于编写</p><p><code>(point -&gt; action)()</code></p><p>换句话说，我们想调用对<code>point -&gt; action()</code>求值的结果，编译器将代码进行如下求值：</p><ol><li>如果<code>point</code>为指针，指向具有名为<code>action</code>的成员的类对象，则将编译为调用该对象的<code>action</code>成员；</li><li>否则，如果<code>action</code>是定义了<code>operator-&gt;</code>操作符的类的对象，则等价于<code>point.operator-&gt;()-&gt;action</code>。即执行<code>point</code>的<code>operator-&gt;()</code>，然后使用该结果再重复这三步。</li><li>否则，代码错误。</li></ol><p><strong>对重载箭头的返回值约束</strong>：重载箭头必须返回指向类类型的指针，或者返回定义了自己的箭头操作符的类类型对象。</p><ul><li>如果返回值是指针，则解引用，若没有该成员则编译器报错</li><li>如果返回值为类类型对象(或这种对象的引用)，则递归调用该操作符。</li></ul><h2 id="自增自减操作符重载"><a class="markdownIt-Anchor" href="#自增自减操作符重载"></a> 自增自减操作符重载</h2><p>C++不要求自增或自减操作符一定作为类的成员，但由于操作符改变对象状态，更倾向于作为成员。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 前缀操作符的实现(++ptr)：</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CheckedPtr</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    CheckedPtr&amp; <span class="keyword">operator</span>++() &#123;</span><br><span class="line">        <span class="comment">// 处理</span></span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 为了区别前后缀形式，后缀操作符函数接受一个额外的(无用的)int型形参，使用后编译器提供0作为形参的实参。</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CheckedPtr</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    CheckedPtr <span class="keyword">operator</span>++(<span class="keyword">int</span>) &#123;</span><br><span class="line">        <span class="comment">// 注：后缀返回的是旧值</span></span><br><span class="line">        <span class="function">CheckedPtr <span class="title">ret</span><span class="params">(*<span class="keyword">this</span>)</span></span>;</span><br><span class="line">        ++*<span class="keyword">this</span>;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 显式调用</span></span><br><span class="line"><span class="function">CheckedPtr <span class="title">parr</span><span class="params">(ia, ia + size)</span></span>;</span><br><span class="line">parr.<span class="keyword">operator</span>++(<span class="number">0</span>);<span class="comment">// 后缀形式</span></span><br><span class="line">parr.<span class="keyword">operator</span>++();  <span class="comment">// 前缀形式</span></span><br></pre></td></tr></table></figure><h2 id="调用操作符和函数对象"><a class="markdownIt-Anchor" href="#调用操作符和函数对象"></a> 调用操作符和函数对象</h2><p>函数对象：定义了调用操作符的类，其对象称为函数对象，即它们的行为类似函数的对象。</p><ol><li><p>函数对象用于标准库算法</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// old</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">GT6</span><span class="params">(<span class="keyword">const</span> string &amp;s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> s.<span class="built_in">size</span>() &gt;= <span class="number">6</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">vector&lt;string&gt;::sizetype wc = <span class="built_in">count_if</span>(words.<span class="built_in">begin</span>(), words.<span class="built_in">end</span>(), GT6);</span><br><span class="line"></span><br><span class="line"><span class="comment">// new</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GT_cls</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">GT_cls</span>(<span class="keyword">size_t</span> val = <span class="number">0</span>): <span class="built_in">bound</span>(val) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span> <span class="params">(<span class="keyword">const</span> string &amp;s)</span> </span>&#123; <span class="keyword">return</span> s.<span class="built_in">size</span>() &gt;= bound; &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::string::size_type bound;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">vector&lt;string&gt;::sizetype wc = <span class="built_in">count_if</span>(words.<span class="built_in">begin</span>(), words.<span class="built_in">end</span>(), <span class="built_in">GT_cls</span>(<span class="number">6</span>));</span><br></pre></td></tr></table></figure></li><li><p>函数对象的适配器和绑定器</p><ol><li>绑定器，是一种函数适配器，通过将一个操作数绑定到给定值而将二元函数对象转换为一元函数对象。</li><li>求反器，是一种函数适配器，将为其函数对象的真值求反。</li></ol><p>标准库定义了两个绑定器的适配器: <code>bind1st, bind2nd</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 计算一个容器中所有小于等于10的元素个数</span></span><br><span class="line"><span class="built_in">count_if</span>(vec.<span class="built_in">begin</span>(), vec.<span class="built_in">end</span>(), <span class="built_in">bind2nd</span>(less_equal&lt;<span class="keyword">int</span>&gt;(), <span class="number">10</span>));</span><br></pre></td></tr></table></figure><p>标准库定义了两个求反器: <code>not1, not2</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 对上个函数求反，即求所有大于10的元素个数</span></span><br><span class="line"><span class="built_in">count_if</span>(vec.<span class="built_in">begin</span>(), vec.<span class="built_in">end</span>(), <span class="built_in">not1</span>(<span class="built_in">bind2nd</span>(less_equal&lt;<span class="keyword">int</span>&gt;(), <span class="number">10</span>)));</span><br></pre></td></tr></table></figure></li></ol><h2 id="其他运算符重载"><a class="markdownIt-Anchor" href="#其他运算符重载"></a> 其他运算符重载</h2><ol><li>定义了<code>operator==</code>的类更容易与标准库一起使用，有些算法默认使用<code>==</code>运算符，如find。</li><li>关联容器以及某些算法，默认使用&lt;操作符。一般而言，关系操作符，诸如相等操作符应定义为非成员函数。</li><li>无论形参为何种类型，赋值操作符必须定义为成员函数。且赋值操作符和复合赋值操作符应返回左操作数的引用。</li></ol><h1 id="转换与类类型"><a class="markdownIt-Anchor" href="#转换与类类型"></a> 转换与类类型</h1><h2 id="转换操作符"><a class="markdownIt-Anchor" href="#转换操作符"></a> 转换操作符</h2><p>转换操作符是一种特殊的<strong>类成员函数</strong>，定义将类类型值转变为其他类型值的转换。<strong>在类定义体内声明</strong>，格式如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 形式：operator type()</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SmallInt</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">SmallInt</span>(<span class="keyword">int</span> i = <span class="number">0</span>): <span class="built_in">val</span>(i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; <span class="number">0</span> || i &gt; <span class="number">255</span>)</span><br><span class="line">            <span class="keyword">throw</span> std::<span class="built_in">out_of_range</span>(<span class="string">&quot;Bad!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">operator</span> <span class="title">int</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> val; &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::<span class="keyword">size_t</span> val;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中，<code>type</code>表示<strong>内置类型名、类类型名或由类型别名所定义的名字</strong>。对任何可作为函数返回类型的类型(<code>void</code>除外)都可以定义转换函数。</p><ol><li><p>一般而言，不允许转换为数组或函数类型，但允许转换为指针类型(数据和函数的指针)以及引用类型。</p></li><li><p>使用转换函数时，被转换的类型不必与所需要的类型完全匹配。例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SmallInt si;</span><br><span class="line"><span class="keyword">double</span> dval;</span><br><span class="line">si &gt;= dval;</span><br></pre></td></tr></table></figure><p><code>SmallInt</code>首先转换为<code>int</code>类型，然后<code>int</code>转换为<code>double</code>的值。</p></li><li><p>**类类型转换以后不能在跟一个类类型转换！！**如果需要多个类类型转换，则代码会错误。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 假定另一个类Integral，可以转换为SmallInt但不能转换为Int</span></span><br><span class="line"><span class="function">Itergral <span class="title">intVal</span><span class="params">(<span class="number">1</span>)</span></span>;</span><br><span class="line"><span class="function">SmallInt <span class="title">si</span><span class="params">(intval)</span></span>;<span class="comment">//ok, Integral-&gt;SmallInt</span></span><br><span class="line"><span class="keyword">int</span> i = si;<span class="comment">//ok, SmallInt-&gt;int</span></span><br><span class="line"><span class="keyword">int</span> j = intval<span class="comment">//error, Integral -x-&gt; int</span></span><br></pre></td></tr></table></figure></li><li><p>标准转换可放在类类型转换之前。</p></li></ol><h2 id="实参匹配与转换"><a class="markdownIt-Anchor" href="#实参匹配与转换"></a> 实参匹配与转换</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 我们为SmallInt加上另外两个转换</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SmallInt</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">SmallInt</span>(<span class="keyword">int</span> = <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">SmallInt</span>(<span class="keyword">double</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">operator</span> <span class="title">int</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> val; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">operator</span> <span class="title">double</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;<span class="keyword">return</span> val; &#125;</span><br><span class="line">    </span><br><span class="line">    std::<span class="keyword">size_t</span> val;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><p>实参匹配和多个转换操作符：</p><p>一般而言，给出一个类与两个内置类型之间的转换是不好的做法，例如下述例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">compute</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fp_compute</span><span class="params">(<span class="keyword">double</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">extend_compute</span><span class="params">(<span class="keyword">long</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">SmallInt si;</span><br><span class="line"><span class="built_in">compute</span>(si);<span class="comment">// SmallInt -&gt; int</span></span><br><span class="line"><span class="built_in">fp_compute</span>(si);<span class="comment">// SmallInt -&gt; double</span></span><br><span class="line"><span class="built_in">extend_compute</span>(si);<span class="comment">// error! ambiguous!</span></span><br></pre></td></tr></table></figure></li><li><p>实参匹配和构造函数转换</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">manip</span><span class="params">(<span class="keyword">const</span> SmallInt &amp;)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">double</span> d; <span class="keyword">int</span> i; <span class="keyword">long</span> l;</span><br><span class="line"><span class="built_in">manip</span>(d);<span class="comment">// ok: use SmallInt(double)</span></span><br><span class="line"><span class="built_in">manip</span>(i);<span class="comment">// ok: use SmallInt(int)</span></span><br><span class="line"><span class="built_in">manip</span>(l);<span class="comment">// error! ambiguous!</span></span><br></pre></td></tr></table></figure></li><li><p>当两个类定义了转换时的二义性</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Integral</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SmallInt</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">SmallInt</span>(Integral);<span class="comment">// convert from Integral to SmallInt</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Integral</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">operator</span> <span class="title">SmallInt</span><span class="params">()</span> <span class="keyword">const</span></span>; <span class="comment">// convert from Integral to SmallInt</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// main</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">compute</span><span class="params">(SmallInt)</span></span>;</span><br><span class="line">Integral int_val;</span><br><span class="line"><span class="built_in">compute</span>(int_val);<span class="comment">//error! ambigouos!</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">compute</span>(<span class="built_in">SmallInt</span>(int_val));<span class="comment">// ok</span></span><br><span class="line"><span class="built_in">compute</span>(int_val.<span class="keyword">operator</span> <span class="built_in">SmallInt</span>());<span class="comment">// ok</span></span><br></pre></td></tr></table></figure></li></ol><h2 id="重载确定和类的实参"><a class="markdownIt-Anchor" href="#重载确定和类的实参"></a> 重载确定和类的实参</h2><ol><li><p>在需要转换函数的实参时，编译器自动应用类的转换操作符或构造函数。于是函数重载确定由三部分组成：</p><ol><li><p>确定候选函数集合：与被调用函数同名的函数。</p></li><li><p>确定可行函数：形参数目、类型与函数调用中的实参相匹配的候选函数。如果有转换操作，编译器还需确定使用哪个转换操作。</p></li><li><p>选择最佳匹配的函数。</p></li></ol></li><li><p>转换操作符之后的标准转换</p><p>哪个函数是最佳匹配，可能依赖于匹配不同函数中是否涉及了一个或多个类类型转换：</p><ul><li><p>如果重载集中的两个函数可以使用同一转换函数匹配，则使用在转换之后或之前的标准转换序列的等级确定哪个函数为最佳匹配；</p></li><li><p>否则，如果使用不同的转换操作，则认为两个转换是一样好的匹配，不管标准转换的等级如何。</p></li></ul></li><li><p>面对二义性转换，程序员可以使用强制转换显式指定应用哪个转换操作：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">compute</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">compute</span><span class="params">(<span class="keyword">double</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">SmallInt si;</span><br><span class="line"><span class="built_in">compute</span>(<span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(si));</span><br></pre></td></tr></table></figure></li><li><p>标准转换和构造函数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SmallInt</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">SmallInt</span>(<span class="keyword">int</span> = <span class="number">0</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Integral</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Integral</span>(<span class="keyword">int</span> = <span class="number">0</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">manip</span><span class="params">(<span class="keyword">const</span> Integral)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">manip</span><span class="params">(<span class="keyword">const</span> SmallInt)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">manip</span>(<span class="number">10</span>);<span class="comment">// error! ambiguous!</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 即使一个类定义了实参需要标准转换的构造函数，该函数调用也具有二义性。</span></span><br><span class="line"><span class="comment">// 原因见本节第二点</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用显式构造消除二义性</span></span><br><span class="line"><span class="built_in">manip</span>(<span class="built_in">SmallInt</span>(<span class="number">10</span>));</span><br><span class="line"><span class="built_in">manip</span>(<span class="built_in">Integral</span>(<span class="number">10</span>));</span><br></pre></td></tr></table></figure></li></ol><h1 id="面向对象编程"><a class="markdownIt-Anchor" href="#面向对象编程"></a> 面向对象编程</h1><p>在C++中，通过基类的引用(或指针)调用虚函数时，发生动态绑定。引用(或指针)既可以指向基类对象也可以指向派生类对象，这是动态绑定的关键。用引用(或指针)调用的虚函数在<strong>运行时确定</strong>，被调用的函数是引用(或指针)所指对象的实际类型定义的。</p><h2 id="定义基类和派生类"><a class="markdownIt-Anchor" href="#定义基类和派生类"></a> 定义基类和派生类</h2><ol><li><p>派生类中虚函数的声明必须与基类中的定义方式完全匹配。但有一个例外：返回对基类型的引用(或指针)的虚函数，派生类中可以返回派生类的引用(或指针)。</p></li><li><p>声明派生类不需要包含派生列表。</p></li><li><p><code>virtual</code>与其他成员函数</p><ol><li><p>要触发动态绑定，必须实现两个条件：</p><ul><li>只有指定为虚函数的成员函数才可以进行动态绑定。</li><li>必须通过基类类型的引用或指针进行函数调用。</li></ul><p>当基类类型的引用和指针既可以指向基类类型，也可以指向派生类，因为派生类包含着基类。当使用指针或引用调用虚函数时，只有才运行时才可以确定指向的类型，并调用相应的函数。</p><p><strong>引用和指针的静态类型与动态类型可以不同</strong>，这是C++用以支持多态性的基石。</p></li><li><p>覆盖虚函数机制：派生类虚函数调用基类版本时，必须显式使用作用域操作符。如果派生函数忽略了这样做，则函数调用在运行时确定并且将是一个自身调用，从而导致无穷递归。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Bulk_item: Item_base</span></span><br><span class="line">Bulk_item derived;</span><br><span class="line">Item_base* baseP = &amp;derived;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用基类版本的虚函数</span></span><br><span class="line"><span class="keyword">double</span> b = baseP-&gt;Item_base::<span class="built_in">net_price</span>(<span class="number">42</span>);</span><br></pre></td></tr></table></figure></li><li><p>虚函数与默认实参：派生类对于默认形参省略了该实参，则会使用基类的默认形参！！！</p><p>所以基类与派生类的默认实参最好设置成一样的！</p></li></ol></li><li><p>公用、私有和受保护的继承</p><ul><li>公用继承：基类成员保持自己的访问级别。</li><li>受保护的继承：基类成员的<code>public</code>成员为派生类的<code>protected</code>成员。</li><li>私有继承：基类成员的所有成员在派生类中为<code>private</code>成员。</li></ul><ol><li><p>接口继承与实现继承：<code>private</code>和<code>protected</code>派生的类不继承基类的接口，这些派生通常被称为实现继承。</p></li><li><p>去除个别成员：尽管使用<code>private</code>或<code>protected</code>继承，但也可以使用<code>using</code>声明来从命名空间使用名字，保持访问等级：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">int</span> m;</span><br><span class="line">&#125;; </span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Extext</span>:</span> <span class="keyword">private</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">using</span> Base::m;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// main</span></span><br><span class="line">Base base;</span><br><span class="line"><span class="keyword">int</span> m = base.m;<span class="comment">// ok</span></span><br></pre></td></tr></table></figure></li><li><p>默认继承保护级别：<code>struct</code>保留字定义的类与用<code>class</code>定义的类唯一不同是默认的成员保护级别和默认的派生保护级别不同，其他无区别：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span> &#123;</span><span class="comment">/* ... */</span>&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">D1</span> :</span> Base &#123;<span class="comment">/* ... */</span>&#125;;<span class="comment">// public继承</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D2</span> :</span> Base &#123;<span class="comment">/* ... */</span>&#125;<span class="comment">// private继承</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 以下定义方式等价</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D3</span> :</span> <span class="keyword">public</span> Base &#123;<span class="comment">/* ... */</span>&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">D3</span> :</span> Base &#123;<span class="comment">/* ... */</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 以下定义方式等价</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D4</span> :</span> Base &#123;<span class="comment">/* ... */</span>&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">D4</span> :</span> <span class="keyword">private</span> Base &#123;<span class="comment">/* ... */</span>&#125;;</span><br></pre></td></tr></table></figure></li></ol></li><li><p>友元关系与继承：有缘关系不能继承。基类的友元对派生类的成员没有特殊访问权限。如果基类被授予友元关系，则只有基类具有特殊访问权限，该基类的派生类不能访问授予友元关系的类。</p></li><li><p>继承与静态成员：如果基类定义了<code>static</code>成员，则整个继承层次中只有一个这样的成员，无论从基类派生出多少个派生类，每个<code>static</code>成员只有一个实例。</p></li></ol><h2 id="转换与继承"><a class="markdownIt-Anchor" href="#转换与继承"></a> 转换与继承</h2><ol><li><p>引用转换不同于转换对象：</p><ul><li>可以将派生类型的对象传给希望接受基类引用的函数，引用直接绑定到该对象，但转换不会在任何方面改变派生类型对象，该对象仍是派生类型对象；</li><li>将派生类型对象传给希望接受基类对象(而不是引用)的函数时，派生类对象的基类部分被复制到形参，形参类型便是固定的——编译与运行时均为基类对象。</li></ul></li><li><p>用派生类对象对基类对象进行初始化或赋值：</p><ul><li><p>基类一般(显式或隐式)定义自己的复制构造函数和赋值操作符，这些成员接受一个形参，<strong>该形参是基类类型的<code>const</code>引用</strong>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Item_base item;</span><br><span class="line">Bulk_item bulk;</span><br><span class="line"><span class="comment">// ok, use Item_base::Item_base(const Item_base&amp;)</span></span><br><span class="line"><span class="function">Item_base <span class="title">item</span><span class="params">(bulk)</span></span>;</span><br><span class="line"><span class="comment">// ok, call Item_base::operator=(const Item_base&amp;)</span></span><br><span class="line">item = bulk;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">转换步骤：</span></span><br><span class="line"><span class="comment">1. Bulk_item对象转换为Item_base引用</span></span><br><span class="line"><span class="comment">2. 将该引用作为实参传给复制构造函数或赋值操作符</span></span><br><span class="line"><span class="comment">3. 使用Bulk_item的Item_base部分分别调用构造函数或赋值的Item_base对象的成员进行初始化和赋值</span></span><br><span class="line"><span class="comment">4. 执行完毕后，对象即为Item_base，包含Bulk_item的Item_base部分的副本，但实参的Bulk_item部分被忽略</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>派生类到基类转换的可访问性：</p><ol><li><p>如果使用public继承，则用户代码和后代类都可以使用派生类到基类的转换；</p></li><li><p>如果使用private和protected继承，用户代码不能将派生类型对象转换为基类对象：</p><ul><li>如果是private继承，则从private继承类派生的类不能转换为基类；</li><li>如果是protected继承，则后续派生类的成员可以转换为基类类型；</li></ul></li><li><p>无论是什么派生访问标号，派生类本身都可以访问基类的public成员，因此派生类本身成员和友元总是可以访问派生类到基类的转换：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">int</span> m = <span class="number">1</span>;</span><br><span class="line">&#125;; </span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Extext</span>:</span> <span class="keyword">private</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">using</span> Base::m;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">function</span><span class="params">(<span class="keyword">const</span> Base&amp; base)</span> </span>&#123;</span><br><span class="line">std::cout &lt;&lt; base.m;</span><br><span class="line">&#125; </span><br><span class="line">    <span class="comment">// 这个函数体现了转换，本身的成员函数总是可以访问派生类到基类的转换的</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">display</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">function</span>(*<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// main</span></span><br><span class="line">Extext ex;</span><br><span class="line">ex.<span class="built_in">display</span>();</span><br></pre></td></tr></table></figure></li></ol></li><li><p>基类到派生类的转换：没有从基类到派生类的自动转换，使用基类指针或引用实际绑定到派生类对象时，同样存在限制；如果知道基类到派生类转换是安全的，可以使用<code>static_case</code>或<code>dynamic_cast</code>进行转换。</p></li></ol><h2 id="构造函数与复制控制"><a class="markdownIt-Anchor" href="#构造函数与复制控制"></a> 构造函数与复制控制</h2><ol><li><p>派生类可以在自己构造函数的初始化列表中向基类的构造函数进行参数传递。</p></li><li><p>一个类只能初始化自己的<strong>直接基类</strong>！</p></li><li><p>定义派生类复制构造函数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span> &#123;</span> <span class="comment">/* ... */</span> &#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span>:</span> <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// Base::Base(const Base&amp;) 不会被自动调用，需要使用初始化函数Base(d)</span></span><br><span class="line">    <span class="built_in">Derived</span>(<span class="keyword">const</span> Derived&amp; d) &#123;</span><br><span class="line">        <span class="built_in">Base</span>(d);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>初始化函数<code>Base(d)</code>将派生类对象d转换为它的基类部分的引用，并调用基类复制构造函数。</p></li><li><p>派生类赋值操作符：如果派生类定义了自己的赋值操作符，该操作符必须对基类部分进行显式赋值：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Derived &amp;Derived::<span class="keyword">operator</span>=(<span class="keyword">const</span> Derived&amp; rhs) &#123;</span><br><span class="line">    <span class="comment">// 必须防止自身赋值</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span> != &amp;rhs) &#123;</span><br><span class="line">        Base::<span class="keyword">operator</span>=(rhs);</span><br><span class="line">        <span class="comment">// do something...</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>派生类的析构函数：每个析构函数只负责清除自己的成员。对象撤销顺序与构造函数相反，按继承层次依次向上调用。</p></li><li><p>虚析构函数：删除指向动态分配对象的指针时，指针的静态类型可能与被删除对象的动态类型不同，可能会删除实际指向派生类对象的基类类型指针。</p><p>要保证运行适当的析构函数，基类中的析构函数必须为虚函数。那么通过指针调用时，运行哪个析构函数将因指针所指对象类型的不同而不同。</p><p>所以，即使析构函数没有工作要做，继承层次的根类也应该定义一个虚析构函数。</p></li><li><p>构造函数和赋值操作符不是虚函数！</p><ul><li>构造函数在运行时，对象的动态类型是不完整的；</li><li>虚函数要求形式完全相同，而赋值操作符中每个类都有一个与类本身相同的形参。</li></ul></li><li><p>构造函数和析构函数中的虚函数：</p><p>在构造派生类对象时首先会运行基类的构造函数，而在撤销派生类对象时，会按照构造顺序的逆序撤销基类部分。在这两种情况下运行构造函数或析构函数，对象都是不完整的，编译器将对象的类型视为在构造和析构期间发生了变化。在基类构造函数或析构函数中，将派生类对象视为基类对象看待，<strong>这对虚函数的绑定有影响</strong>。</p><p><strong>如果在构造函数或析构函数中调用虚函数，则运行的是为构造函数或析构函数自身类型定义的版本</strong>。</p></li></ol><h2 id="纯虚函数"><a class="markdownIt-Anchor" href="#纯虚函数"></a> 纯虚函数</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Disc_item</span>:</span> <span class="keyword">public</span> Item_base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">net_price</span><span class="params">(std::<span class="keyword">size_t</span>)</span> <span class="keyword">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在函数形参表后面写上=0以指定纯虚函数。</p><p>含有(或继承)一个或多个纯虚函数的类是抽象基类，除了作为抽象基类的派生类的对象的组成部分，不能创建抽象类型的对象。</p><h2 id="容器与继承"><a class="markdownIt-Anchor" href="#容器与继承"></a> 容器与继承</h2><p>因为派生类对象在赋值给基类对象时会被&quot;切掉&quot;，所以容器与通过继承相关的类型不能很好的融合。</p><h2 id="句柄类与继承"><a class="markdownIt-Anchor" href="#句柄类与继承"></a> 句柄类与继承</h2><ol><li><p>句柄类存储和管理基类指针。指针所指对象的类型可以变化，既可以指向基类类型对象又可以指向派生类型对象。用户通过句柄类访问继承层次的操作。句柄类类似指针执行操作，<strong>虚成员</strong>的行为将在运行时根据句柄实际绑定的对象类型而变化。</p></li><li><p>复制未知类型：句柄类经常需要在不知道对象的确切类型时分配已知对象的新副本。解决这个问题的通常方法是定义<strong>虚操作</strong>进行复制，称该操作为clone。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 基类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Item_base</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> Item_base* <span class="title">clone</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Item_base</span>(*<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 派生类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bulk_item</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> Bulk_item* <span class="title">clone</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Bulk_item</span>(*<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>句柄的使用</p><ol><li><p>使用带比较器的关联容器</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">compare</span><span class="params">(<span class="keyword">const</span> Sales_item&amp; lhs, <span class="keyword">const</span> Sales_item&amp; rhs)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> lhs-&gt;<span class="built_in">book</span>() &lt; rhs-&gt;<span class="built_in">book</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">bool</span> <span class="params">(*Comp)</span> <span class="params">(<span class="keyword">const</span> Sales_item&amp;, <span class="keyword">const</span> Sales_item&amp;)</span></span>;</span><br><span class="line"><span class="function">std::multiset&lt;Sales_item, Comp&gt; <span class="title">items</span><span class="params">(compare)</span></span>;</span><br></pre></td></tr></table></figure></li><li><p>使用句柄执行虚函数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">Basket::total</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">double</span> sum = <span class="number">0.0</span>;</span><br><span class="line">    <span class="keyword">for</span> (const_iter iter = items.<span class="built_in">begin</span>(); </span><br><span class="line">         iter != items.<span class="built_in">end</span>(); </span><br><span class="line">         iter = items.<span class="built_in">upper_bound</span>(*iter)) &#123;</span><br><span class="line">        sum += (*iter)-&gt;<span class="built_in">net_price</span>(items.<span class="built_in">count</span>(*iter));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol></li></ol>]]></content>
    
    
    <summary type="html">C++ Primer学习笔记，这个书牛牛牛。</summary>
    
    
    
    <category term="CS" scheme="http://aflyingsheep.github.io/categories/CS/"/>
    
    
    <category term="CS" scheme="http://aflyingsheep.github.io/tags/CS/"/>
    
    <category term="C/C++" scheme="http://aflyingsheep.github.io/tags/C-C/"/>
    
  </entry>
  
  <entry>
    <title>C++：const在各个位置的含义</title>
    <link href="http://aflyingsheep.github.io/2023/02/23/cpp/const/"/>
    <id>http://aflyingsheep.github.io/2023/02/23/cpp/const/</id>
    <published>2023-02-23T09:37:06.000Z</published>
    <updated>2023-02-23T09:45:28.685Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="const在函数的各个位置"><a class="markdownIt-Anchor" href="#const在函数的各个位置"></a> const在函数的各个位置</h1><p>1.<code>const</code>在函数返回值前，表明返回值为<code>const</code></p><p><code>const int getNum() &#123; return i; &#125;    // 表示返回值为const</code></p><p>2.<code>const</code>在参数前面，表明参数为<code>const</code>，在函数体不能改变</p><p><code>int getNum(const int num) &#123;&#125;   //num在函数体中不能被改变</code></p><p>3.<code>const</code>在函数体后面，表示是类的常成员函数（函数体中可以把<code>this</code>看做是<code>const</code>，类的成员不能改变，只能调用其他常成员函数）</p><p><code>public int getNum() const;</code></p><h1 id="const在指针定义的各个位置"><a class="markdownIt-Anchor" href="#const在指针定义的各个位置"></a> const在指针定义的各个位置</h1><p><code>const int a = 2;</code></p><p>`const int* p;</p><p>这种情况表示p是一个指向<code>const int</code>的指针。<code>p</code>可以改变，但是它指向的内容是不可变的。</p><p>`int const* p = &amp;a;</p><p>这种情况表示p是一个指向int的const指针。p的地址不可以改变，但是它指向的内容可变。比如<code>*p = 3;</code></p><p><code>const int const *p = &amp;a;</code></p><p><code>p</code>是一个指向<code>const int</code>的<code>const</code>指针。它指向的内容，和自身的地址都不可变。</p>]]></content>
    
    
    <summary type="html">const常量，在函数各个位置有不同含义</summary>
    
    
    
    <category term="C++" scheme="http://aflyingsheep.github.io/categories/C/"/>
    
    
    <category term="C++" scheme="http://aflyingsheep.github.io/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>线性方程组的迭代式求解方法</title>
    <link href="http://aflyingsheep.github.io/2023/02/10/math/sor/"/>
    <id>http://aflyingsheep.github.io/2023/02/10/math/sor/</id>
    <published>2023-02-10T12:22:06.000Z</published>
    <updated>2023-02-11T08:41:34.155Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="笔记图解"><a class="markdownIt-Anchor" href="#笔记图解"></a> 笔记图解</h1><p><img src="/image/j_gs_sor/1.jpeg" alt="1" /></p>]]></content>
    
    
    <summary type="html">详解Jacobi迭代法、Gauss-Seidel迭代法、SOR超松弛迭代法由一般形式转化为矩阵形式</summary>
    
    
    
    <category term="Math" scheme="http://aflyingsheep.github.io/categories/Math/"/>
    
    
    <category term="Math" scheme="http://aflyingsheep.github.io/tags/Math/"/>
    
  </entry>
  
  <entry>
    <title>cmake学习笔记</title>
    <link href="http://aflyingsheep.github.io/2023/01/30/linux/cmake/"/>
    <id>http://aflyingsheep.github.io/2023/01/30/linux/cmake/</id>
    <published>2023-01-30T13:27:06.000Z</published>
    <updated>2023-02-11T08:42:55.001Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>实验环境下载地址：<a href="https://github.com/AFlyingSheep/cmake-learn/archive/refs/heads/master.zip">Click me!</a></p><h1 id="cmake一个helloword"><a class="markdownIt-Anchor" href="#cmake一个helloword"></a> CMake一个HelloWord</h1><p>1、步骤一，写一个HelloWord</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#main.cpp</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">std::cout &lt;&lt;  <span class="string">&quot;hello word&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2、步骤二，写CMakeLists.txt</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">#CMakeLists.<span class="function">txt</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">PROJECT</span> <span class="params">(HELLO)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">SET</span><span class="params">(SRC_LIST main.cpp)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">MESSAGE</span><span class="params">(STATUS <span class="string">&quot;This is BINARY dir &quot;</span> $&#123;HELLO_BINARY_DIR&#125;)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">MESSAGE</span><span class="params">(STATUS <span class="string">&quot;This is SOURCE dir &quot;</span>$&#123;HELLO_SOURCE_DIR&#125;)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">ADD_EXECUTABLE</span><span class="params">(hello $&#123;SRC_LIST&#125;)</span></span></span><br></pre></td></tr></table></figure><p>3、步骤三、使用cmake，生成makefile文件</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">cmake .</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line">[root@localhost cmake]<span class="meta"># cmake .</span></span><br><span class="line"><span class="function">CMake <span class="title">Warning</span> <span class="params">(dev)</span> in CMakeLists.txt:</span></span><br><span class="line"><span class="function">  Syntax Warning in cmake code at</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">    /root/cmake/CMakeLists.txt:<span class="number">7</span>:<span class="number">37</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">  Argument not separated from preceding token by whitespace.</span></span><br><span class="line"><span class="function">This warning is for project developers.  Use -Wno-dev to suppress it.</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">-- The C compiler identification is GNU <span class="number">10.2</span><span class="number">.1</span></span></span><br><span class="line"><span class="function">-- The CXX compiler identification is GNU <span class="number">10.2</span><span class="number">.1</span></span></span><br><span class="line"><span class="function">-- Check for working C compiler: /usr/bin/cc</span></span><br><span class="line"><span class="function">-- Check for working C compiler: /usr/bin/cc -- works</span></span><br><span class="line"><span class="function">-- Detecting C compiler ABI info</span></span><br><span class="line"><span class="function">-- Detecting C compiler ABI info - done</span></span><br><span class="line"><span class="function">-- Check for working CXX compiler: /usr/bin/c++</span></span><br><span class="line"><span class="function">-- Check for working CXX compiler: /usr/bin/c++ -- works</span></span><br><span class="line"><span class="function">-- Detecting CXX compiler ABI info</span></span><br><span class="line"><span class="function">-- Detecting CXX compiler ABI info - done</span></span><br><span class="line"><span class="function">-- This is BINARY dir /root/cmake</span></span><br><span class="line"><span class="function">-- This is SOURCE dir /root/cmake</span></span><br><span class="line"><span class="function">-- Configuring done</span></span><br><span class="line"><span class="function">-- Generating done</span></span><br><span class="line"><span class="function">-- Build files have been written to: /root/cmake</span></span><br></pre></td></tr></table></figure><p>目录下就生成了这些文件-CMakeFiles, CMakeCache.txt, cmake_install.cmake 等文件，并且生成了Makefile.<br />现在不需要理会这些文件的作用，以后你也可以不去理会。最关键的是，它自动生成了Makefile.</p><p>4、使用make命令编译</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">root@localhost cmake]<span class="meta"># make</span></span><br><span class="line">Scanning dependencies of target hello</span><br><span class="line">[<span class="number">100</span>%] Building CXX object CMakeFiles/hello.dir/main.cpp.o</span><br><span class="line">Linking CXX executable hello</span><br><span class="line">[<span class="number">100</span>%] Built target hello</span><br></pre></td></tr></table></figure><p>5、最终生成了Hello的可执行程序</p><h1 id="cmake一个helloword-的语法介绍"><a class="markdownIt-Anchor" href="#cmake一个helloword-的语法介绍"></a> CMake一个HelloWord-的语法介绍</h1><h2 id="project关键字"><a class="markdownIt-Anchor" href="#project关键字"></a> PROJECT关键字</h2><p>可以用来指定工程的名字和支持的语言，默认支持所有语言</p><p>PROJECT (HELLO)   指定了工程的名字，并且支持所有语言—建议</p><p>PROJECT (HELLO CXX)      指定了工程的名字，并且支持语言是C++</p><p>PROJECT (HELLO C CXX)      指定了工程的名字，并且支持语言是C和C++</p><p>该指定隐式定义了两个CMAKE的变量</p><p><projectname>_BINARY_DIR，本例中是 HELLO_BINARY_DIR</p><p><projectname>_SOURCE_DIR，本例中是 HELLO_SOURCE_DIR</p><p>MESSAGE关键字就可以直接使用者两个变量，当前都指向当前的工作目录，后面会讲外部编译</p><p>问题：如果改了工程名，这两个变量名也会改变</p><p>解决：又定义两个预定义变量：PROJECT_BINARY_DIR和PROJECT_SOURCE_DIR，这两个变量和HELLO_BINARY_DIR，HELLO_SOURCE_DIR是一致的。所以改了工程名也没有关系</p><h2 id="set关键字"><a class="markdownIt-Anchor" href="#set关键字"></a> SET关键字</h2><p>用来显示的指定变量的</p><p>SET(SRC_LIST main.cpp)    SRC_LIST变量就包含了main.cpp</p><p>也可以 SET(SRC_LIST main.cpp t1.cpp t2.cpp)</p><h2 id="message关键字"><a class="markdownIt-Anchor" href="#message关键字"></a> MESSAGE关键字</h2><p>向终端输出用户自定义的信息</p><p>主要包含三种信息：</p><ul><li>SEND_ERROR，产生错误，生成过程被跳过。</li><li>SATUS，输出前缀为—的信息。</li><li>FATAL_ERROR，立即终止所有 cmake 过程.</li></ul><h2 id="add_executable关键字"><a class="markdownIt-Anchor" href="#add_executable关键字"></a> ADD_EXECUTABLE关键字</h2><p>生成可执行文件</p><p>ADD_EXECUTABLE(hello ${SRC_LIST})     生成的可执行文件名是hello，源文件读取变量SRC_LIST中的内容</p><p>也可以直接写 ADD_EXECUTABLE(hello main.cpp)</p><p>上述例子可以简化的写成</p><p>PROJECT(HELLO)<br />ADD_EXECUTABLE(hello main.cpp)</p><p>注意：工程名的 HELLO 和生成的可执行文件 hello 是没有任何关系的</p><h1 id="语法的基本原则"><a class="markdownIt-Anchor" href="#语法的基本原则"></a> 语法的基本原则</h1><ul><li><p>变量使用${}方式取值，但是在 IF 控制语句中是直接使用变量名</p></li><li><p>指令(参数 1 参数 2…) 参数使用括弧括起，参数之间使用空格或分号分开。 以上面的 ADD_EXECUTABLE 指令为例，如果存在另外一个 func.cpp 源文件</p><p>就要写成：ADD_EXECUTABLE(hello main.cpp func.cpp)或者ADD_EXECUTABLE(hello main.cpp;func.cpp)</p></li><li><p>指令是大小写无关的，参数和变量是大小写相关的。但，推荐你全部使用大写指令</p></li></ul><h2 id="语法注意事项"><a class="markdownIt-Anchor" href="#语法注意事项"></a> 语法注意事项</h2><ul><li>SET(SRC_LIST main.cpp) 可以写成 SET(SRC_LIST “main.cpp”)，如果源文件名中含有空格，就必须要加双引号</li><li>ADD_EXECUTABLE(hello main) 后缀可以不写，他会自动去找.c和.cpp，最好不要这样写，可能会有这两个文件main.cpp和main</li></ul><h1 id="内部构建和外部构建"><a class="markdownIt-Anchor" href="#内部构建和外部构建"></a> 内部构建和外部构建</h1><ul><li>上述例子就是内部构建，他生产的临时文件特别多，不方便清理</li><li>外部构建，就会把生成的临时文件放在build目录下，不会对源文件有任何影响强烈使用外部构建方式</li></ul><h2 id="外部构建方式举例"><a class="markdownIt-Anchor" href="#外部构建方式举例"></a> 外部构建方式举例</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//例子目录，CMakeLists.txt和上面例子一致</span></span><br><span class="line">[root@localhost cmake]<span class="meta"># pwd</span></span><br><span class="line">/root/cmake</span><br><span class="line">[root@localhost cmake]<span class="meta"># ll</span></span><br><span class="line">total <span class="number">8</span></span><br><span class="line">-rw-r--r--. <span class="number">1</span> root root <span class="number">198</span> Dec <span class="number">28</span> <span class="number">20</span>:<span class="number">59</span> CMakeLists.txt</span><br><span class="line">-rw-r--r--. <span class="number">1</span> root root  <span class="number">76</span> Dec <span class="number">28</span> <span class="number">00</span>:<span class="number">18</span> main.cpp</span><br></pre></td></tr></table></figure><p>1、建立一个build目录，可以在任何地方，建议在当前目录下</p><p>2、进入build，运行cmake …    当然…表示上一级目录，你可以写CMakeLists.txt所在的绝对路径，生产的文件都在build目录下了</p><p>3、在build目录下，运行make来构建工程</p><p>注意外部构建的两个变量</p><p>1、HELLO_SOURCE_DIR  还是工程路径</p><p>2、HELLO_BINARY_DIR   编译路径 也就是 /root/cmake/bulid</p><h1 id="让hello-world看起来更像一个工程"><a class="markdownIt-Anchor" href="#让hello-world看起来更像一个工程"></a> 让Hello World看起来更像一个工程</h1><ul><li>为工程添加一个子目录 src，用来放置工程源代码</li><li>添加一个子目录 doc，用来放置这个工程的文档 hello.txt</li><li>在工程目录添加文本文件 COPYRIGHT, README</li><li>在工程目录添加一个 <a href="http://runhello.sh/">runhello.sh</a> 脚本，用来调用 hello 二进制</li><li>将构建后的目标文件放入构建目录的 bin 子目录</li><li>将 doc 目录 的内容以及 COPYRIGHT/README 安装到/usr/share/doc/cmake/</li></ul><h2 id="将目标文件放入构建目录的-bin-子目录"><a class="markdownIt-Anchor" href="#将目标文件放入构建目录的-bin-子目录"></a> 将目标文件放入构建目录的 bin 子目录</h2><p>每个目录下都要有一个CMakeLists.txt说明</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost cmake]<span class="meta"># tree</span></span><br><span class="line">.</span><br><span class="line">├── build</span><br><span class="line">├── CMakeLists.txt</span><br><span class="line">└── src</span><br><span class="line">    ├── CMakeLists.txt</span><br><span class="line">    └── main.cpp</span><br></pre></td></tr></table></figure><p>外层CMakeLists.txt</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">PROJECT</span>(HELLO)</span><br><span class="line"><span class="built_in">ADD_SUBDIRECTORY</span>(src bin)</span><br></pre></td></tr></table></figure><p>src下的CMakeLists.txt</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">ADD_EXECUTABLE</span>(hello main.cpp)</span><br></pre></td></tr></table></figure><h3 id="add_subdirectory-指令"><a class="markdownIt-Anchor" href="#add_subdirectory-指令"></a> ADD_SUBDIRECTORY 指令</h3><p>ADD_SUBDIRECTORY(source_dir [binary_dir] [EXCLUDE_FROM_ALL])</p><ul><li><p>这个指令用于向当前工程添加存放源文件的子目录，并可以指定中间二进制和目标二进制存放的位置</p></li><li><p>EXCLUDE_FROM_ALL函数是将写的目录从编译中排除，如程序中的example</p></li><li><p>ADD_SUBDIRECTORY(src bin)</p><p>将 src 子目录加入工程并指定编译输出(包含编译中间结果)路径为bin 目录</p><p>如果不进行 bin 目录的指定，那么编译结果(包括中间结果)都将存放在build/src 目录</p></li></ul><h3 id="更改二进制的保存路径"><a class="markdownIt-Anchor" href="#更改二进制的保存路径"></a> 更改二进制的保存路径</h3><p>SET 指令重新定义 EXECUTABLE_OUTPUT_PATH 和 LIBRARY_OUTPUT_PATH 变量 来指定最终的目标二进制的位置</p><p>SET(EXECUTABLE_OUTPUT_PATH ${PROJECT_BINARY_DIR}/bin)<br />SET(LIBRARY_OUTPUT_PATH ${PROJECT_BINARY_DIR}/lib)</p><p>思考：加载哪个CMakeLists.txt当中</p><p>哪里要改变目标存放路径，就在哪里加入上述的定义，所以应该在src下的CMakeLists.txt下写</p><h1 id="安装"><a class="markdownIt-Anchor" href="#安装"></a> 安装</h1><ul><li>一种是从代码编译后直接 make install 安装</li><li>一种是打包时的指定 目录安装。<ul><li>简单的可以这样指定目录：make install DESTDIR=/tmp/test</li><li>稍微复杂一点可以这样指定目录：./configure –prefix=/usr</li></ul></li></ul><h2 id="如何安装helloword"><a class="markdownIt-Anchor" href="#如何安装helloword"></a> 如何安装HelloWord</h2><p>使用CMAKE一个新的指令：INSTALL</p><p>INSTALL的安装可以包括：二进制、动态库、静态库以及文件、目录、脚本等</p><p>使用CMAKE一个新的变量：CMAKE_INSTALL_PREFIX</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 目录树结构</span></span><br><span class="line">[root@localhost cmake]<span class="meta"># tree</span></span><br><span class="line">.</span><br><span class="line">├── build</span><br><span class="line">├── CMakeLists.txt</span><br><span class="line">├── COPYRIGHT</span><br><span class="line">├── doc</span><br><span class="line">│   └── hello.txt</span><br><span class="line">├── README</span><br><span class="line">├── runhello.sh</span><br><span class="line">└── src</span><br><span class="line">    ├── CMakeLists.txt</span><br><span class="line">    └── main.cpp</span><br><span class="line"></span><br><span class="line"><span class="number">3</span> directories, <span class="number">7</span> files</span><br></pre></td></tr></table></figure><h3 id="安装文件copyright和readme"><a class="markdownIt-Anchor" href="#安装文件copyright和readme"></a> 安装文件COPYRIGHT和README</h3><p>INSTALL(FILES COPYRIGHT README DESTINATION share/doc/cmake/)</p><p>FILES：文件</p><p>DESTINATION：</p><p>1、写绝对路径</p><p>2、可以写相对路径，相对路径实际路径是：${CMAKE_INSTALL_PREFIX}/&lt;DESTINATION 定义的路径&gt;</p><p>CMAKE_INSTALL_PREFIX  默认是在 /usr/local/</p><p>cmake -DCMAKE_INSTALL_PREFIX=/usr    在cmake的时候指定CMAKE_INSTALL_PREFIX变量的路径</p><h3 id="安装脚本runhellosh"><a class="markdownIt-Anchor" href="#安装脚本runhellosh"></a> <a href="http://xn--runhello-zh5o444ghv3d9ht.sh">安装脚本runhello.sh</a></h3><p>PROGRAMS：非目标文件的可执行程序安装(比如脚本之类)</p><p>INSTALL(PROGRAMS <a href="http://runhello.sh">runhello.sh</a> DESTINATION bin)</p><p>说明：实际安装到的是 /usr/bin</p><h3 id="安装-doc-中的-hellotxt"><a class="markdownIt-Anchor" href="#安装-doc-中的-hellotxt"></a> 安装 doc 中的 hello.txt</h3><ul><li><p>一、是通过在 doc 目录建立CMakeLists.txt ，通过install下的file</p></li><li><p>二、是直接在工程目录通过</p><p>INSTALL(DIRECTORY doc/ DESTINATION share/doc/cmake)</p></li></ul><p>DIRECTORY 后面连接的是所在 Source 目录的相对路径</p><p>注意：abc 和 abc/有很大的区别</p><p>目录名不以/结尾：这个目录将被安装为目标路径下的</p><p>目录名以/结尾：将这个目录中的内容安装到目标路径</p><h3 id="安装过程"><a class="markdownIt-Anchor" href="#安装过程"></a> 安装过程</h3><p>cmake …</p><p>make</p><p>make install</p><h1 id="静态库和动态库的构建"><a class="markdownIt-Anchor" href="#静态库和动态库的构建"></a> 静态库和动态库的构建</h1><p>任务：</p><p>１，建立一个静态库和动态库，提供 HelloFunc 函数供其他程序编程使用，HelloFunc 向终端输出 Hello World 字符串。</p><p>２，安装头文件与共享库。</p><p>静态库和动态库的区别</p><ul><li>静态库的扩展名一般为“.a”或“.lib”；动态库的扩展名一般为“.so”或“.dll”。</li><li>静态库在编译时会直接整合到目标程序中，编译成功的可执行文件可独立运行</li><li>动态库在编译时不会放到连接的目标程序中，即可执行文件无法单独运行。</li></ul><h2 id="构建实例"><a class="markdownIt-Anchor" href="#构建实例"></a> 构建实例</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost cmake2]<span class="meta"># tree</span></span><br><span class="line">.</span><br><span class="line">├── build</span><br><span class="line">├── CMakeLists.txt</span><br><span class="line">└── lib</span><br><span class="line">    ├── CMakeLists.txt</span><br><span class="line">    ├── hello.cpp</span><br><span class="line">    └── hello.h</span><br></pre></td></tr></table></figure><p>hello.h中的内容</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> HELLO_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Hello_H</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">HelloFunc</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>hello.cpp中的内容</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;hello.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">HelloFunc</span><span class="params">()</span></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Hello World&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>项目中的cmake内容</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">PROJECT</span>(HELLO)</span><br><span class="line"><span class="built_in">ADD_SUBDIRECTORY</span>(lib bin)</span><br></pre></td></tr></table></figure><p>lib中CMakeLists.txt中的内容</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">SET</span>(LIBHELLO_SRC hello.cpp)</span><br><span class="line"><span class="built_in">ADD_LIBRARY</span>(hello SHARED $&#123;LIBHELLO_SRC&#125;)</span><br></pre></td></tr></table></figure><h3 id="add_library"><a class="markdownIt-Anchor" href="#add_library"></a> ADD_LIBRARY</h3><p>ADD_LIBRARY(hello SHARED ${LIBHELLO_SRC})</p><ul><li>hello：就是正常的库名，生成的名字前面会加上lib，<a href="http://xn--libhello-x80mpzv93qwwbs3dby3f9mei53b.so">最终产生的文件是libhello.so</a></li><li>SHARED，动态库    STATIC，静态库</li><li>${LIBHELLO_SRC} ：源文件</li></ul><h3 id="同时构建静态和动态库"><a class="markdownIt-Anchor" href="#同时构建静态和动态库"></a> 同时构建静态和动态库</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 如果用这种方式，只会构建一个动态库，不会构建出静态库，虽然静态库的后缀是.a</span></span><br><span class="line"><span class="built_in">ADD_LIBRARY</span>(hello SHARED $&#123;LIBHELLO_SRC&#125;)</span><br><span class="line"><span class="built_in">ADD_LIBRARY</span>(hello STATIC $&#123;LIBHELLO_SRC&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 修改静态库的名字，这样是可以的，但是我们往往希望他们的名字是相同的，只是后缀不同而已</span></span><br><span class="line"><span class="built_in">ADD_LIBRARY</span>(hello SHARED $&#123;LIBHELLO_SRC&#125;)</span><br><span class="line"><span class="built_in">ADD_LIBRARY</span>(hello_static STATIC $&#123;LIBHELLO_SRC&#125;)</span><br></pre></td></tr></table></figure><h3 id="set_target_properties"><a class="markdownIt-Anchor" href="#set_target_properties"></a> SET_TARGET_PROPERTIES</h3><p>这条指令可以用来设置输出的名称，对于动态库，还可以用来指定动态库版本和 API 版本</p><p>同时构建静态和动态库</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">SET</span>(LIBHELLO_SRC hello.cpp)</span><br><span class="line"></span><br><span class="line"><span class="built_in">ADD_LIBRARY</span>(hello_static STATIC $&#123;LIBHELLO_SRC&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">//对hello_static的重名为hello</span></span><br><span class="line"><span class="built_in">SET_TARGET_PROPERTIES</span>(hello_static PROPERTIES  OUTPUT_NAME <span class="string">&quot;hello&quot;</span>)</span><br><span class="line"><span class="comment">//cmake 在构建一个新的target 时，会尝试清理掉其他使用这个名字的库，因为，在构建 libhello.so 时， 就会清理掉 libhello.a</span></span><br><span class="line"><span class="built_in">SET_TARGET_PROPERTIES</span>(hello_static PROPERTIES CLEAN_DIRECT_OUTPUT <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">ADD_LIBRARY</span>(hello SHARED $&#123;LIBHELLO_SRC&#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">SET_TARGET_PROPERTIES</span>(hello PROPERTIES  OUTPUT_NAME <span class="string">&quot;hello&quot;</span>)</span><br><span class="line"><span class="built_in">SET_TARGET_PROPERTIES</span>(hello PROPERTIES CLEAN_DIRECT_OUTPUT <span class="number">1</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="动态库的版本号"><a class="markdownIt-Anchor" href="#动态库的版本号"></a> 动态库的版本号</h3><p>一般动态库都有一个版本号的关联</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">libhello.so<span class="number">.1</span><span class="number">.2</span></span><br><span class="line">libhello.so -&gt;libhello.so<span class="number">.1</span></span><br><span class="line">libhello.so<span class="number">.1</span>-&gt;libhello.so<span class="number">.1</span><span class="number">.2</span></span><br></pre></td></tr></table></figure><p>CMakeLists.txt 插入如下</p><p><code>SET_TARGET_PROPERTIES(hello PROPERTIES VERSION 1.2 SOVERSION 1)</code></p><p>VERSION 指代动态库版本，SOVERSION 指代 API 版本。</p><h3 id="安装共享库和头文件"><a class="markdownIt-Anchor" href="#安装共享库和头文件"></a> 安装共享库和头文件</h3><p>本例中我们将 hello 的共享库安装到<prefix>/lib目录，</p><p>将 hello.h 安装到<prefix>/include/hello 目录</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//文件放到该目录下</span></span><br><span class="line"><span class="built_in">INSTALL</span>(FILES hello.h DESTINATION include/hello)</span><br><span class="line"></span><br><span class="line"><span class="comment">//二进制，静态库，动态库安装都用TARGETS</span></span><br><span class="line"><span class="comment">//ARCHIVE 特指静态库，LIBRARY 特指动态库，RUNTIME 特指可执行目标二进制。</span></span><br><span class="line"><span class="built_in">INSTALL</span>(TARGETS hello hello_static LIBRARY DESTINATION lib ARCHIVE DESTINATION lib)</span><br></pre></td></tr></table></figure><p>注意：</p><p>安装的时候，指定一下路径，放到系统下</p><p><code>cmake -DCMAKE_INSTALL_PREFIX=/usr ..</code></p><h3 id="使用外部共享库和头文件"><a class="markdownIt-Anchor" href="#使用外部共享库和头文件"></a> 使用外部共享库和头文件</h3><p>准备工作，新建一个目录来使用外部共享库和头文件</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@MiWiFi-R4CM-srv cmake3]<span class="meta"># tree</span></span><br><span class="line">.</span><br><span class="line">├── build</span><br><span class="line">├── CMakeLists.txt</span><br><span class="line">└── src</span><br><span class="line">    ├── CMakeLists.txt</span><br><span class="line">    └── main.cpp</span><br></pre></td></tr></table></figure><p>main.cpp</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;hello.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">HelloFunc</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="解决make后头文件找不到的问题"><a class="markdownIt-Anchor" href="#解决make后头文件找不到的问题"></a> 解决：make后头文件找不到的问题</h3><p>PS：include &lt;hello/hello.h&gt;  这样include是可以，这么做的话，就没啥好讲的了</p><p>关键字：INCLUDE_DIRECTORIES    这条指令可以用来向工程添加多个特定的头文件搜索路径，路径之间用空格分割</p><p>在CMakeLists.txt中加入头文件搜索路径</p><p>INCLUDE_DIRECTORIES(/usr/include/hello)</p><h3 id="解决找到引用的函数问题"><a class="markdownIt-Anchor" href="#解决找到引用的函数问题"></a> 解决：找到引用的函数问题</h3><p>报错信息：undefined reference to `HelloFunc()’</p><p>关键字：LINK_DIRECTORIES     添加非标准的共享库搜索路径</p><p>指定第三方库所在路径，LINK_DIRECTORIES(/home/myproject/libs)</p><p>关键字：TARGET_LINK_LIBRARIES    添加需要链接的共享库</p><p>TARGET_LINK_LIBRARIES的时候，只需要给出动态链接库的名字就行了。</p><p>在CMakeLists.txt中插入链接共享库，主要要插在executable的后面</p><p>查看main的链接情况</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[root@MiWiFi-R4CM-srv bin]<span class="meta"># ldd main </span></span><br><span class="line">linux-vdso.so<span class="number">.1</span> =&gt;  (<span class="number">0x00007ffedfda4000</span>)</span><br><span class="line">libhello.so =&gt; /lib64/libhello.<span class="built_in">so</span> (<span class="number">0x00007f41c0d8f000</span>)</span><br><span class="line">libstdc++.so<span class="number">.6</span> =&gt; /lib64/libstdc++.so<span class="number">.6</span> (<span class="number">0x00007f41c0874000</span>)</span><br><span class="line">libm.so<span class="number">.6</span> =&gt; /lib64/libm.so<span class="number">.6</span> (<span class="number">0x00007f41c0572000</span>)</span><br><span class="line">libgcc_s.so<span class="number">.1</span> =&gt; /lib64/libgcc_s.so<span class="number">.1</span> (<span class="number">0x00007f41c035c000</span>)</span><br><span class="line">libc.so<span class="number">.6</span> =&gt; /lib64/libc.so<span class="number">.6</span> (<span class="number">0x00007f41bff8e000</span>)</span><br><span class="line">/lib64/ld-linux-x86<span class="number">-64.</span>so<span class="number">.2</span> (<span class="number">0x00007f41c0b7c000</span>)</span><br></pre></td></tr></table></figure><p>链接静态库</p><p><code>TARGET_LINK_LIBRARIES(main libhello.a)</code></p><h3 id="特殊的环境变量-cmake_include_path-和-cmake_library_path"><a class="markdownIt-Anchor" href="#特殊的环境变量-cmake_include_path-和-cmake_library_path"></a> 特殊的环境变量 CMAKE_INCLUDE_PATH 和 CMAKE_LIBRARY_PATH</h3><p>注意：这两个是环境变量而不是 cmake 变量，可以在linux的bash中进行设置</p><p>我们上面例子中使用了绝对路径INCLUDE_DIRECTORIES(/usr/include/hello)来指明include路径的位置</p><p>我们还可以使用另外一种方式，使用环境变量export CMAKE_INCLUDE_PATH=/usr/include/hello</p><p>补充：生产debug版本的方法：<br />cmake … -DCMAKE_BUILD_TYPE=debug</p>]]></content>
    
    
    <summary type="html">cmake学习笔记，真好用真好用:-)</summary>
    
    
    
    <category term="linux" scheme="http://aflyingsheep.github.io/categories/linux/"/>
    
    
    <category term="C++" scheme="http://aflyingsheep.github.io/tags/C/"/>
    
    <category term="linux" scheme="http://aflyingsheep.github.io/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>C++：模板类和静态成员变量</title>
    <link href="http://aflyingsheep.github.io/2023/01/08/cpp/template_and_static/"/>
    <id>http://aflyingsheep.github.io/2023/01/08/cpp/template_and_static/</id>
    <published>2023-01-08T08:57:06.000Z</published>
    <updated>2023-02-11T13:10:34.737Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="c-模板类和静态成员变量"><a class="markdownIt-Anchor" href="#c-模板类和静态成员变量"></a> C++ 模板类和静态成员变量</h1><p>当一个模板类产生不同的类时，<strong>每个类产生的对象共享static变量</strong>，静态成员变量作用于类层面。即类间不共享，类内共享。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> size_type&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">hello</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> s_a;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">()</span> </span>&#123;</span><br><span class="line">s_a++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;; </span><br><span class="line"></span><br><span class="line"><span class="comment">// 模板类中静态变量的定义</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">size_type</span>&gt;</span> <span class="keyword">int</span> hello&lt;size_type&gt;::s_a = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">hello&lt;<span class="keyword">int</span>&gt; h3;</span><br><span class="line">hello&lt;<span class="keyword">char</span>&gt; h4; </span><br><span class="line"></span><br><span class="line">h3.<span class="built_in">add</span>();</span><br><span class="line">h4.<span class="built_in">add</span>();</span><br><span class="line">h4.<span class="built_in">add</span>();</span><br><span class="line"></span><br><span class="line">std::cout &lt;&lt; hello&lt;<span class="keyword">int</span>&gt;::s_a &lt;&lt; std::endl;</span><br><span class="line">std::cout &lt;&lt; hello&lt;<span class="keyword">char</span>&gt;::s_a &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    out:</span></span><br><span class="line"><span class="comment">    1</span></span><br><span class="line"><span class="comment">    2</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">当一个模板类产生不同的类时，每个类产生的对象共享static变量，静态成员变量作用于类层面</summary>
    
    
    
    <category term="C++" scheme="http://aflyingsheep.github.io/categories/C/"/>
    
    
    <category term="C++" scheme="http://aflyingsheep.github.io/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>C++杂谈笔记</title>
    <link href="http://aflyingsheep.github.io/2023/01/05/cpp/%E6%9D%82%E7%83%A9/"/>
    <id>http://aflyingsheep.github.io/2023/01/05/cpp/%E6%9D%82%E7%83%A9/</id>
    <published>2023-01-05T13:27:06.000Z</published>
    <updated>2023-02-11T13:08:54.894Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><strong>左值和右值</strong></p><p>左值的英文简写为“lvalue”，右值的英文简写为“rvalue”。很多人认为它们分别是&quot;left value&quot;、“right value” 的缩写，其实不然。lvalue 是“loactor value”的缩写，可意为存储在内存中、有明确存储地址（可寻址）的数据，而 rvalue 译为 “read value”，指的是那些可以提供数据值的数据（不一定可以寻址，例如存储于寄存器中的数据）。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 左值引用</span></span><br><span class="line"><span class="keyword">int</span> num = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> &amp;b = num;     <span class="comment">// 正确</span></span><br><span class="line"><span class="keyword">int</span> &amp;c = <span class="number">10</span>;      <span class="comment">// 错误</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">int</span> num = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> &amp;b = num;   <span class="comment">// 正确</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> &amp;c = <span class="number">10</span>;    <span class="comment">// 正确</span></span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="comment">// 右值引用</span></span><br><span class="line"><span class="keyword">int</span> num = <span class="number">10</span>;</span><br><span class="line"><span class="comment">//int &amp;&amp; a = num;    // 错误，右值引用不能初始化为左值</span></span><br><span class="line"><span class="keyword">int</span> &amp;&amp; a = <span class="number">10</span>;       <span class="comment">// 正确</span></span><br><span class="line"> </span><br><span class="line">a = <span class="number">100</span>;</span><br><span class="line">cout &lt;&lt; a &lt;&lt; endl;   <span class="comment">// 输出为100，右值引用可以修改值</span></span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="comment">// 右值引用的使用</span></span><br><span class="line"><span class="comment">// 如 thread argv 的传入</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Callable, <span class="keyword">typename</span>... _Args&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">explicit</span> <span class="title">thread</span><span class="params">(_Callable&amp;&amp; __f, _Args&amp;&amp;... __args)</span> </span>&#123; </span><br><span class="line"><span class="comment">//.... </span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Args&amp;&amp;... args 是对函数参数的类型 Args&amp;&amp; 进行展开</span></span><br><span class="line"><span class="comment">// args... 是对函数参数 args 进行展开</span></span><br><span class="line"><span class="comment">// explicit 只对构造函数起作用，用来抑制隐式转换</span></span><br></pre></td></tr></table></figure><p><a href="https://blog.csdn.net/TABE_/article/details/122609775">(2条消息) C++ 左值和右值_TABE_的博客-CSDN博客_左值和右值</a></p><p>讲的非常好</p><p><strong>可变参数</strong></p><p><a href="https://blog.csdn.net/wodownload2/article/details/117512062">(2条消息) C<ins>中可变参数…args_wodownload2的博客-CSDN博客_c</ins> args…</a></p><p><a href="https://blog.csdn.net/chenlong_cxy/article/details/126807356">(2条消息) C<ins>11 ——— 可变参数模板_2021dragon的博客-CSDN博客_c</ins>11 可变参数模板</a></p><p><a href="https://blog.csdn.net/f110300641/article/details/83477160">(2条消息) 理解std::move和std::forward_土戈的博客-CSDN博客_std::forward</a></p><p>C++ move &amp;&amp; forward</p><p><strong>std::move</strong></p><p>c++11中提供了std::move()来将左值转换为右值引用，从而方便的使用移动语义。move是将对象的状态或者所有权从一个对象转移到另一个对象，只是转移，没有内存拷贝。</p><p>c++中所有容器都实现了move语义，方便我们实现性能优化。move对于拥有形如对内存、文件句柄等资源的成员的对象有效。如果是一些基本类型，比如int或char[10]数组等，如果使用move，仍然会发生拷贝（因为没有对应的移动构造函数）。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">std::list&lt;std::string&gt; tokens;</span><br><span class="line"><span class="comment">// 发生了移动构造。list的实现，将目的资源句柄赋值为源资源句柄，而将源资源句柄清空</span></span><br><span class="line">std::list&lt;std::string&gt; t = std::<span class="built_in">move</span>(tokens);</span><br></pre></td></tr></table></figure><p><strong>std::forward</strong></p><p>右值引用类型是独立于值的，一个右值引用参数作为函数的形参，在函数内部再转发该参数的时候它已经变成一个左值，并不是他原来的类型。</p><p>需要一种方法能够按照参数原来的类型转发到另一个函数，这种转发类型称为<strong>完美转发</strong>。</p><p>完美转发（Perfect Forwarding），是指在函数模板中，完全依照模板的参数的类型（即保持参数的左值、右值特征），将参数传递给函数模板中调用的另外一个函数。C++11中提供了这样的一个函数std::forward，它是为转发而生的，不管参数是T&amp;&amp;这种未定的引用还是明确的左值引用或者右值引用，它会按照参数本来的类型转发。</p><p><strong>tuple</strong></p><p><a href="https://blog.csdn.net/sinat_31608641/article/details/123315773">(2条消息) C<ins>的tuple_物随心转的博客-CSDN博客_c</ins> tuple</a></p><p><strong>C++模板 - index_sequence</strong></p><p><a href="https://blog.csdn.net/qq_51986723/article/details/127602490">(2条消息) C++模板 - index_sequence_AMjieker的博客-CSDN博客_std::index_sequence</a></p><p>// vector.reserve() 更改vector的容量（capacity），使vector至少可以容纳n个元素。</p><p>// 如果n大于vector当前的容量，reserve会对vector进行扩容。其他情况下都不会重新分配vector的存储空间</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="C++" scheme="http://aflyingsheep.github.io/categories/C/"/>
    
    
    <category term="C++" scheme="http://aflyingsheep.github.io/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>Codelet调度模型与Swdarts</title>
    <link href="http://aflyingsheep.github.io/2022/12/31/science_research/Codelet/"/>
    <id>http://aflyingsheep.github.io/2022/12/31/science_research/Codelet/</id>
    <published>2022-12-31T10:27:06.000Z</published>
    <updated>2023-02-11T13:11:54.313Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="codelet程序执行模型"><a class="markdownIt-Anchor" href="#codelet程序执行模型"></a> Codelet程序执行模型</h1><h2 id="基本单元"><a class="markdownIt-Anchor" href="#基本单元"></a> 基本单元</h2><ul><li>codelet程序执行模型的基本调度和执行单元</li><li>一个codelet是一些机器指令的集合（代码片段）</li><li>codelet一旦开始执行，不会被中断或迁移</li><li>codelet中不包括延迟时间长或等待的操作</li><li>codelet间异步、并发，产生若干token(数据)作为输出</li></ul><h2 id="激发规则"><a class="markdownIt-Anchor" href="#激发规则"></a> 激发规则</h2><ol><li>休眠状态：数据依赖未满足</li><li>就绪状态：数据依赖满足</li><li>激发状态：有空闲的计算单元且事件依赖被满足</li><li>完成状态：完成计算</li></ol><h2 id="codelet-graph"><a class="markdownIt-Anchor" href="#codelet-graph"></a> Codelet Graph</h2><p>计算任务被划分成大量的codelet, 这些codelet及其依赖关系构成一张数据流图，称位Codelet Graph(CDG)。CDG是一个有向无环图。</p><p>CDG被划分为一个个子图，每个子图被分配一个Threaded Procedure（TP），由TP对其调度和执行。</p><h2 id="threaded-procedure"><a class="markdownIt-Anchor" href="#threaded-procedure"></a> Threaded Procedure</h2><p>TP是异步的函数，以控制流的方式被调用，包括一个<strong>上下文框架</strong>和<strong>CDG子图</strong>。</p><ul><li>上下文框架：为CDG中的codelet提供所需所有数据操作服务（初始化输入数据、为中间数据分配和释放空间、输出数据分配空间）</li><li>TP被实例化后，绑定到一个核簇（cluster）上。TP的CDG子图中所有codelet被分配给该cluster调度执行。</li><li>TP被实例化之前可以在cluster间迁移，以进行负载平衡。一旦被分配给一个cluster后，TP便不可移动。</li></ul><h2 id="抽象机器模型"><a class="markdownIt-Anchor" href="#抽象机器模型"></a> 抽象机器模型</h2><p>抽象机器系统由若干计算节点（node）构成，计算节点以互联网络连接。每个计算节点由一个或者多个many-core chip构成，节点内chip以高速开关或总线互联。</p><p>Chip上的cluster以片上网络互联，每个cluster上有多个core。core分为计算单元（CU）和调度单元（SU）。CU负责执行codelet，SU负责：(1) 管理cluster所有硬件资源 (2) 在cluster间调度TP (3) 将处于就绪态的codelet依据一定调度策略给合适的CU执行。</p><p><img src="/image/codelet/1.png" alt="1" /></p><h1 id="swdarts"><a class="markdownIt-Anchor" href="#swdarts"></a> Swdarts</h1><h2 id="抽象机器模型-2"><a class="markdownIt-Anchor" href="#抽象机器模型-2"></a> 抽象机器模型</h2><p>为了利用申威众核异构平台，需要将Codelet抽象机器模型映射到国产异构众核平台上。</p><ul><li>核组即可映射为Codelet抽象机器模型中的cluster，包含两种不同功能的core：<ul><li>主核：调度单元，负责任务分配和调度</li><li>从核：计算单元，负责任务计算</li></ul></li></ul><p><img src="/image/codelet/2.png" alt="2" /></p><h2 id="runtime-system设计与实现"><a class="markdownIt-Anchor" href="#runtime-system设计与实现"></a> Runtime system设计与实现</h2><p>Runtime system主要负责任务的分配调度和任务间通信，是核心组件。</p><p>整个系统分为两层：</p><ul><li>用户层：提供给用户描述、生成、调度可执行任务的接口，<strong>用户通过所提供接口</strong>对应用程序进行<strong>数据流风格的抽象</strong>，并使用接口将可执行任务交给下一层</li><li>运行时执行层：负责将以满足数据依赖关系的计算任务分配给空闲的硬件资源<ul><li>设置了任务队列，入队的任务表示依赖关系已经满足</li></ul></li></ul><h3 id="前端接口设计"><a class="markdownIt-Anchor" href="#前端接口设计"></a> 前端接口设计</h3><ol><li>Task类：所有任务的抽象基类<ul><li>主要包括计算任务需要的上下文数据、可并行的计算任务、任务之间的数据依赖（CDG子图）</li><li>对应Codelet中的TP</li><li>可以发起生成一段可以并行执行的tasklet和task任务</li><li>需要维护任务之间的链接关系来维护上下文数据的生命周期<ul><li>execute(): task的执行函数，函数中可以做计算，也可以启动其他并行任务(task, tasklet)，再次声明任务之间的依赖关系</li><li>invoke(task) 启动并行执行的task任务</li><li>spawn_task(task_ptr) 将满足依赖关系的task任务放到任务队列中</li></ul></li></ul></li><li>Tasklet类：对应codelet，是运行时系统中的基本执行和调度单元<ul><li>tasklet无需维护上下文数据，只需管理tasklet任务间的依赖关系</li><li>tasklet组成：依赖计数、执行函数、通知函数<ul><li>spawn_tasklet(tasklet_ptr): 将tasklet放入tasklet队列中</li><li>release(): 释放tasklet的依赖计数，当计数为0时，调用spawn_tasklet()函数</li><li>execute(): 执行函数，执行过程调用激发函数，通过上述函数声明tasklet之间的依赖关系（？？）</li><li>can_spawn_on_cpe(): 表示tasklet在主核上还是从核上执行</li></ul></li></ul></li><li>enable_cpe_spawn类：与tasklet类基本相同，定义为可以在从核上运行的代码，只有执行函数<ul><li>创建该类原因：tasklet或enable_cpe_spawn依赖计数减为0时，被放入任务队列。依赖计数操作和通知操作会放在主核上执行，但是从核如果可以依赖计数操作和通知操作，需要对主核队列进行读写原子操作，代价大、成本高。<ul><li>spawn__(): 主从核之间的任务传递，并在从核上执行计算任务</li></ul></li></ul></li><li>Runtime类：要负责任务的调度和执行，以及判断tasklet任务是否可以放到从核上执行，由用户声明。<ul><li>make_tasklet(): 用于将函数定义或转换为tasklet</li><li>execute_and_wait(): 用于启动运行时系统和定义运行时系统停止的条件，并将数据流抽象化的应用交给运行时系统。</li><li>launch(Args…): 用户构造task时，通过launch()函数将任务需要的上下文传递给task</li></ul></li></ol><h3 id="运行时系统设计"><a class="markdownIt-Anchor" href="#运行时系统设计"></a> 运行时系统设计</h3><p>运行时系统：负责任务分配调度和执行；负责启动、管理从核</p><ul><li>给从核队列中每个从核设置三种状态：初始化、空闲和繁忙</li><li>从核完成tasklet计算任务后，主核完成tasklet的通知任务，并将满足数据依赖的任务push到对应任务队列中</li><li>循环检查task任务队列，将队首任务取出并执行；循环检查tasklet任务队列，将队首tasklet根据用户声明交给主核或从核执行</li></ul><p>运行时系统执行流程：</p><ol><li>用户完成应用的数据流化抽象，通过接口交给运行时系统</li><li>将满足依赖关系的任务放入任务队列</li><li>查询从核阵列状态，如果有空间资源，将任务分配计算</li><li>从核计算完成，改变对应从核状态</li></ol><p><img src="/image/codelet/3.png" alt="3" /></p><h3 id="继承关系"><a class="markdownIt-Anchor" href="#继承关系"></a> 继承关系</h3><ul><li>std::enable_shared_from_this&lt;task&gt;<ul><li>task<ul><li>tasklet<ul><li>mem_fn_tasklet</li></ul></li><li>task_context</li></ul></li></ul></li></ul>]]></content>
    
    
    <summary type="html">Codelet是一种针对E级计算机的需求而进行设计的细粒度并行、事件驱动的程序执行模型。</summary>
    
    
    
    <category term="HPC" scheme="http://aflyingsheep.github.io/categories/HPC/"/>
    
    
    <category term="HPC" scheme="http://aflyingsheep.github.io/tags/HPC/"/>
    
  </entry>
  
  <entry>
    <title>C++智能指针：shared_ptr</title>
    <link href="http://aflyingsheep.github.io/2022/12/12/cpp/shared_pointer/"/>
    <id>http://aflyingsheep.github.io/2022/12/12/cpp/shared_pointer/</id>
    <published>2022-12-12T13:22:06.000Z</published>
    <updated>2023-02-11T13:16:32.235Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>使用raw pointer管理动态内存出现的问题：</p><ol><li>忘记delete内存，造成内存泄露；</li><li>抛出异常时，无法执行delete，造成内存泄漏。</li></ol><h1 id="智能指针shared_ptrの原理"><a class="markdownIt-Anchor" href="#智能指针shared_ptrの原理"></a> 智能指针shared_ptrの原理</h1><p>shared_ptr是最常用的C++11提供的智能指针。shared_ptr采用了引用计数器，多个shared_ptr中的T *ptr指向同一个内存区域（同一个对象），并<strong>共同维护同一个引用计数器</strong>。shared_ptr定义如下，记录同一个实例被引用的次数，当引用次数大于0时可用，等于0时释放内存。</p><p>从而可以在任何地方都不使用时自动删除相关指针，从而帮助彻底消除内存泄漏和悬空指针的问题。</p><p>每个 shared_ptr 对象在内部维护着两个内存位置：</p><ol><li><strong>指向对象</strong>的指针。</li><li>用于<strong>控制引用计数数据</strong>的指针。</li></ol><ul><li><p><strong>共享所有权如何在参考计数的帮助下工作的？</strong></p><ol><li><p>当新的 shared_ptr 对象与指针关联时，则在其构造函数中，将与此指针关联的引用计数增加1。</p></li><li><p>当任何 shared_ptr 对象超出作用域时，则在其析构函数中，它将关联指针的引用计数减1。如果引用计数变为0，则表</p><p>示没有其他 shared_ptr 对象与此内存关联，在这种情况下，它使用delete函数删除该内存。</p></li></ol></li><li><p><strong>注意避免循环引用</strong>，shared_ptr的一个最大的陷阱是循环引用，循环，循环引用会导致堆内存无法正确释放，导致内存泄漏。循环引用在weak_ptr中介绍。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">temple&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SharedPtr</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">   ...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T *_ptr;</span><br><span class="line">    <span class="keyword">int</span> *_refCount;     <span class="comment">//should be int*, rather than int</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><p>一、 构造函数与析构函数</p><ol><li><p>shared_ptr对象每次离开作用域时会自动调用析构函数，而析构函数并不像其他类的析构函数一样，而是在释放内存是先判断引用计数器是否为0。等于0才做delete操作，否则只对引用计数器左减一操作。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">~<span class="built_in">SharedPtr</span>() &#123;</span><br><span class="line">    <span class="keyword">if</span> (_ptr &amp;&amp; --*_refCount == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">delete</span> _ptr;</span><br><span class="line">        <span class="keyword">delete</span> _refCount;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>构造函数：<strong>默认构造函数的引用计数器为0，ptr指向NULL</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">SharedPtr</span>() : _ptr((T *)<span class="number">0</span>), _refCount(<span class="number">0</span>) &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>用<strong>普通指针初始化智能指针时，引用计数器初始化为1</strong>：</p><p>创建空的 shared_ptr 对象</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">explicit</span> <span class="title">SharedPtr</span><span class="params">(T *obj)</span> : _ptr(obj), _refCount(new int(<span class="number">1</span>)) &#123;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 这里无法防止循环引用，若我们用同一个普通指针去初始化两个shared_ptr，</span></span><br><span class="line"><span class="comment">// 此时两个ptr均指向同一片内存区域，但是引用计数器均为1，使用时需要注意</span></span><br></pre></td></tr></table></figure><p>因为带有参数的 shared_ptr 构造函数是 explicit 类型的，所以不能像这样<code>std::shared_ptr&lt;int&gt; p1 = new int();</code>隐式调用它构造函数。创建新的shared_ptr对象的最佳方法是使用<code>std :: make_shared</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::shared_ptr&lt;<span class="keyword">int</span>&gt; p1 = std::make_shared&lt;<span class="keyword">int</span>&gt;();</span><br></pre></td></tr></table></figure><p><strong>std::make_shared</strong> 一次性为<code>int</code>对象和用于引用计数的数据都分配了内存，而<code>new</code>操作符只是为<code>int</code>分配了内存。</p></li><li><p><strong>拷贝构造函数</strong>需要注意，用一个shared_ptr对象去初始化另一个shared_ptr对象时，<strong>引用计数器加一，并指向同一片内存区域</strong>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">SharedPtr</span>(SharedPtr &amp;other) : _ptr(other._ptr), _refCount(&amp;(++*other._refCount)) &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="5"><li>赋值运算符的重载</li></ol><p>当用一个shared_ptr<T> other去给另一个 shared_ptr<T> sp赋值时，发生了两件事情：</p><ul><li><p>sp指针指向发生变化，不再指向之前的内存区域，所以赋值前原来的_refCount要自减</p></li><li><p>sp指针指向other.ptr，所以other的引用计数器_refCount要做++操作。</p></li></ul> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">SharedPtr &amp;<span class="keyword">operator</span>=(SharedPtr &amp;other) &#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">this</span>==&amp;other)</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line"> </span><br><span class="line">    ++*other._refCount;</span><br><span class="line">    <span class="keyword">if</span> (--*_refCount == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">delete</span> _ptr;</span><br><span class="line">        <span class="keyword">delete</span> _refCount;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    _ptr = other._ptr;</span><br><span class="line">    _refCount = other._refCount;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>二、 自定义运算符</p><ol><li><p>定义解引用运算符，直接返回底层指针的引用：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">T &amp;<span class="keyword">operator</span>*() &#123;</span><br><span class="line">    <span class="keyword">if</span> (_refCount == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> (T*)<span class="number">0</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> *_ptr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>定义指针运算符-&gt;</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">T *<span class="keyword">operator</span>-&gt;() &#123;</span><br><span class="line">    <span class="keyword">if</span>(_refCount == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> _ptr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h1 id="shared_ptr-使用の注意事项"><a class="markdownIt-Anchor" href="#shared_ptr-使用の注意事项"></a> shared_ptr 使用の注意事项</h1><ol><li><p><strong>缺少<code>++，––, [] </code>运算符，仅提供 <code>--&gt;, *, ==</code>运算符。</strong></p></li><li><p><strong>NULL检测</strong></p><p>当我们创建 shared_ptr 对象而不分配任何值时，它就是空的；普通指针不分配空间的时候相当于一个野指针，指向垃圾空间，且无法判断指向的是否是有用数据。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">std::shared_ptr&lt;Sample&gt; ptr3;</span><br><span class="line"><span class="keyword">if</span>(!ptr3)</span><br><span class="line">std::cout&lt;&lt;<span class="string">&quot;Yes, ptr3 is empty&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"><span class="keyword">if</span>(ptr3 == <span class="literal">NULL</span>)</span><br><span class="line">std::cout&lt;&lt;<span class="string">&quot;ptr3 is empty&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"><span class="keyword">if</span>(ptr3 == <span class="literal">nullptr</span>)</span><br><span class="line">std::cout&lt;&lt;<span class="string">&quot;ptr3 is empty&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">输出结果：</span></span><br><span class="line"><span class="comment">Yes, ptr3 is empty</span></span><br><span class="line"><span class="comment">ptr3 is empty</span></span><br><span class="line"><span class="comment">ptr3 is empty</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></li><li><p><strong>创建 shared_ptr 的注意事项</strong></p><p><strong>不要使用同一个原始指针构造 shared_ptr</strong></p><p>创建多个 shared_ptr 的正常方法是使用一个已存在的shared_ptr 进行创建，而不是使用同一个原始指针进行创建。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> *num = <span class="keyword">new</span> <span class="built_in"><span class="keyword">int</span></span>(<span class="number">23</span>);</span><br><span class="line"><span class="function">std::shared_ptr&lt;<span class="keyword">int</span>&gt; <span class="title">p1</span><span class="params">(num)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">std::shared_ptr&lt;<span class="keyword">int</span>&gt; <span class="title">p2</span><span class="params">(p1)</span></span>;  <span class="comment">// 正确使用方法</span></span><br><span class="line"><span class="function">std::shared_ptr&lt;<span class="keyword">int</span>&gt; <span class="title">p3</span><span class="params">(num)</span></span>; <span class="comment">// 不推荐</span></span><br><span class="line"></span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;p1 Reference = &quot;</span> &lt;&lt; p1.<span class="built_in">use_count</span>() &lt;&lt; std::endl; <span class="comment">// 输出 2</span></span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;p2 Reference = &quot;</span> &lt;&lt; p2.<span class="built_in">use_count</span>() &lt;&lt; std::endl; <span class="comment">// 输出 2</span></span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;p3 Reference = &quot;</span> &lt;&lt; p3.<span class="built_in">use_count</span>() &lt;&lt; std::endl; <span class="comment">// 输出 1</span></span><br></pre></td></tr></table></figure><p>假如使用原始指针<code>num</code>创建了p1，又同样方法创建了p3，当p1超出作用域时会调用<code>delete</code>释放<code>num</code>内存，此时num成了悬空指针，当p3超出作用域再次<code>delete</code>的时候就可能会出错。</p></li><li><p><strong>不要用栈中的指针构造 shared_ptr 对象</strong></p><p>shared_ptr 默认的构造函数中使用的是<code>delete</code>来删除关联的指针，所以构造的时候也必须使用<code>new</code>出来的堆空间的指针。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;memory&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">int</span> x = <span class="number">12</span>;</span><br><span class="line">   <span class="function">std::shared_ptr&lt;<span class="keyword">int</span>&gt; <span class="title">ptr</span><span class="params">(&amp;x)</span></span>;</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当 shared_ptr 对象超出作用域调用析构函数<code>delete</code> 指针<code>&amp;x</code>时会出错。</p></li><li><p><strong>建议使用 make_shared</strong></p><p>为了避免以上两种情形，建议使用<code>make_shared()&lt;&gt;</code>创建 shared_ptr 对象，而不是使用默认构造函数创建。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">std::shared_ptr&lt;<span class="keyword">int</span>&gt; ptr_1 = make_shared&lt;<span class="keyword">int</span>&gt;();</span><br><span class="line"><span class="function">std::shared_ptr&lt;<span class="keyword">int</span>&gt; <span class="title">ptr_2</span> <span class="params">(ptr_1)</span></span>;</span><br></pre></td></tr></table></figure><p>另外不建议使用<code>get()</code>函数获取 shared_ptr 关联的原始指针，因为如果在 shared_ptr 析构之前手动调用了<code>delete</code>函数，同样会导致类似的错误。</p></li></ol>]]></content>
    
    
    <summary type="html">C++引入智能指针，可用于动态资源管理，资源即对象的管理策略。</summary>
    
    
    
    <category term="CS" scheme="http://aflyingsheep.github.io/categories/CS/"/>
    
    
    <category term="CS" scheme="http://aflyingsheep.github.io/tags/CS/"/>
    
    <category term="C/C++" scheme="http://aflyingsheep.github.io/tags/C-C/"/>
    
  </entry>
  
  <entry>
    <title>C++：explicit</title>
    <link href="http://aflyingsheep.github.io/2022/12/12/cpp/explicit/"/>
    <id>http://aflyingsheep.github.io/2022/12/12/cpp/explicit/</id>
    <published>2022-12-12T13:21:06.000Z</published>
    <updated>2023-02-11T13:20:19.730Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="cexplicit关键字详解"><a class="markdownIt-Anchor" href="#cexplicit关键字详解"></a> C++explicit关键字详解</h1><p>C++中的explicit关键字只能用于<strong>修饰只有一个参数的类构造函数</strong>，它的作用是<strong>表明该构造函数是显式的, 而非隐式的</strong>，跟它相对应的另一个关键字是implicit，意思是隐藏的，<strong>类构造函数默认情况下即声明为implicit(隐式)</strong>。</p><p>下面是显式声明与隐式声明构造函数的区别例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CxString</span>  // 没有使用<span class="title">explicit</span>关键字的类声明, 即默认为隐式声明  </span></span><br><span class="line"><span class="class">&#123;</span>  </span><br><span class="line"><span class="keyword">public</span>:  </span><br><span class="line">    <span class="keyword">char</span> *_pstr;  </span><br><span class="line">    <span class="keyword">int</span> _size;  </span><br><span class="line">    <span class="built_in">CxString</span>(<span class="keyword">int</span> size)  </span><br><span class="line">    &#123;  </span><br><span class="line">        _size = size;                <span class="comment">// string的预设大小  </span></span><br><span class="line">        _pstr = <span class="built_in">malloc</span>(size + <span class="number">1</span>);    <span class="comment">// 分配string的内存  </span></span><br><span class="line">        <span class="built_in">memset</span>(_pstr, <span class="number">0</span>, size + <span class="number">1</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="built_in">CxString</span>(<span class="keyword">const</span> <span class="keyword">char</span> *p)  </span><br><span class="line">    &#123;  </span><br><span class="line">        <span class="keyword">int</span> size = <span class="built_in">strlen</span>(p);  </span><br><span class="line">        _pstr = <span class="built_in">malloc</span>(size + <span class="number">1</span>);    <span class="comment">// 分配string的内存  </span></span><br><span class="line">        <span class="built_in">strcpy</span>(_pstr, p);            <span class="comment">// 复制字符串  </span></span><br><span class="line">        _size = <span class="built_in">strlen</span>(_pstr);  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="comment">// 析构函数这里不讨论, 省略...  </span></span><br><span class="line">&#125;;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 下面是调用:  </span></span><br><span class="line">  </span><br><span class="line">    <span class="function">CxString <span class="title">string1</span><span class="params">(<span class="number">24</span>)</span></span>;     <span class="comment">// 这样是OK的, 为CxString预分配24字节的大小的内存  </span></span><br><span class="line">    CxString string2 = <span class="number">10</span>;    <span class="comment">// 这样是OK的, 为CxString预分配10字节的大小的内存  </span></span><br><span class="line">    CxString string3;         <span class="comment">// 这样是不行的, 因为没有默认构造函数, 错误为: &quot;CxString&quot;: 没有合适的默认构造函数可用  </span></span><br><span class="line">    <span class="function">CxString <span class="title">string4</span><span class="params">(<span class="string">&quot;aaaa&quot;</span>)</span></span>; <span class="comment">// 这样是OK的  </span></span><br><span class="line">    CxString string5 = <span class="string">&quot;bbb&quot;</span>; <span class="comment">// 这样也是OK的, 调用的是CxString(const char *p)  </span></span><br><span class="line">    CxString string6 = <span class="string">&#x27;c&#x27;</span>;   <span class="comment">// 这样也是OK的, 其实调用的是CxString(int size), 且size等于&#x27;c&#x27;的ascii码  </span></span><br><span class="line">    string1 = <span class="number">2</span>;              <span class="comment">// 这样也是OK的, 为CxString预分配2字节的大小的内存  </span></span><br><span class="line">    string2 = <span class="number">3</span>;              <span class="comment">// 这样也是OK的, 为CxString预分配3字节的大小的内存  </span></span><br><span class="line">    string3 = string1;        <span class="comment">// 这样也是OK的, 至少编译是没问题的, 但是如果析构函数里用</span></span><br></pre></td></tr></table></figure><p>free释放_pstr内存指针的时候可能会报错，完整的代码必须重载运算符&quot;=&quot;，并在其中处理内存释放。</p><p><strong>&quot;CxString string2 = 10;&quot;这句为什么是可以的呢?</strong></p><p>在C++中, 如果的<strong>构造函数只有一个参数时</strong>，那么在编译的时候就会有一个<strong>缺省的转换操作</strong>：将该构造函数对应数据类型的数据转换为该类对象。也就是说&quot;CxString string2 = 10;&quot;这段代码，<strong>编译器自动将整型转换为CxString类对象</strong>, 实际上等同于下面的操作：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">CxString <span class="title">string2</span><span class="params">(<span class="number">10</span>)</span></span>;  </span><br><span class="line"></span><br><span class="line"><span class="comment">// 或者</span></span><br><span class="line"><span class="function">CxString <span class="title">temp</span><span class="params">(<span class="number">10</span>)</span></span>;  </span><br><span class="line">CxString string2 = temp; </span><br></pre></td></tr></table></figure><p>但是, 上面的代码中的_size代表的是字符串内存分配的大小，那么调用的第二句 &quot;CxString string2 = 10;&quot;和第六句 “CxString string6 = ‘c’;” 就显得不伦不类，而且容易让人疑惑。有什么办法阻止这种用法呢？答案就是使用explicit关键字。我们把上面的代码修改一下，如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CxString</span>  // 使用关键字<span class="title">explicit</span>的类声明, 显示转换  </span></span><br><span class="line"><span class="class">&#123;</span>  </span><br><span class="line"><span class="keyword">public</span>:  </span><br><span class="line">    <span class="keyword">char</span> *_pstr;  </span><br><span class="line">    <span class="keyword">int</span> _size;  </span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">CxString</span><span class="params">(<span class="keyword">int</span> size)</span>  </span></span><br><span class="line"><span class="function">    </span>&#123;  </span><br><span class="line">        _size = size;  </span><br><span class="line">        <span class="comment">// 代码同上, 省略...  </span></span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="built_in">CxString</span>(<span class="keyword">const</span> <span class="keyword">char</span> *p)  </span><br><span class="line">    &#123;  </span><br><span class="line">        <span class="comment">// 代码同上, 省略...  </span></span><br><span class="line">    &#125;  </span><br><span class="line">&#125;;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 下面是调用:  </span></span><br><span class="line">  </span><br><span class="line">    <span class="function">CxString <span class="title">string1</span><span class="params">(<span class="number">24</span>)</span></span>;     <span class="comment">// 这样是OK的  </span></span><br><span class="line">    CxString string2 = <span class="number">10</span>;    <span class="comment">// 这样是不行的, 因为explicit关键字取消了隐式转换  </span></span><br><span class="line">    CxString string3;         <span class="comment">// 这样是不行的, 因为没有默认构造函数  </span></span><br><span class="line">    <span class="function">CxString <span class="title">string4</span><span class="params">(<span class="string">&quot;aaaa&quot;</span>)</span></span>; <span class="comment">// 这样是OK的  </span></span><br><span class="line">    CxString string5 = <span class="string">&quot;bbb&quot;</span>; <span class="comment">// 这样也是OK的, 调用的是CxString(const char *p)  </span></span><br><span class="line">    CxString string6 = <span class="string">&#x27;c&#x27;</span>;   <span class="comment">// 这样是不行的, 其实调用的是CxString(int size), 且size等于&#x27;c&#x27;的ascii码, 但explicit关键字取消了隐式转换  </span></span><br><span class="line">    string1 = <span class="number">2</span>;              <span class="comment">// 这样也是不行的, 因为取消了隐式转换  </span></span><br><span class="line">    string2 = <span class="number">3</span>;              <span class="comment">// 这样也是不行的, 因为取消了隐式转换  </span></span><br><span class="line">    string3 = string1;        <span class="comment">// 这样也是不行的, 因为取消了隐式转换, 除非类实现操作符&quot;=&quot;的重载 </span></span><br></pre></td></tr></table></figure><p>explicit关键字的作用就是<strong>防止类构造函数的隐式自动转换</strong></p><p>上面也已经说过了，explicit关键字只对有一个参数的类构造函数有效，<strong>如果类构造函数参数大于或等于两个时,是不会产生隐式转换的，所以explicit关键字也就无效了</strong>。</p><p>但是, 也有一个例外，就是<strong>当除了第一个参数以外的其他参数都有默认值的时候，explicit关键字依然有效</strong>，此时，当调用构造函数时只传入一个参数，等效于只有一个参数的类构造函数。</p><h1 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h1><p>explicit关键字只需用于类内的单参数构造函数前面。由于无参数的构造函数和多参数的构造函数总是显示调用，这种情况在构造函数前加explicit无意义。</p><p>google的c++规范中提到explicit的优点是可以避免不合时宜的类型变换，缺点无。所以google约定所有单参数的构造函数都必须是显示的，只有极少数情况下拷贝构造函数可以不声明称explicit。例如作为其他类的透明包装器的类。</p><p>effective c++中说：被声明为explicit的构造函数通常比其non-explicit兄弟更受欢迎。因为它们禁止编译器执行非预期（往往也不被期望）的类型转换。除非我有一个好理由允许构造函数被用于隐式类型转换，否则我会把它声明为explicit，鼓励大家遵循相同的政策。</p>]]></content>
    
    
    <summary type="html">C++ explicit关键字详解。</summary>
    
    
    
    <category term="CS" scheme="http://aflyingsheep.github.io/categories/CS/"/>
    
    
    <category term="CS" scheme="http://aflyingsheep.github.io/tags/CS/"/>
    
    <category term="C/C++" scheme="http://aflyingsheep.github.io/tags/C-C/"/>
    
  </entry>
  
  <entry>
    <title>树状数组理解</title>
    <link href="http://aflyingsheep.github.io/2022/11/16/algorithm/binary_indexed_tree/"/>
    <id>http://aflyingsheep.github.io/2022/11/16/algorithm/binary_indexed_tree/</id>
    <published>2022-11-16T12:28:06.000Z</published>
    <updated>2022-11-16T13:39:06.339Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="树状数组的问题模型"><a class="markdownIt-Anchor" href="#树状数组的问题模型"></a> 树状数组的问题模型</h1><p>朴素的查询区间和+修改操作的时间复杂度为O(1) &amp; O(n)，树状数组将其时间复杂度降低至均为O(logn)。</p><h1 id="lowbit函数"><a class="markdownIt-Anchor" href="#lowbit函数"></a> lowbit函数</h1><p>顾名思义，<code>lowbit</code>这个函数的功能就是求某一个数的二进制表示中最低的一位<code>1</code>，举个例子，<code>x = 6</code>，它的二进制为<code>110</code>，那么<code>lowbit(x)</code>就返回<code>2</code>，因为最后一位<code>1</code>表示<code>2</code>。</p><p>两种方法实现：</p><ol><li>消除最后一位1，再用原数减去消除最后一位<code>1</code>的数，答案即为<code>lowbit(x)</code>的结果。</li><li>用补码来运算。</li></ol><p>实现的代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 方法1</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lowbit</span><span class="params">(x)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x - (x &amp; (x - <span class="number">1</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 方法2</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lowbit</span><span class="params">(x)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x &amp; -x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="树状数组的思想"><a class="markdownIt-Anchor" href="#树状数组的思想"></a> 树状数组的思想</h1><p>一些定义：<code>arr</code>是原数组，<code>c</code>是新开的一个数组，这个数组代表后缀和;</p><p>二进制的视角：一个数<code>n</code>，假设<code>n = 6</code>，它的二进制为<code>110</code>，我们把它表示成累加的形式<code>110 = 100 + 10</code>，前<code>6(110)</code>项的和可以这样求：</p><p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msubsup><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mn>6</mn></msubsup><mo>=</mo><mo stretchy="false">(</mo><mi>a</mi><mi>r</mi><msub><mi>r</mi><mn>1</mn></msub><mo>+</mo><mi>a</mi><mi>r</mi><msub><mi>r</mi><mn>2</mn></msub><mo>+</mo><mi>a</mi><mi>r</mi><msub><mi>r</mi><mn>3</mn></msub><mo>+</mo><mi>a</mi><mi>r</mi><msub><mi>r</mi><mn>4</mn></msub><mo stretchy="false">)</mo><mo>+</mo><mo stretchy="false">(</mo><mi>a</mi><mi>r</mi><msub><mi>r</mi><mn>5</mn></msub><mo>+</mo><mi>a</mi><mi>r</mi><msub><mi>r</mi><mn>6</mn></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\sum_{i=1}^6=(arr_1+arr_2+arr_3+arr_4)+(arr_5+arr_6)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.253718em;vertical-align:-0.29971000000000003em;"></span><span class="mop"><span class="mop op-symbol small-op" style="position:relative;top:-0.0000050000000000050004em;">∑</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.954008em;"><span style="top:-2.40029em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.2029em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">6</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.29971000000000003em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal">a</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.73333em;vertical-align:-0.15em;"></span><span class="mord mathnormal">a</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.73333em;vertical-align:-0.15em;"></span><span class="mord mathnormal">a</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">a</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">4</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal">a</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">5</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">a</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">6</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></p><p>括号中的元素个数，是不是<code>4(100)</code>个加<code>2(10)</code>个，和<code>110 = 100 + 10</code>很像</p><p>同时，<code>10</code>就是<code>lowbit(110)</code>的结果，<code>100</code>是<code>lowbit(100)</code>的结果。求和的时候我们总是把<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msubsup><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>n</mi></msubsup></mrow><annotation encoding="application/x-tex">\sum_{i=1}^n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.104002em;vertical-align:-0.29971000000000003em;"></span><span class="mop"><span class="mop op-symbol small-op" style="position:relative;top:-0.0000050000000000050004em;">∑</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.804292em;"><span style="top:-2.40029em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.2029em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.29971000000000003em;"><span></span></span></span></span></span></span></span></span></span>拆分成这样的几段区间和来计算，而如何去确定这些区间的起点和长度呢？就是根据n的二进制来的，二进制怎么拆的，就怎么拆分，而拆分二进制就要用到上面说的<code>lowbit</code>函数了。这里也可以顺理成章得给出c数组的表示了。</p><p>例如：</p><p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msubsup><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mn>6</mn></msubsup><mo>=</mo><mo stretchy="false">(</mo><mi>a</mi><mi>r</mi><msub><mi>r</mi><mn>1</mn></msub><mo>+</mo><mi>a</mi><mi>r</mi><msub><mi>r</mi><mn>2</mn></msub><mo>+</mo><mi>a</mi><mi>r</mi><msub><mi>r</mi><mn>3</mn></msub><mo>+</mo><mi>a</mi><mi>r</mi><msub><mi>r</mi><mn>4</mn></msub><mo stretchy="false">)</mo><mo>+</mo><mo stretchy="false">(</mo><mi>a</mi><mi>r</mi><msub><mi>r</mi><mn>5</mn></msub><mo>+</mo><mi>a</mi><mi>r</mi><msub><mi>r</mi><mn>6</mn></msub><mo stretchy="false">)</mo><mo>=</mo><mo stretchy="false">(</mo><mi>a</mi><mi>r</mi><msub><mi>r</mi><mn>1</mn></msub><mo>+</mo><mi>a</mi><mi>r</mi><msub><mi>r</mi><mn>2</mn></msub><mo>+</mo><mi>a</mi><mi>r</mi><msub><mi>r</mi><mn>3</mn></msub><mo>+</mo><mi>a</mi><mi>r</mi><msub><mi>r</mi><mn>4</mn></msub><mo stretchy="false">)</mo><mo>+</mo><mi>c</mi><mo stretchy="false">[</mo><mn>6</mn><mo stretchy="false">]</mo><mspace linebreak="newline"></mspace><mo>=</mo><msubsup><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mn>4</mn></msubsup><mo>+</mo><mi>c</mi><mo stretchy="false">[</mo><mn>6</mn><mo stretchy="false">]</mo><mo>=</mo><mi>c</mi><mo stretchy="false">[</mo><mn>6</mn><mo>−</mo><mi>l</mi><mi>o</mi><mi>w</mi><mi>b</mi><mi>i</mi><mi>t</mi><mo stretchy="false">(</mo><mn>6</mn><mo stretchy="false">)</mo><mo stretchy="false">]</mo><mo>+</mo><mi>c</mi><mo stretchy="false">[</mo><mn>6</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">\sum_{i=1}^6=(arr_1+arr_2+arr_3+arr_4)+(arr_5+arr_6)=(arr_1+arr_2+arr_3+arr_4)+c[6]\\=\sum_{i=1}^4+c[6]=c[6-lowbit(6)]+c[6]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.253718em;vertical-align:-0.29971000000000003em;"></span><span class="mop"><span class="mop op-symbol small-op" style="position:relative;top:-0.0000050000000000050004em;">∑</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.954008em;"><span style="top:-2.40029em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.2029em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">6</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.29971000000000003em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal">a</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.73333em;vertical-align:-0.15em;"></span><span class="mord mathnormal">a</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.73333em;vertical-align:-0.15em;"></span><span class="mord mathnormal">a</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">a</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">4</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal">a</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">5</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">a</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">6</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal">a</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.73333em;vertical-align:-0.15em;"></span><span class="mord mathnormal">a</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.73333em;vertical-align:-0.15em;"></span><span class="mord mathnormal">a</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">a</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">4</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">c</span><span class="mopen">[</span><span class="mord">6</span><span class="mclose">]</span></span><span class="mspace newline"></span><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.253718em;vertical-align:-0.29971000000000003em;"></span><span class="mop"><span class="mop op-symbol small-op" style="position:relative;top:-0.0000050000000000050004em;">∑</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.954008em;"><span style="top:-2.40029em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.2029em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">4</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.29971000000000003em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">+</span><span class="mord mathnormal">c</span><span class="mopen">[</span><span class="mord">6</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">c</span><span class="mopen">[</span><span class="mord">6</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="mord mathnormal">b</span><span class="mord mathnormal">i</span><span class="mord mathnormal">t</span><span class="mopen">(</span><span class="mord">6</span><span class="mclose">)</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">c</span><span class="mopen">[</span><span class="mord">6</span><span class="mclose">]</span></span></span></span></p><h1 id="树状数组的实现"><a class="markdownIt-Anchor" href="#树状数组的实现"></a> 树状数组的实现</h1><h2 id="查询"><a class="markdownIt-Anchor" href="#查询"></a> 查询</h2><p>这里说的查询是查询任一区间的和，由于区间和具有可加减性，故转化为求前缀和；</p><p>查询前缀和刚刚在树状数组的思想中已经说过了，就是把大区间分成几段长度不等的小区间，然后求和。区间的个数为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(logn)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>，所以查询的时间复杂度为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(logn)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></p><h2 id="修改"><a class="markdownIt-Anchor" href="#修改"></a> 修改</h2><p><img src="/image/binary_tree/1.png" alt="1" /></p><p>可以得到树状数组的性值：</p><ol><li>后缀和的长度是2的幂；</li><li>上一层后缀和的长度是下一层后缀和长度的两倍；</li><li>一层后缀和只要补上自己后缀和的长度就可以得到上面层的后缀和(图中的虚框框)，注意，是上面的后缀和，而不是上一层的后缀和，这个性质就是更新操作的依据；</li><li>最后一位1右边有多少个0(可以用<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>l</mi><mi>o</mi><msub><mi>g</mi><mn>2</mn></msub><mo stretchy="false">(</mo><mi>l</mi><mi>o</mi><mi>w</mi><mi>b</mi><mi>i</mi><mi>t</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">log_2(lowbit(x))</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">o</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="mord mathnormal">b</span><span class="mord mathnormal">i</span><span class="mord mathnormal">t</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mclose">)</span><span class="mclose">)</span></span></span></span>表示)就表示这一层有多少个直系子层(子层的意思就是这一层的和包含下面某一层的和)。</li></ol><p>更新操作：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这里的val应该是修改值的变化量</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> val, <span class="keyword">int</span> *c, <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> ( ; x &lt;= n; c[x] += val, x += <span class="built_in">lowbit</span>(x));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="leetcode775-全局倒置与局部倒置"><a class="markdownIt-Anchor" href="#leetcode775-全局倒置与局部倒置"></a> Leetcode.775 全局倒置与局部倒置</h1><p><a href="https://leetcode.cn/problems/global-and-local-inversions/">775. 全局倒置与局部倒置 - 力扣（LeetCode）</a></p><p>根据题意，对于每个<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mi>u</mi><mi>m</mi><mi>s</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">nums[i]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">n</span><span class="mord mathnormal">u</span><span class="mord mathnormal">m</span><span class="mord mathnormal">s</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">]</span></span></span></span>而言：</p><ul><li><p>其左边比它大的<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mi>u</mi><mi>m</mi><mi>s</mi><mo stretchy="false">[</mo><mi>j</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">nums[j]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">n</span><span class="mord mathnormal">u</span><span class="mord mathnormal">m</span><span class="mord mathnormal">s</span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mclose">]</span></span></span></span>的个数，是以<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mi>u</mi><mi>m</mi><mi>s</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">nums[i]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">n</span><span class="mord mathnormal">u</span><span class="mord mathnormal">m</span><span class="mord mathnormal">s</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">]</span></span></span></span>为右端点的“全局倒置”数量，统计所有以<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mi>u</mi><mi>m</mi><mi>s</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">nums[i]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">n</span><span class="mord mathnormal">u</span><span class="mord mathnormal">m</span><span class="mord mathnormal">s</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">]</span></span></span></span>为右端点的“全局倒置”数量即是总的“全局倒置”数量<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi></mrow><annotation encoding="application/x-tex">a</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">a</span></span></span></span></p></li><li><p>同时我们可以将每个<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mi>u</mi><mi>m</mi><mi>s</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">nums[i]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">n</span><span class="mord mathnormal">u</span><span class="mord mathnormal">m</span><span class="mord mathnormal">s</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">]</span></span></span></span>与前一个值进行比较，从而统计总的“局部倒置”数量<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>b</mi></mrow><annotation encoding="application/x-tex">b</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal">b</span></span></span></span>，其中 ii 的取值范围为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mn>1</mn><mo separator="true">,</mo><mi>n</mi><mtext>−</mtext><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">[1,n−1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">n</span><span class="mord">−</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></p></li></ul><p>一个容易想到的做法是利用「树状数组」，虽然该做法没有利用到核心条件「<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mi>u</mi><mi>m</mi><mi>s</mi></mrow><annotation encoding="application/x-tex">nums</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">n</span><span class="mord mathnormal">u</span><span class="mord mathnormal">m</span><span class="mord mathnormal">s</span></span></span></span>是一个<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mn>0</mn><mo separator="true">,</mo><mi>n</mi><mtext>−</mtext><mn>1</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[0,n−1]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">n</span><span class="mord">−</span><span class="mord">1</span><span class="mclose">]</span></span></span></span>的排列」，但根据数据范围n可知该复杂度为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(nlogn)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>的做法可过，且依赖的条件更少，适用范围更广。</p><p>! 没太看明白，后期更</p>]]></content>
    
    
    <summary type="html">又称二叉索引树，使得查询区间和与修改的时间复杂度将为O(logn)</summary>
    
    
    
    <category term="Algorithm" scheme="http://aflyingsheep.github.io/categories/Algorithm/"/>
    
    
    <category term="Algorithm" scheme="http://aflyingsheep.github.io/tags/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>SWSPH - 论文阅读笔记</title>
    <link href="http://aflyingsheep.github.io/2022/11/15/science_research/swsph/"/>
    <id>http://aflyingsheep.github.io/2022/11/15/science_research/swsph/</id>
    <published>2022-11-15T14:28:06.000Z</published>
    <updated>2022-12-02T13:16:42.730Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="优化方法"><a class="markdownIt-Anchor" href="#优化方法"></a> 优化方法</h2><ol><li><p>域分解策略：</p><ol><li><p>基于单元列表的成对交互：引入模拟域中分配均匀的空间网格，将整个粒子系统根据位空间坐标将粒子放置到cell中。</p><p>进行粒子对交互时，每个中心单元根据自身和相邻的cell执行计算。第一层循环迭代当前cell，第二层迭代周围cell。</p><p>确定粒子与周围cell的最小距离是否大于其支持域(剪枝)</p><p>充分保持了数据的局部性，提高搜索成功率，减少分支数，有利于矢量化。</p><img src="C:\Users\赵阳\AppData\Roaming\Typora\typora-user-images\image-20221114160055315.png" alt="image-20221114160055315" style="zoom:80%;" /></li></ol></li><li><p>负载平衡——自适应粒子分割 &amp; 体积自适应方案</p><ol><li><p>自适应粒子分割</p><ul><li>传统SPH：为每个core分配统一数量的粒子，效率不高</li><li>改进SPH：使用每个单元粒子最大支持域半径估算计算量，收敛区域使用树状自适应网格细化，直到计算量降至平均值以下，算法如下图：</li><li>将单元半径设置为略大于支持域半径，减少无效搜索</li></ul><img src="C:\Users\赵阳\AppData\Roaming\Typora\typora-user-images\image-20221114192107755.png" alt="image-20221114192107755" style="zoom:80%;" /></li><li><p>体积自适应方案</p><ol><li><p>冲击模拟带来的问题：</p><ul><li><p>粒子压缩：局部负荷增加</p></li><li><p>过度膨胀粒子：更大的支撑域收集足够粒子用于SPH插值，需要更大区域长度并增加没有膨胀波区域的计算负荷</p></li></ul></li><li><p>体积自适应方案解决：</p><ul><li>粒子体积大于预设上限，母粒子拆分为8个子粒子(物理量继承母粒子物理数量)</li><li>粒子体积小于预设下限，中心距离小于预设最大长度的一对粒子：合并为一个母粒子，物理量通过子粒子加权和计算</li></ul></li></ol></li></ol></li><li><p>通信优化策略</p><p>将存储在每个节点的cell分为三种类型：<strong>core cell, edge cell and ghost cell</strong></p><ol><li><p>点对点通信模式：</p><p>SPH中存在两种通信：粒子迁移(发送粒子到目标进程)、halo-exchange，采用非阻塞式点对点通信方法</p><ul><li><p>核心单元粒子计算与原子迁移、halo-exchange的堆叠</p><img src="C:\Users\赵阳\AppData\Roaming\Typora\typora-user-images\image-20221114215342162.png" alt="image-20221114215342162" style="zoom:80%;" /></li></ul></li><li><p>ghost单元冗余删除</p><ul><li>大多数框架，halo-exchange直接pack并发送，但包含大量冗余数据。</li><li>优化：细化子单元，分析支持域有效半径，提前消除ghost单元中冗余粒子数据</li></ul></li></ol></li><li><p>390-cores CPU细粒度任务映射策略</p><ol><li><p>全共享模式：Sunway提供全共享模式：使用1个MPI进程+6个OpenMP线程能够控制6个CG，6*64个slave cores可以共享92GB内存</p></li><li><p>计算核心分组方案：</p><ul><li><p>根据牛顿第三定律(作用力与反作用力，计算量减半)：1. 找到比当前索引小的相邻cells并构建数据副本(之前已经计算过作用力，直接赋值即可); 2. 遍历比自己索引大的相邻cells，完成作用计算</p></li><li><p>原分组方案：粗粒度并行(将整个i cell list分配给slave core，写入时j cell core的粒子数据也会被更新(牛顿第三定律))与细粒度并行(把每个cell list分配给64个slave core，但由于没有足够任务支持64个core parallel，将近一半的core处于忙等状态)</p></li><li><p>现改进方案：将64个CPE按行划分为16个计算组(一组4个CPE)，每个计算组负责一个cell list，每个CPE负责计算一对cell</p><img src="C:\Users\赵阳\AppData\Roaming\Typora\typora-user-images\image-20221114231825086.png" alt="image-20221114231825086" style="zoom:80%;" /><ul><li>组中没有写入冲突，但组间写入冲突依旧存在——在列0的CPE的LDM中设置一个数据副本，当一个组所有成员完成cell list计算后，每个CPE将数据归约为第0列CPE的副本，并使用DMA更新内存数据</li><li>数据归约：树约简方法更适合从核阵列的互联结构</li></ul></li></ul></li><li><p>数据布局优化与矢量化</p><img src="C:\Users\赵阳\AppData\Roaming\Typora\typora-user-images\image-20221114232342268.png" alt="image-20221114232342268" style="zoom:80%;" /><ol><li>排序(根据相对位置，由CPE并行实现)</li><li>AoS-&gt;AoSoA</li><li>可以使用simd加载指令从LDM读取8个连续的双数据并将它们放入向量寄存器中</li></ol></li></ol></li></ol>]]></content>
    
    
    <summary type="html">SWSPH-A Massively Parallel SPH Implementation for Hundred-Billion-Particle Simulation on New Sunway Supercomputer</summary>
    
    
    
    <category term="HPC" scheme="http://aflyingsheep.github.io/categories/HPC/"/>
    
    
    <category term="Paper Reading" scheme="http://aflyingsheep.github.io/tags/Paper-Reading/"/>
    
  </entry>
  
  <entry>
    <title>C++11:原子操作与memory_order</title>
    <link href="http://aflyingsheep.github.io/2022/10/31/linux/aotomic_and_memory_order/"/>
    <id>http://aflyingsheep.github.io/2022/10/31/linux/aotomic_and_memory_order/</id>
    <published>2022-10-31T11:27:06.000Z</published>
    <updated>2023-02-11T13:22:54.559Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="原子操作"><a class="markdownIt-Anchor" href="#原子操作"></a> 原子操作</h1><h2 id="概念"><a class="markdownIt-Anchor" href="#概念"></a> 概念</h2><p>原子操作是多线程程序中&quot;<strong>最小且不可并行化</strong>&quot;的操作。通常对一个共享资源的操作是原子操作的话，意味着多个线程访问该资源时，有且仅有唯一一个线程在对这个资源进行操作。</p><p>通常情况下，原子操作通过&quot;互斥&quot;（mutual exclusive）的访问来保证。实现互斥通常需要平台相关的特殊指令，在c++11标准之前，这常常意味着需要在c/c++代码中嵌入内联汇编代码。</p><h2 id="问题"><a class="markdownIt-Anchor" href="#问题"></a> 问题</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">static</span> <span class="keyword">long</span> <span class="keyword">long</span> total=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">pthread_mutex_t</span> m=PTHREAD_MUTEX_INITIALIZER;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">func</span><span class="params">(<span class="keyword">void</span>*)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">     <span class="keyword">long</span> <span class="keyword">long</span> i;</span><br><span class="line">     <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">100000000</span>;i++)</span><br><span class="line">     &#123;</span><br><span class="line">         <span class="built_in">pthread_mutex_lock</span>(&amp;m);</span><br><span class="line">         total+=i;</span><br><span class="line">         <span class="built_in">pthread_mutex_unlock</span>(&amp;m);</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">     <span class="keyword">pthread_t</span> thread1,thread2;</span><br><span class="line">     <span class="keyword">if</span>(<span class="built_in">pthread_create</span>(&amp;thread1,<span class="literal">NULL</span>,&amp;func,<span class="literal">NULL</span>))</span><br><span class="line">     &#123;</span><br><span class="line">        <span class="keyword">throw</span>;</span><br><span class="line">     &#125;</span><br><span class="line"> </span><br><span class="line">     <span class="keyword">if</span>(<span class="built_in">pthread_create</span>(&amp;thread2,<span class="literal">NULL</span>,&amp;func,<span class="literal">NULL</span>))</span><br><span class="line">     &#123;</span><br><span class="line">        <span class="keyword">throw</span>;</span><br><span class="line">     &#125;</span><br><span class="line"> </span><br><span class="line">     <span class="built_in">pthread_join</span>(thread1,<span class="literal">NULL</span>);</span><br><span class="line">     <span class="built_in">pthread_join</span>(thread2,<span class="literal">NULL</span>);</span><br><span class="line">     cout&lt;&lt;total&lt;&lt;endl;<span class="comment">//9999999900000000</span></span><br><span class="line">     <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码中为了防止数据竞争，我们使用了pthread_mutex_t的互斥锁保证两个线程可以正确的访问total。</p><ul><li>加锁和解锁会消耗系统资源</li><li>代码移植性较差，像我们实际开发过程中，一套代码中兼容windows和linux等的地方比比皆是，这其实是程序员做了&quot;妥协&quot;。</li></ul><h2 id="c11的改进"><a class="markdownIt-Anchor" href="#c11的改进"></a> C++11的改进</h2><p>c++11对数据进行了更加良好的抽象，引入“原子数据类型”（atomic）,以达到对开发者掩盖互斥锁、临界区的目的。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;atomic&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">std::<span class="keyword">atomic_llong</span> total&#123; <span class="number">0</span> &#125;;<span class="comment">//原子数据类型</span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">long</span> <span class="keyword">long</span> i = <span class="number">0</span>; i&lt;<span class="number">100000000</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        total += i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">thread <span class="title">t1</span><span class="params">(func, <span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="function">thread <span class="title">t2</span><span class="params">(func, <span class="number">0</span>)</span></span>;</span><br><span class="line">    t1.<span class="built_in">join</span>();</span><br><span class="line">    t2.<span class="built_in">join</span>();</span><br><span class="line">    cout&lt;&lt;total&lt;&lt;endl;<span class="comment">//9999999900000000</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将total定义为原子类型std::atomic_llong，使得程序不需要显示的调用API来加锁、解锁，对于代码来说，即容易又简洁。</p><h1 id="atomic"><a class="markdownIt-Anchor" href="#atomic"></a> atomic</h1><p><code>template &lt;class T&gt; struct atomic;</code></p><p>参考手册：<a href="http://cplusplus.com/reference/atomic/atomic/?kw=atomic">http://cplusplus.com/reference/atomic/atomic/?kw=atomic</a></p><h1 id="内存模型与memory_order"><a class="markdownIt-Anchor" href="#内存模型与memory_order"></a> 内存模型与memory_order</h1><h2 id="强顺序与弱顺序"><a class="markdownIt-Anchor" href="#强顺序与弱顺序"></a> 强顺序与弱顺序</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;atomic&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"> </span><br><span class="line">atomic&lt;<span class="keyword">int</span>&gt; m&#123;<span class="number">0</span>&#125;;</span><br><span class="line">atomic&lt;<span class="keyword">int</span>&gt; n&#123;<span class="number">0</span>&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> tmp = <span class="number">1</span>;</span><br><span class="line">    m = tmp;</span><br><span class="line">    n = <span class="number">3</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>汇编代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">loadi reg3, <span class="number">1</span>;    #将<span class="number">1</span>放入寄存器reg3</span><br><span class="line">move reg4, reg3;  #将reg3的数据放入reg4 </span><br><span class="line">store reg4, m;    #将寄存器reg4中的数据存入内存地址m</span><br><span class="line">loadi reg5, <span class="number">2</span>;    #将立即数<span class="number">2</span>放入寄存器reg5</span><br><span class="line">store reg5, n;    #将寄存器<span class="number">5</span>中的数据存入内存地址n</span><br></pre></td></tr></table></figure><p>强顺序：指令执行顺序为1-&gt;2-&gt;3-&gt;4-&gt;5</p><p>弱顺序：执行可能的执行顺序为1-&gt;4-&gt;2-&gt;5-&gt;3（指的是执行顺序存在一定的不确定性）</p><h2 id="优势与劣势"><a class="markdownIt-Anchor" href="#优势与劣势"></a> 优势与劣势</h2><p>优势：提高指令执行性能</p><p>劣势：多线程下，可能会造成程序运行错误；</p><p>例：单例模式中经典的double check双检查锁的实现方式</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Singleton* <span class="title">Singleton::getInstance</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (m_instance == <span class="literal">nullptr</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        std::mutex mtx;           <span class="comment">//函数结束时锁资源释放</span></span><br><span class="line">        m_instance = <span class="built_in"><span class="keyword">new</span></span>(std::nothrow) <span class="built_in">Singleton</span>();</span><br><span class="line">        <span class="keyword">if</span> (m_instance == <span class="literal">nullptr</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> m_instance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>默认构造顺序：分配内存、调用构造器、返回指针至instance</p><p>reorder后可能为：分配内存、指针返回值给instance、调用构造器</p><p><strong>导致问题：当一个线程执行到第二步时，假如此时有另外一个线程访问，会默认m_instance不为空返回，此时实际还未调用构造器，进而导致不可预知的问题。</strong></p><h2 id="memory_order"><a class="markdownIt-Anchor" href="#memory_order"></a> memory_order</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">enum</span> <span class="title">memory_order</span> &#123;</span></span><br><span class="line">memory_order_relaxed,</span><br><span class="line">memory_order_consume,</span><br><span class="line">memory_order_acquire,</span><br><span class="line">memory_order_release,</span><br><span class="line">memory_order_acq_rel,</span><br><span class="line">memory_order_seq_cst</span><br><span class="line">&#125; memory_order;</span><br></pre></td></tr></table></figure><p><img src="/image/aotomic/1.png" alt="1" /></p><p>对于单例构造的修改：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">std::atomic&lt;Singleton*&gt; Singleton::m_instance;   <span class="comment">//原子对象</span></span><br><span class="line">std::mutex Singleton::m_mutex;</span><br><span class="line"> </span><br><span class="line"><span class="function">Singleton* <span class="title">Singleton::getInstance</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Singleton* s = m_instance.<span class="built_in">load</span>(std::memory_order_relaxed);  <span class="comment">//屏蔽编译器的reorder</span></span><br><span class="line">    std::_Atomic_thread_fence(std::memory_order_acquire);       <span class="comment">//本线程中，所有后续的读操作必须在本条原子操作完成后执行</span></span><br><span class="line">    <span class="keyword">if</span> (s == <span class="literal">nullptr</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(m_mutex)</span></span>;</span><br><span class="line">        s = m_instance.<span class="built_in">load</span>(std::memory_order_relaxed);  <span class="comment">//取变量</span></span><br><span class="line">        <span class="keyword">if</span> (s == <span class="literal">nullptr</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            s = <span class="keyword">new</span> Singleton;   <span class="comment">//保证不出现reorder</span></span><br><span class="line">            std::_Atomic_thread_fence(std::memory_order_release);  <span class="comment">//释放内存fence</span></span><br><span class="line">            m_instance.<span class="built_in">store</span>(s, std::memory_order_relaxed);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><em>memory_order</em>参数的默认值是std::memory_order_seq_cst。<strong>实际上，atomic类型的其他原子操作接口都有memory_order这个参数，而且默认值都是std::memory_order_seq_cst。</strong></p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="C++" scheme="http://aflyingsheep.github.io/categories/C/"/>
    
    <category term="HPC" scheme="http://aflyingsheep.github.io/categories/HPC/"/>
    
    
    <category term="HPC" scheme="http://aflyingsheep.github.io/tags/HPC/"/>
    
  </entry>
  
  <entry>
    <title>Compare And Swap(CAS)原理分析</title>
    <link href="http://aflyingsheep.github.io/2022/10/31/linux/CAS/"/>
    <id>http://aflyingsheep.github.io/2022/10/31/linux/CAS/</id>
    <published>2022-10-31T11:04:06.000Z</published>
    <updated>2023-02-11T13:24:51.030Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="cas概论"><a class="markdownIt-Anchor" href="#cas概论"></a> CAS概论</h1><h2 id="cas定义"><a class="markdownIt-Anchor" href="#cas定义"></a> CAS定义</h2><p><strong>Compare and swap，解决多线程并行情况下使用锁造成性能损耗的一种机制</strong>，CAS操作包含三个操作数——<strong>内存位置</strong>（V）、<strong>预期原值</strong>（A）和<strong>新值</strong>(B)。如果<strong>内存位置的值与预期原值相匹配，那么处理器会自动将该位置值更新为新值。否则，处理器不做任何操作</strong>。无论哪种情况，它都会在CAS指令之前返回该位置的值。CAS有效地说明了“我认为位置V应该包含值A；如果包含该值，则将B放到这个位置；否则，不要更改该位置，只告诉我这个位置现在的值即可。&quot;</p><p>CAS操作是一条CPU的原子指令，所以不会有线程安全问题。</p><p><img src="/image/CAS/1.png" alt="1" /></p><h2 id="加锁和cas解决原子性问题的不同原理"><a class="markdownIt-Anchor" href="#加锁和cas解决原子性问题的不同原理"></a> 加锁和CAS解决原子性问题的不同原理</h2><p>考虑如下代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//共享资源</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">increase</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    i++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    Runnable r = () -&gt; &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">1000</span>; j++) &#123;</span><br><span class="line">            increase();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    List&lt;Thread&gt; threads = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">10</span>; j++) &#123;</span><br><span class="line">        Thread thread = <span class="keyword">new</span> Thread(r);</span><br><span class="line">        threads.add(thread);</span><br><span class="line">        thread.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//确保前面10个线程都走完</span></span><br><span class="line">    <span class="keyword">for</span> (Thread thread : threads) &#123;</span><br><span class="line">        thread.join();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    System.out.println(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于i++，并不是原子性操作，导致10个线程执行后i的值并不是10*1000.</p><p>加锁解决的方式：</p><p><img src="/image/CAS/2.png" alt="2" /></p><p>CAS解决方式：</p><p><img src="/image/CAS/3.png" alt="3" /></p><h1 id="c中的cas操作"><a class="markdownIt-Anchor" href="#c中的cas操作"></a> C++中的CAS操作</h1><p>C++ 中的 CAS 操作用于操作原子变量，它是 <code>atomic&lt;T&gt; </code>的成员函数。</p><p><strong>在进行判等操作时，它执行的是物理上的比较，即直接比较内存值，而不是使用 <code>T</code> 的 <code>==</code> 操作符进行比较。此外，它允许虚假失败，也就是当前原子变量的内容与 <code>expected</code> 相等，但是它仍然返回 <code>false</code> ，但它不会修改 <code>expected</code> 。它需要放在循环中使用。</strong></p><p><a href="https://blog.csdn.net/www_dong/article/details/119920236">c++ CAS API接口(click me!)</a></p><h2 id="示例"><a class="markdownIt-Anchor" href="#示例"></a> 示例</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;atomic&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    T data;</span><br><span class="line">    node* next;</span><br><span class="line">    <span class="built_in">node</span>(<span class="keyword">const</span> T&amp; data) : <span class="built_in">data</span>(data), <span class="built_in">next</span>(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">stack</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    std::atomic&lt;node&lt;T&gt;*&gt; head;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">const</span> T&amp; data)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        node&lt;T&gt;* new_node = <span class="keyword">new</span> node&lt;T&gt;(data);</span><br><span class="line"> </span><br><span class="line">        new_node-&gt;next = head.<span class="built_in">load</span>(std::memory_order_relaxed);</span><br><span class="line"> </span><br><span class="line">        <span class="comment">//std::memory_order_release: 本线程中，所有之前的写操作完成后才能执行本条原子操作</span></span><br><span class="line">        <span class="comment">//memory_order_relaxed: 不对执行的顺序作任何保证</span></span><br><span class="line">        <span class="keyword">while</span>(!std::<span class="built_in">atomic_compare_exchange_weak_explicit</span>(</span><br><span class="line">                                &amp;head,</span><br><span class="line">                                &amp;new_node-&gt;next,</span><br><span class="line">                                new_node,</span><br><span class="line">                                std::memory_order_release,     </span><br><span class="line">                                std::memory_order_relaxed))</span><br><span class="line">                ; </span><br><span class="line">   &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    stack&lt;<span class="keyword">int</span>&gt; s;</span><br><span class="line">    s.<span class="built_in">push</span>(<span class="number">1</span>);</span><br><span class="line">    s.<span class="built_in">push</span>(<span class="number">2</span>);</span><br><span class="line">    s.<span class="built_in">push</span>(<span class="number">3</span>);</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">compare and swap，解决多线程并行情况下使用锁造成性能损耗的一种机制</summary>
    
    
    
    <category term="CS" scheme="http://aflyingsheep.github.io/categories/CS/"/>
    
    <category term="HPC" scheme="http://aflyingsheep.github.io/categories/HPC/"/>
    
    
    <category term="HPC" scheme="http://aflyingsheep.github.io/tags/HPC/"/>
    
  </entry>
  
  <entry>
    <title>自旋锁</title>
    <link href="http://aflyingsheep.github.io/2022/10/31/linux/spinlock/"/>
    <id>http://aflyingsheep.github.io/2022/10/31/linux/spinlock/</id>
    <published>2022-10-31T10:43:06.000Z</published>
    <updated>2023-02-11T13:25:13.115Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="前言"><a class="markdownIt-Anchor" href="#前言"></a> 前言</h1><p>在有些场景中，同步资源的锁定时间很短，为了这一小段时间去切换线程，线程挂起和恢复现场的花费可能会让系统得不偿失。</p><p>如果机器有多个CPU核心，能够让两个或以上的线程同时并行执行，我们就可以让后面那个请求锁的线程不放弃CPU的执行时间，看看持有锁的线程是否很快就会释放锁。</p><p>为了让当前线程“稍等一下”，我们需让当前线程进行自旋，如果在自旋完成后前面锁定同步资源的线程已经释放了锁，那么当前线程就可以不必阻塞而是直接获取同步资源，从而避免切换线程的开销。这就是自旋锁。</p><img src="/image/spinlock/1.png" alt="1" style="zoom:50%;" /><h1 id="缺点"><a class="markdownIt-Anchor" href="#缺点"></a> 缺点</h1><p>不能代替阻塞。自旋等待虽然避免了线程切换的开销，但它要占用处理器时间。</p><ul><li>如果锁被占用的时间很短，自旋等待的效果就会非常好；</li><li>如果锁被占用的时间很长，那么自旋的线程只会白浪费处理器资源。</li></ul><p>自旋等待的时间必须要有一定的限度，如果自旋超过了限定次数没有成功获得锁，就应当挂起线程。（这个次数默认是10次，可以配置）</p>]]></content>
    
    
    <summary type="html">同步资源，切换线程，让两个或以上的线程同时并行执行，后面请求锁的线程不放弃CPU的执行时间，看看持有锁的线程是否很快就会释放锁。</summary>
    
    
    
    <category term="CS" scheme="http://aflyingsheep.github.io/categories/CS/"/>
    
    <category term="HPC" scheme="http://aflyingsheep.github.io/categories/HPC/"/>
    
    
    <category term="HPC" scheme="http://aflyingsheep.github.io/tags/HPC/"/>
    
  </entry>
  
  <entry>
    <title>软中断、tasklet和工作队列详解</title>
    <link href="http://aflyingsheep.github.io/2022/10/31/linux/tasklet/"/>
    <id>http://aflyingsheep.github.io/2022/10/31/linux/tasklet/</id>
    <published>2022-10-31T08:19:06.000Z</published>
    <updated>2023-02-11T13:25:33.830Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="引言"><a class="markdownIt-Anchor" href="#引言"></a> 引言</h1><p>软中断、tasklet和工作队列并不是Linux内核中一直存在的机制，而是由更早版本的内核中的“下半部”（bottom half）演变而来。</p><p>上半部指的是中断处理程序，下半部则指的是一些虽然与中断有相关性但是可以延后执行的任务。举个例子：在网络传输中，网卡接收到数据包这个事件不一定需要马上被处理，适合用下半部去实现；但是用户敲击键盘这样的事件就必须马上被响应，应该用中断实现。<br />两者的主要区别在于：中断不能被相同类型的中断打断，而下半部依然可以被中断打断；中断对于时间非常敏感，而下半部基本上都是一些可以延迟的工作。由于二者的这种区别，所以对于一个工作是放在上半部还是放在下半部去执行，可以参考下面4条：</p><ol><li>如果一个任务对时间非常敏感，将其放在中断处理程序中执行。</li><li>如果一个任务和硬件相关，将其放在中断处理程序中执行。</li><li>如果一个任务要保证不被其他中断（特别是相同的中断）打断，将其放在中断处理程序中执行。</li><li>其他所有任务，考虑放在下半部去执行。</li></ol><p>有写内核任务需要延后执行，因此才有的下半部，进而实现了三种实现下半部的方法。这就是本文要讨论的<strong>软中断</strong>、<strong>Tasklet</strong>和<strong>工作队列</strong>。</p><p><img src="/image/tasklet/1.png" alt="1" /></p><h1 id="软中断"><a class="markdownIt-Anchor" href="#软中断"></a> 软中断</h1><p>软中断作为下半部机制的代表，是随着SMP（share memory processor）的出现应运而生的，它也是tasklet实现的基础（tasklet实际上只是在软中断的基础上添加了一定的机制）。软中断一般是“可延迟函数”的总称，有时候也包括了tasklet（请读者在遇到的时候根据上下文推断是否包含tasklet）。它的出现就是因为要满足上面所提出的上半部和下半部的区别，使得对时间不敏感的任务延后执行，而且可以在多个CPU上并行执行，使得总的系统效率可以更高。它的特性包括：</p><ul><li>产生后并不是马上可以执行，必须要等待内核的调度才能执行。软中断不能被自己打断(即单个cpu上软中断不能嵌套执行)，只能被硬件中断打断（上半部）。</li><li>可以并发运行在多个CPU上（即使同一类型的也可以）。所以软中断必须设计为可重入的函数（一个函数在被调用执行期间（尚未调用结束），由于某种时序又被重复调用，称之为重入; 允许多个CPU同时操作），因此也需要使用自旋锁来保其数据结构。</li></ul><h1 id="tasklet"><a class="markdownIt-Anchor" href="#tasklet"></a> tasklet</h1><p>由于软中断必须使用可重入函数，这就导致设计上的复杂度变高，作为设备驱动程序的开发者来说，增加了负担。而如果某种应用并不需要在多个CPU上并行执行，那么软中断其实是没有必要的。因此诞生了弥补以上两个要求的tasklet。它具有以下特性：</p><ul><li>一种特定类型的tasklet只能运行在一个CPU上，不能并行，只能串行执行。</li><li>多个不同类型的tasklet可以并行在多个CPU上。</li><li>软中断是静态分配的，在内核编译好之后，就不能改变。但tasklet就灵活许多，可以在运行时改变（比如添加模块时）。</li></ul><p>tasklet是在两种软中断类型的基础上实现的，因此如果不需要软中断的并行特性，tasklet就是最好的选择。也就是说tasklet是软中断的一种特殊用法，即延迟情况下的串行执行。</p><h1 id="工作队列"><a class="markdownIt-Anchor" href="#工作队列"></a> 工作队列</h1><p>从上面的介绍看以看出，软中断运行在中断上下文中，因此不能阻塞和睡眠，而tasklet使用软中断实现，当然也不能阻塞和睡眠。但如果某延迟处理函数需要睡眠或者阻塞呢？便使用工作队列来实现。</p><p>内核定义了一组队列，其中每个队列都包含一个由等待调用的函数组成的链表。根据其所处队列的位置，这些函数会在某个时刻执行。驱动程序可以把它们的下半部注册到合适的队列上去。缺点是，对于一些性能要求较高的子系统（例如定时器、网络部分），它则不能胜任。</p><p>把推后执行的任务叫做工作（work），描述它的数据结构为work_struct ，这些工作以队列结构组织成工作队列（workqueue），其数据结构为workqueue_struct ，而工作线程就是负责执行工作队列中的工作。系统默认的工作者线程为events。</p><p>工作队列(work queue)是另外一种将工作推后执行的形式。工作队列可以把工作推后，交由一个内核线程去执行—这个下半部分总是会在进程上下文执行，但由于是内核线程，其不能访问用户空间。最重要特点的就是工作队列允许重新调度甚至是睡眠。</p><h1 id="软中断-tasklet与工作队列的区别与联系"><a class="markdownIt-Anchor" href="#软中断-tasklet与工作队列的区别与联系"></a> 软中断、tasklet与工作队列的区别与联系</h1><h2 id="软中断-2"><a class="markdownIt-Anchor" href="#软中断-2"></a> 软中断</h2><ol><li><p>软中断是在编译期间静态分配的。</p></li><li><p>最多可以有32个软中断。</p></li><li><p>软中断不会抢占另外一个软中断，唯一可以抢占软中断的是中断处理程序。</p></li><li><p>可以并发运行在多个CPU上（即使同一类型的也可以）。所以软中断必须设计为可重入的函数（允许多个CPU同时操作），因此也需要使用自旋锁来保护其数据结构。</p></li><li><p>目前只有两个子系直接使用软中断：网络和SCSI。</p></li><li><p>执行时间有：从硬件中断代码返回时、在ksoftirqd内核线程中和某些显示检查并执行软中断的代码中。</p></li></ol><h2 id="tasklet-2"><a class="markdownIt-Anchor" href="#tasklet-2"></a> tasklet</h2><ol><li>tasklet是使用两类软中断实现的：HI_SOFTIRQ和TASKLET_SOFTIRQ。</li><li>可以动态增加减少，没有数量限制。</li><li>同一类tasklet不能并发执行。</li><li>不同类型可以并发执行。</li><li>大部分情况使用tasklet。</li></ol><h2 id="工作队列-2"><a class="markdownIt-Anchor" href="#工作队列-2"></a> 工作队列</h2><ol><li>由内核线程去执行，换句话说总在进程上下文执行。</li><li>可以睡眠，阻塞。</li></ol><p><img src="/image/tasklet/2.png" alt="2" /></p><h2 id="选择方法"><a class="markdownIt-Anchor" href="#选择方法"></a> 选择方法</h2><ul><li>如果推后执行的任务<strong>需要睡眠</strong>，那么只能选择<strong>工作队列</strong>。</li><li>如果推后执行的任务<strong>需要延时指定的时间再触发</strong>，那么使用<strong>工作队列</strong>，因为其可以利用timer延时(内核定时器实现)。</li><li>如果推后执行的任务<strong>需要在一个tick之内处理</strong>，则使用<strong>软中断或tasklet</strong>，因为其可以抢占普通进程和内核线程，同时不可睡眠。</li><li>如果推后执行的任务对延迟的时间<strong>没有任何要求</strong>，则使用<strong>工作队列</strong>，此时通常为无关紧要的任务。</li></ul><blockquote><p>参考：</p><p><a href="https://blog.csdn.net/godleading/article/details/52971179">https://blog.csdn.net/godleading/article/details/52971179</a></p><p><a href="https://blog.csdn.net/Ivan804638781/article/details/115312421">https://blog.csdn.net/Ivan804638781/article/details/115312421</a></p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="CS" scheme="http://aflyingsheep.github.io/categories/CS/"/>
    
    <category term="HPC" scheme="http://aflyingsheep.github.io/categories/HPC/"/>
    
    
    <category term="HPC" scheme="http://aflyingsheep.github.io/tags/HPC/"/>
    
  </entry>
  
  <entry>
    <title>HPC基础：MPI+OPENMP</title>
    <link href="http://aflyingsheep.github.io/2022/08/05/mpi%20and%20openmp/openmp_MPI/"/>
    <id>http://aflyingsheep.github.io/2022/08/05/mpi%20and%20openmp/openmp_MPI/</id>
    <published>2022-08-05T12:38:06.000Z</published>
    <updated>2022-11-07T09:21:39.206Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="mpi"><a class="markdownIt-Anchor" href="#mpi"></a> MPI</h1><h2 id="第一个并行程序"><a class="markdownIt-Anchor" href="#第一个并行程序"></a> 第一个并行程序</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 第一个MPI程序</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">hello_world</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> greeting[MAX_STRING];</span><br><span class="line">    <span class="keyword">int</span> comm_sz; <span class="comment">// 进程核数</span></span><br><span class="line">    <span class="keyword">int</span> my_rank; <span class="comment">// 进程等级</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 进行所有必要的初始化设置，调用该函数前不得调用其他MPI函数</span></span><br><span class="line">    <span class="comment">// 同样存在MPI_Finalize()与其对应，在他们中间可以使用MPI函数</span></span><br><span class="line">    <span class="built_in">MPI_Init</span>(<span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Init的一个目的为用户启动程序时定义由用户启动所有进程所组成的通信子，成为MPI_COMM_WORLD</span></span><br><span class="line">    <span class="comment">// 注：下面两个函数第一个参数为通信子，第二个为输出</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回通信子进程数</span></span><br><span class="line">    <span class="built_in">MPI_Comm_size</span>(MPI_COMM_WORLD, &amp;comm_sz);</span><br><span class="line">    <span class="comment">// 返回正在调用进程在通信子中的进程号</span></span><br><span class="line">    <span class="built_in">MPI_Comm_rank</span>(MPI_COMM_WORLD, &amp;my_rank);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 消息发送与接收</span></span><br><span class="line">    <span class="comment">// 消息发送</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    int MPI_Send(</span></span><br><span class="line"><span class="comment">        void* msg_buf_p      , //指向包含信息内容的指针</span></span><br><span class="line"><span class="comment">        int   msg_size       ,</span></span><br><span class="line"><span class="comment">        MPI_Datatype msg_type, //数据量</span></span><br><span class="line"><span class="comment">        int   dest           , //目的</span></span><br><span class="line"><span class="comment">        int   tag            , //标签</span></span><br><span class="line"><span class="comment">        MPI_Comm communicator);//通信子</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="comment">// 消息接收</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    int MPI_Recv(</span></span><br><span class="line"><span class="comment">        void* msg_buf_p      ,</span></span><br><span class="line"><span class="comment">        int   buf_size       ,</span></span><br><span class="line"><span class="comment">        MPI_Datatype         ,</span></span><br><span class="line"><span class="comment">        int   source         ,</span></span><br><span class="line"><span class="comment">        int   tag            ,</span></span><br><span class="line"><span class="comment">        MPI_Comm communicator,</span></span><br><span class="line"><span class="comment">        MPI_Status* status_p //是一个输出！</span></span><br><span class="line"><span class="comment">        );</span></span><br><span class="line"><span class="comment">    )</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="comment">// 当recv_type = send_type &amp;&amp; recv_buf_sz &gt;= send_buf_sz，则可以被接受</span></span><br><span class="line">    <span class="comment">// 接收的SOURCE核TAG有通配符，但通信子没有。</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 0号进程用于接收信息并打印</span></span><br><span class="line">    <span class="keyword">if</span> (my_rank == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;I&#x27;m main process, greetings from process %d of %d!\n&quot;</span>, my_rank, comm_sz);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; comm_sz; i++) &#123;</span><br><span class="line">            <span class="comment">// 使用MPI_ANY_SOURCE保证按完成工作顺序打印,MPI_ANY_TAG同理</span></span><br><span class="line">            <span class="comment">//MPI_Recv(greeting, MAX_STRING, MPI_CHAR, i, 0, MPI_COMM_WORLD, MPI_STATUSES_IGNORE);</span></span><br><span class="line">            <span class="built_in">MPI_Recv</span>(greeting, MAX_STRING, MPI_CHAR, MPI_ANY_SOURCE, <span class="number">0</span>, MPI_COMM_WORLD, MPI_STATUSES_IGNORE);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, greeting);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 其他进程用于发送信息</span></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 输出信息到字符串greeting中</span></span><br><span class="line">        <span class="built_in">sprintf_s</span>(greeting, <span class="string">&quot;Greetings from process %d of %d!&quot;</span>, my_rank, comm_sz);</span><br><span class="line">        <span class="comment">// 将消息发送给0号进程</span></span><br><span class="line">        <span class="built_in">MPI_Send</span>(greeting, <span class="built_in">strlen</span>(greeting) + <span class="number">1</span>, MPI_CHAR, <span class="number">0</span>, <span class="number">0</span>, MPI_COMM_WORLD);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// MPI_Status 结构体，对其成员访问分别获取source和tag信息：</span></span><br><span class="line">    <span class="comment">// status.MPI_SOURCE</span></span><br><span class="line">    <span class="comment">// status.MPI_TAG</span></span><br><span class="line">    <span class="comment">// 通过MPI_Get_count(&amp;status, recv_type, &amp;count)获取到接受元素的数量（返回到count中）</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="built_in">MPI_Finalize</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="利用mpi实现梯形积分点对点通信"><a class="markdownIt-Anchor" href="#利用mpi实现梯形积分点对点通信"></a> 利用MPI实现梯形积分（点对点通信）</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 2. 利用MPI实现梯形积分（点对点通信）</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    设计一个并行程序：</span></span><br><span class="line"><span class="comment">    1. 将问题划分为多个任务</span></span><br><span class="line"><span class="comment">    2. 在任务间识别出需要的通信信道</span></span><br><span class="line"><span class="comment">    3. 将任务聚合为复合任务</span></span><br><span class="line"><span class="comment">    4. 在核上分配任务</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">this_function</span><span class="params">(<span class="keyword">double</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    输入：只允许0号进程进行输入</span></span><br><span class="line"><span class="comment">    输出：可能乱序，需要自己进行编写</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">Trap</span><span class="params">(<span class="keyword">double</span> left, <span class="keyword">double</span> right, <span class="keyword">double</span> n, <span class="keyword">double</span> h)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">double</span> res = <span class="built_in">this_function</span>(left) / <span class="number">2</span> + <span class="built_in">this_function</span>(right) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        res += <span class="built_in">this_function</span>(left + h * i);</span><br><span class="line">    &#125;</span><br><span class="line">    res = res * h;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Trapezoids</span> <span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> my_rank, comm_sz, n;</span><br><span class="line">    <span class="built_in">MPI_Init</span>(<span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">int</span> left, right;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">MPI_Comm_size</span>(MPI_COMM_WORLD, &amp;comm_sz);</span><br><span class="line">    <span class="built_in">MPI_Comm_rank</span>(MPI_COMM_WORLD, &amp;my_rank);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 0号进程进行输入</span></span><br><span class="line">    <span class="keyword">if</span> (my_rank == <span class="number">0</span>) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Input a, b and n\n&quot;</span>;</span><br><span class="line">        cin &gt;&gt; left &gt;&gt; right &gt;&gt; n;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> dest = <span class="number">1</span>; dest &lt; comm_sz; dest++) &#123;</span><br><span class="line">            <span class="built_in">MPI_Send</span>(&amp;left, <span class="number">1</span>, MPI_INT, dest, <span class="number">0</span>, MPI_COMM_WORLD);</span><br><span class="line">            <span class="built_in">MPI_Send</span>(&amp;right, <span class="number">1</span>, MPI_INT, dest, <span class="number">0</span>, MPI_COMM_WORLD);</span><br><span class="line">            <span class="built_in">MPI_Send</span>(&amp;n, <span class="number">1</span>, MPI_INT, dest, <span class="number">0</span>, MPI_COMM_WORLD);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 其他进程读取输入</span></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">MPI_Recv</span>(&amp;left, <span class="number">1</span>, MPI_INT, <span class="number">0</span>, <span class="number">0</span>, MPI_COMM_WORLD, MPI_STATUS_IGNORE);</span><br><span class="line">        <span class="built_in">MPI_Recv</span>(&amp;right, <span class="number">1</span>, MPI_INT, <span class="number">0</span>, <span class="number">0</span>, MPI_COMM_WORLD, MPI_STATUS_IGNORE);</span><br><span class="line">        <span class="built_in">MPI_Recv</span>(&amp;n, <span class="number">1</span>, MPI_INT, <span class="number">0</span>, <span class="number">0</span>, MPI_COMM_WORLD, MPI_STATUS_IGNORE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算负责区域的左右区间、分段数量</span></span><br><span class="line">    <span class="keyword">int</span> h = (right - left) / n;</span><br><span class="line">    <span class="keyword">int</span> local_n = n / comm_sz;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> local_left = left + my_rank * h * local_n;</span><br><span class="line">    <span class="keyword">int</span> local_right = right + my_rank * h * local_n;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在负责区域进行串行计算</span></span><br><span class="line">    <span class="keyword">double</span> local_res = <span class="built_in">Trap</span>(local_left, local_right, local_n, h);</span><br><span class="line">    <span class="keyword">double</span> total_res = local_res;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回结果</span></span><br><span class="line">    <span class="keyword">if</span> (my_rank != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">MPI_Send</span>(&amp;local_res, <span class="number">1</span>, MPI_DOUBLE, <span class="number">0</span>, <span class="number">0</span>, MPI_COMM_WORLD);</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;I&#x27;m process &quot;</span> &lt;&lt; my_rank &lt;&lt; <span class="string">&quot;, I send the result&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; comm_sz; i++) &#123;</span><br><span class="line">            <span class="built_in">MPI_Recv</span>(&amp;local_res, <span class="number">1</span>, MPI_DOUBLE, i, <span class="number">0</span>, MPI_COMM_WORLD, MPI_STATUS_IGNORE);</span><br><span class="line">            total_res += local_res;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 0号进程输出结果</span></span><br><span class="line">    <span class="keyword">if</span> (my_rank == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;With n = %d trapezoids, our estimate\n&quot;</span>, n);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;of the integral from %f to %f = %.15e\n&quot;</span>, left, right, total_res);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">MPI_Finalize</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="集合通信"><a class="markdownIt-Anchor" href="#集合通信"></a> 集合通信</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    集合通信：设计通信子中所有进程的通信函数</span></span><br><span class="line"><span class="comment">    点对点通信：MPI_Send类似</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    一些集合通信的注意事项：</span></span><br><span class="line"><span class="comment">    1. 通信子内所有进程必须调用相同的集合通信函数</span></span><br><span class="line"><span class="comment">    2. 参数必须相容，如dest_process都应该相同</span></span><br><span class="line"><span class="comment">    3. output_data_p只作用于dest_process</span></span><br><span class="line"><span class="comment">    4. 集合通信函数只通过通信子和调用顺序进行匹配！！！调用顺序很重要！P69表3-3</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 集合通信解决梯形积分</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">int MPI_Reduce(</span></span><br><span class="line"><span class="comment">    void*           input_data_p,</span></span><br><span class="line"><span class="comment">    void*           output_data_p,</span></span><br><span class="line"><span class="comment">    int             count,</span></span><br><span class="line"><span class="comment">    MPI_Datatype    datatype,</span></span><br><span class="line"><span class="comment">    MPI_Op          operator,</span></span><br><span class="line"><span class="comment">    int             dest_process,</span></span><br><span class="line"><span class="comment">    MPI_Comm        comm</span></span><br><span class="line"><span class="comment">)</span></span><br><span class="line"><span class="comment">    MPI_Allreduce 将计算的结果返回给所有进程，参数表同Reduce，但是没有dest</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    广播函数：MPI_Bcast(data_p(in/out), count, data_type, source_proc, comm)</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">// 使用广播函数获取输入并分发</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Get_input</span><span class="params">(<span class="keyword">int</span> my_rank, <span class="keyword">int</span> comm_sz, <span class="keyword">double</span>* a_p, <span class="keyword">double</span>* b_p, <span class="keyword">int</span>* n_p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (my_rank == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Input a, b and n.\n&quot;</span>);</span><br><span class="line">        <span class="built_in">scanf_s</span>(<span class="string">&quot;%lf%lf%d&quot;</span>, a_p, b_p, n_p);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">MPI_Bcast</span>(a_p, <span class="number">1</span>, MPI_DOUBLE, <span class="number">0</span>, MPI_COMM_WORLD);</span><br><span class="line">    <span class="built_in">MPI_Bcast</span>(b_p, <span class="number">1</span>, MPI_DOUBLE, <span class="number">0</span>, MPI_COMM_WORLD);</span><br><span class="line">    <span class="built_in">MPI_Bcast</span>(n_p, <span class="number">1</span>, MPI_INT, <span class="number">0</span>, MPI_COMM_WORLD);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    散射：MPI_Scatter()</span></span><br><span class="line"><span class="comment">    限制：块划分法+块大小相同</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">// 读取向量并划分分发</span></span><br><span class="line"><span class="comment">// 以下仅考虑可以整除的情况，习题3.13将讨论不可整除</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Read_vector</span><span class="params">(<span class="keyword">double</span> local_a[], <span class="keyword">int</span> local_n, <span class="keyword">int</span> n, </span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">char</span> vector_name[], <span class="keyword">int</span> my_rank, MPI_Comm comm)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">double</span>* a = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span> (my_rank == <span class="number">0</span>) &#123;</span><br><span class="line">        a = (<span class="keyword">double</span>*) <span class="built_in">malloc</span>(n * <span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">double</span>));</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="built_in">scanf_s</span>(<span class="string">&quot;%lf&quot;</span>, &amp;a[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">MPI_Scatter</span>(a, local_n, MPI_DOUBLE, local_a, local_n, MPI_DOUBLE, <span class="number">0</span>, comm);</span><br><span class="line">        <span class="built_in">free</span>(a);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">MPI_Scatter</span>(a, local_n, MPI_DOUBLE, local_a, local_n, MPI_DOUBLE, <span class="number">0</span>, comm);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    聚集：MPI_Gather()</span></span><br><span class="line"><span class="comment">    注：recv_count 指的是每个进程接收到的数据量</span></span><br><span class="line"><span class="comment">    限制：块划分法+块大小相同</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Print_vector</span><span class="params">(<span class="keyword">double</span> local_b[], <span class="keyword">int</span> local_n, <span class="keyword">int</span> n, <span class="keyword">char</span> title[], <span class="keyword">int</span> my_rank, MPI_Comm comm)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">double</span>* a = (<span class="keyword">double</span>*)<span class="built_in">malloc</span>(n * <span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">double</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (my_rank == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">MPI_Gather</span>(local_b, local_n, MPI_DOUBLE, a, local_n, MPI_DOUBLE, <span class="number">0</span>, MPI_COMM_WORLD);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, title);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) <span class="built_in">printf</span>(<span class="string">&quot;%lf &quot;</span>, a[i]);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">        <span class="built_in">free</span>(a);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">MPI_Gather</span>(local_b, local_n, MPI_DOUBLE, a, local_n, MPI_DOUBLE, <span class="number">0</span>, MPI_COMM_WORLD);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    全局聚集：MPI_Allgather()：相当于MPI_Gather + MPI_Bcast</span></span><br><span class="line"><span class="comment">    将每个进程Send_p的内容串联起来放到Recv_p中</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">// 矩阵与向量相乘</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Matirx_Mul_Vector</span><span class="params">(<span class="keyword">double</span> local_A[], <span class="keyword">double</span> local_x[], <span class="keyword">double</span> local_y[], </span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">int</span> local_m, <span class="keyword">int</span> n,<span class="keyword">int</span> local_n, <span class="keyword">int</span> my_rank, MPI_Comm comm)</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">double</span>* x;</span><br><span class="line"></span><br><span class="line">    x = (<span class="keyword">double</span>*)<span class="built_in">malloc</span>(n * <span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">double</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 因为此处，函数得到的是划分后的x，但是运算需要整个x向量，故需要Allgather进行向量补全</span></span><br><span class="line">    <span class="built_in">MPI_Allgather</span>(local_x, local_n, MPI_DOUBLE, x, local_n, MPI_DOUBLE, comm);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> local_i = <span class="number">0</span>; local_i &lt; local_m; local_i++) &#123;</span><br><span class="line">        local_y[local_i] = <span class="number">0.0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++)</span><br><span class="line">            local_y[local_i] += local_A[local_i * n + j] * x[j];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">free</span>(x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="信息整合"><a class="markdownIt-Anchor" href="#信息整合"></a> 信息整合</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    MPI提供的三个整合多条消息数据的手段：</span></span><br><span class="line"><span class="comment">    1. count</span></span><br><span class="line"><span class="comment">    2. 派生数据类型</span></span><br><span class="line"><span class="comment">    3. pack/unpack</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 派生数据类型：如果发送数据的函数知道数据项的类型以及在内存中数据项集合的相对位置，</span></span><br><span class="line"><span class="comment">   就可以在数据项被发送出去之前在内存中将数据项聚集起来。</span></span><br><span class="line"><span class="comment">   组成：数据类型 + 偏移</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">   派生数据类型更像是将每一个指定位移的数据的偏移量记录下来，每次通信的时候传输这些数据</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">// 创建派生数据类型</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">int MPI_Type_create_struct(</span></span><br><span class="line"><span class="comment">    int count,                          // 数据类型中的元素个数，下面各个参数数组都有count个元素</span></span><br><span class="line"><span class="comment">    int array_of_blocklengths[],        // 允许单独数据项为数组或子数组，如第一个元素是一个含5个元素的数组，则aob[0] = 5</span></span><br><span class="line"><span class="comment">    MPI_Aint array_of_displacements[],  // 距离消息起始位置的偏移量,单位为字节</span></span><br><span class="line"><span class="comment">    MPI_Datatype array_of_types[],      // 数据类型</span></span><br><span class="line"><span class="comment">    MPI_Datatype* new_type_p    (out)</span></span><br><span class="line"><span class="comment">    )</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">// 使用前需要指定</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">int MPI_Type_commit(MPI_Datatype* new_type_p);</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用派生数据类型的Get_input</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">原：</span></span><br><span class="line"><span class="comment">void Get_input(int my_rank, int comm_sz, double* a_p, double* b_p, int* n_p) &#123;</span></span><br><span class="line"><span class="comment">    if (my_rank == 0) &#123;</span></span><br><span class="line"><span class="comment">        printf(&quot;Input a, b and n.\n&quot;);</span></span><br><span class="line"><span class="comment">        scanf_s(&quot;%lf%lf%d&quot;, a_p, b_p, n_p);</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    MPI_Bcast(a_p, 1, MPI_DOUBLE, 0, MPI_COMM_WORLD);</span></span><br><span class="line"><span class="comment">    MPI_Bcast(b_p, 1, MPI_DOUBLE, 0, MPI_COMM_WORLD);</span></span><br><span class="line"><span class="comment">    MPI_Bcast(n_p, 1, MPI_INT, 0, MPI_COMM_WORLD);</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    修改后</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Build_mpi_type</span><span class="params">(<span class="keyword">double</span>* a_p, <span class="keyword">double</span>* b_p, <span class="keyword">int</span>* n_p, MPI_Datatype* data_type)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> array_of_blocklengths[<span class="number">3</span>] = &#123; <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span> &#125;;</span><br><span class="line">    MPI_Datatype array_of_types[<span class="number">3</span>] = &#123; MPI_DOUBLE, MPI_DOUBLE, MPI_INT &#125;;</span><br><span class="line">    MPI_Aint a_addr, b_addr, n_addr;</span><br><span class="line">    MPI_Aint array_of_addr[<span class="number">3</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">MPI_Get_address</span>(a_p, &amp;a_addr);</span><br><span class="line">    <span class="built_in">MPI_Get_address</span>(b_p, &amp;b_addr);</span><br><span class="line">    <span class="built_in">MPI_Get_address</span>(n_p, &amp;n_addr);</span><br><span class="line"></span><br><span class="line">    array_of_addr[<span class="number">1</span>] = b_addr - a_addr;</span><br><span class="line">    array_of_addr[<span class="number">2</span>] = n_addr - b_addr;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">MPI_Type_create_struct</span>(<span class="number">3</span>, array_of_blocklengths, array_of_addr, array_of_types, data_type);</span><br><span class="line">    <span class="built_in">MPI_Type_commit</span>(data_type);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Get_input_new</span><span class="params">(<span class="keyword">int</span> my_rank, <span class="keyword">int</span> comm_sz, <span class="keyword">double</span>* a_p, <span class="keyword">double</span>* b_p, <span class="keyword">int</span>* n_p)</span> </span>&#123;</span><br><span class="line">    MPI_Datatype <span class="keyword">input_mpi_t</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Build_mpi_type</span>(a_p, b_p, n_p, &amp;<span class="keyword">input_mpi_t</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (my_rank == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Input a, b and n.\n&quot;</span>);</span><br><span class="line">        <span class="built_in">scanf_s</span>(<span class="string">&quot;%lf%lf%d&quot;</span>, a_p, b_p, n_p);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">MPI_Bcast</span>(a_p, <span class="number">1</span>, <span class="keyword">input_mpi_t</span>, <span class="number">0</span>, MPI_COMM_WORLD);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">MPI_Type_free</span>(&amp;<span class="keyword">input_mpi_t</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="并行排序算法分布式算法实现"><a class="markdownIt-Anchor" href="#并行排序算法分布式算法实现"></a> 并行排序算法——分布式算法实现</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 冒泡排序变种——奇偶交换排序</span></span><br><span class="line"><span class="comment">// 找寻交换进程号</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ComputePartner</span><span class="params">(<span class="keyword">int</span> my_rank, <span class="keyword">int</span> comm_sz, <span class="keyword">int</span> phase, <span class="keyword">int</span>&amp; partner)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (phase % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (my_rank % <span class="number">2</span> == <span class="number">0</span>)</span><br><span class="line">            partner = my_rank + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> partner = my_rank - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (my_rank % <span class="number">2</span> == <span class="number">0</span>)</span><br><span class="line">            partner = my_rank - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> partner = my_rank + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (partner == <span class="number">-1</span> || partner == comm_sz)</span><br><span class="line">        <span class="comment">// 注：MPI_PROC_NULL作为源进程或目标进程进程号时，调用通信函数直接返回，不产生通信</span></span><br><span class="line">        partner = MPI_PROC_NULL;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注：MPI_Send有两种发送方式，如果数据量较大可能会造成阻塞发送，可能导致死锁。</span></span><br><span class="line"><span class="comment">// 问题：程序安全如何保证？使用MPI_Ssend（表示同步，发送如果没被接受便阻塞）</span></span><br><span class="line"><span class="comment">// 问题：怎么修改奇偶排序使其安全？重构通信。</span></span><br><span class="line"><span class="comment">// MPI_Sendrecv() 阻塞式发送接收，可以保证安全</span></span><br><span class="line"><span class="comment">// MPI_Sendrecv_replace() 发送和接受使用的是同一个缓冲区</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 奇偶冒泡</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Merge_low</span><span class="params">(<span class="keyword">int</span> my_keys[], <span class="keyword">int</span> recv_keys[], <span class="keyword">int</span> temp_keys[], <span class="keyword">int</span> local_n, <span class="keyword">bool</span> flag)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> m_i = <span class="number">0</span>, r_i = <span class="number">0</span>, t_i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (!flag) &#123;</span><br><span class="line">        m_i = local_n - <span class="number">1</span>;</span><br><span class="line">        r_i = local_n - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// flag为true时，交换代表前一个线程（取小），反之取大。</span></span><br><span class="line">    <span class="comment">// 每次前一线程取小，后一线程取大</span></span><br><span class="line">    <span class="keyword">while</span> (t_i &lt; local_n) &#123;</span><br><span class="line">        <span class="keyword">if</span> (flag) &#123;</span><br><span class="line">            <span class="keyword">if</span> (my_keys[m_i] &lt; recv_keys[r_i]) &#123;</span><br><span class="line">                temp_keys[t_i] = my_keys[m_i];</span><br><span class="line">                t_i++; m_i++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                temp_keys[t_i] = recv_keys[r_i];</span><br><span class="line">                t_i++; r_i++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (my_keys[m_i] &gt; recv_keys[r_i]) &#123;</span><br><span class="line">                temp_keys[t_i] = my_keys[m_i];</span><br><span class="line">                t_i++; m_i--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                temp_keys[t_i] = recv_keys[r_i];</span><br><span class="line">                t_i++; r_i--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (flag) <span class="keyword">for</span> (m_i = <span class="number">0</span>; m_i &lt; local_n; m_i++) my_keys[m_i] = temp_keys[m_i];</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">for</span> (m_i = local_n - <span class="number">1</span>; m_i &gt;= <span class="number">0</span>; m_i--) my_keys[local_n - m_i - <span class="number">1</span>] = temp_keys[m_i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">compare</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span>* e1, <span class="keyword">const</span> <span class="keyword">void</span>* e2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//将void*类型的指针e1和e2强制类型转换成int*型</span></span><br><span class="line">    <span class="keyword">return</span>  *((<span class="keyword">int</span>*)e1) - *((<span class="keyword">int</span>*)e2);</span><br><span class="line">    <span class="comment">//一定要强制类型转换，因为e1和e2都是void*指针，没有类型的指针</span></span><br><span class="line">    <span class="comment">//如果不想要升序排列，想要按降序排列，就可以return  *((int*)e2) - *((int *)e1);</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">My_Sort</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> my_rank, comm_sz, n;</span><br><span class="line">    <span class="keyword">int</span>* array = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="built_in">MPI_Init</span>(<span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">MPI_Comm_size</span>(MPI_COMM_WORLD, &amp;comm_sz);</span><br><span class="line">    <span class="built_in">MPI_Comm_rank</span>(MPI_COMM_WORLD, &amp;my_rank);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 进程0读入</span></span><br><span class="line">    <span class="keyword">if</span> (my_rank == <span class="number">0</span>) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Input size of array:&quot;</span>;</span><br><span class="line">        cin &gt;&gt; n;</span><br><span class="line"></span><br><span class="line">        array = (<span class="keyword">int</span>*)<span class="built_in">malloc</span>(<span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">int</span>) * n);</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            cin &gt;&gt; array[i];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 广播总个数</span></span><br><span class="line">    <span class="built_in">MPI_Bcast</span>(&amp;n, <span class="number">1</span>, MPI_INT, <span class="number">0</span>, MPI_COMM_WORLD);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// local_n代表每个进程分配的元素个数</span></span><br><span class="line">    <span class="keyword">int</span> local_n = n / comm_sz;</span><br><span class="line">    <span class="comment">// cout &lt;&lt; &quot;local_n&quot; &lt;&lt; local_n &lt;&lt; endl;</span></span><br><span class="line">    <span class="keyword">int</span>* local_array = (<span class="keyword">int</span>*)<span class="built_in">malloc</span>(<span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">int</span>) * local_n);</span><br><span class="line">    <span class="comment">// if (my_rank == 0) for (int i = 0; i &lt; local_n; i++) local_array[i] = array[i];</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 分配元素</span></span><br><span class="line">    <span class="built_in">MPI_Scatter</span>(array, local_n, MPI_INT, local_array, local_n, MPI_INT, <span class="number">0</span>, MPI_COMM_WORLD);</span><br><span class="line">    <span class="comment">//cout &lt;&lt; &quot;Process&quot; &lt;&lt; my_rank &lt;&lt; &quot; &#x27;s array is &quot; &lt;&lt; local_array[0] &lt;&lt; endl;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">101</span>; i++) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>* local_receive = (<span class="keyword">int</span>*)<span class="built_in">malloc</span>(<span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">int</span>) * local_n);</span><br><span class="line">        <span class="keyword">int</span>* local_temp = (<span class="keyword">int</span>*)<span class="built_in">malloc</span>(<span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">int</span>) * local_n);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> partner;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 计算本回合交换目标</span></span><br><span class="line">        <span class="built_in">ComputePartner</span>(my_rank, comm_sz, i, partner);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// cout &lt;&lt; &quot;epoch&quot; &lt;&lt; i &lt;&lt; &quot; &quot; &lt;&lt; &quot;Process&quot; &lt;&lt; my_rank &lt;&lt; &quot; &#x27;s partner is &quot; &lt;&lt; partner &lt;&lt; endl;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 本进程元素排序</span></span><br><span class="line">        <span class="built_in">qsort</span>(local_array, local_n, <span class="built_in"><span class="keyword">sizeof</span></span>(local_array[<span class="number">0</span>]), compare);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 互发元素元素</span></span><br><span class="line">        <span class="built_in">MPI_Sendrecv</span>(local_array, local_n, MPI_INT, partner, <span class="number">0</span>, </span><br><span class="line">            local_receive, local_n, MPI_INT, partner, <span class="number">0</span>, MPI_COMM_WORLD, MPI_STATUSES_IGNORE);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// cout &lt;&lt; &quot;epoch&quot; &lt;&lt; i &lt;&lt; &quot; &quot; &lt;&lt; &quot;Process&quot; &lt;&lt; my_rank &lt;&lt; &quot; &#x27;s recv is &quot; &lt;&lt; local_receive[0] &lt;&lt; &quot;and&quot; &lt;&lt; local_receive[1] &lt;&lt; endl;</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">bool</span> flag = (i % <span class="number">2</span> == <span class="number">0</span>) &amp;&amp; (my_rank % <span class="number">2</span> == <span class="number">0</span>) || (i % <span class="number">2</span> == <span class="number">1</span>) &amp;&amp; (my_rank % <span class="number">2</span> == <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (partner != MPI_PROC_NULL)</span><br><span class="line">            <span class="built_in">Merge_low</span>(local_array, local_receive, local_temp, local_n, flag);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// cout &lt;&lt; &quot;epoch&quot; &lt;&lt; i &lt;&lt; &quot; &quot; &lt;&lt; &quot;Process&quot; &lt;&lt; my_rank &lt;&lt; &quot; &#x27;s sorted array is &quot; &lt;&lt; local_array[0] &lt;&lt; &quot;and&quot; &lt;&lt; local_array[1] &lt;&lt; endl;</span></span><br><span class="line"></span><br><span class="line">        <span class="built_in">free</span>(local_receive);</span><br><span class="line">        <span class="built_in">free</span>(local_temp);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 收集最后结果</span></span><br><span class="line">    <span class="built_in">MPI_Gather</span>(local_array, local_n, MPI_INT, array, local_n, MPI_INT, <span class="number">0</span>, MPI_COMM_WORLD);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (my_rank == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) cout &lt;&lt; array[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    <span class="built_in">MPI_Finalize</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="openmp"><a class="markdownIt-Anchor" href="#openmp"></a> OpenMP</h1><h2 id="第一个openmp程序"><a class="markdownIt-Anchor" href="#第一个openmp程序"></a> 第一个OpenMP程序</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> _OPENMP</span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">include</span><span class="meta-string">&lt;omp.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Hello_world</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span> </span>&#123;</span><br><span class="line">    <span class="comment">/* 得到线程数 */</span></span><br><span class="line">    <span class="keyword">int</span> thread_count = <span class="built_in">strtol</span>(argv[<span class="number">1</span>], <span class="literal">NULL</span>, <span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// #pragma 开头，代表预处理器指令，如果不支持pragma的编译器会忽略该指令</span></span><br><span class="line">    <span class="comment">// parallel代表结构化代码块，是一条C语句或一个入口和一个出口的复合C语句</span></span><br><span class="line">    <span class="comment">// parallel指令添加num_threads子句(子句是修改指令的文本)</span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">pragma</span> omp parallel num_threads(thread_count)</span></span><br><span class="line">    <span class="built_in">Hello_world</span>();</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        执行parallel指令后，thread_count - 1个线程被启动，</span></span><br><span class="line"><span class="comment">        原始线程成为主线程master,额外线程称为从线程slave</span></span><br><span class="line"><span class="comment">        master + slave称为线程组，线程组每个线程都执行parallel后的代码块</span></span><br><span class="line"><span class="comment">        该处存在一个隐式路障，当所有线程执行完代码块，从线程终止，主线程才继续执行</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Hello_world</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 得到自己的线程编号</span></span><br><span class="line">    <span class="keyword">int</span> my_rank = <span class="built_in">omp_get_thread_num</span>();</span><br><span class="line">    <span class="comment">// 得到线程组中的线程数</span></span><br><span class="line">    <span class="keyword">int</span> thread_count = <span class="built_in">omp_get_num_threads</span>();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Hello world from thread %d of %d\n&quot;</span>, my_rank, thread_count);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="openmp实现梯形积分法"><a class="markdownIt-Anchor" href="#openmp实现梯形积分法"></a> OpenMP实现梯形积分法</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> _OPENMP</span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">include</span><span class="meta-string">&lt;omp.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Trap</span><span class="params">(<span class="keyword">double</span> a, <span class="keyword">double</span> b, <span class="keyword">int</span> n, </span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">double</span>* global_result_p)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">f</span><span class="params">(<span class="keyword">double</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">double</span> y = x;</span><br><span class="line">    <span class="keyword">return</span> y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">double</span> global_result = <span class="number">0.0</span>;</span><br><span class="line">    <span class="keyword">double</span> a, b;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">int</span> thread_count = <span class="built_in">strtol</span>(argv[<span class="number">1</span>], <span class="literal">NULL</span>, <span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Input a, b and n\n&quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%lf %lf %d&quot;</span>, &amp;a, &amp;b, &amp;n);</span><br><span class="line"></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">pragma</span> omp parallel num_threads(thread_count)</span></span><br><span class="line">    <span class="built_in">Trap</span>(a, b, n, &amp;global_result);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Estimate of the integral = %.14e\n&quot;</span>, global_result);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Trap</span><span class="params">(<span class="keyword">double</span> a, <span class="keyword">double</span> b, <span class="keyword">int</span> n, </span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">double</span>* global_result_p)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 注意，计算并没有检查n是否能被thread_num整除，如不能需要另加修改</span></span><br><span class="line">    <span class="keyword">double</span> h, x, my_result;</span><br><span class="line">    <span class="keyword">double</span> local_a, local_b;</span><br><span class="line">    <span class="keyword">int</span> i, local_n;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> my_rank = <span class="built_in">omp_get_thread_num</span>();</span><br><span class="line">    <span class="keyword">int</span> thread_count = <span class="built_in">omp_get_num_threads</span>();</span><br><span class="line"></span><br><span class="line">    h = (b - a) / n;</span><br><span class="line">    local_n = n / thread_count;</span><br><span class="line">    local_a = a + my_rank * local_n * h;</span><br><span class="line">    local_b = local_a + h * local_n;</span><br><span class="line"></span><br><span class="line">    my_result = (<span class="built_in">f</span>(local_a) + <span class="built_in">f</span>(local_b)) / <span class="number">2.0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= local_n - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        x = local_a + i * h;</span><br><span class="line">        my_result += <span class="built_in">f</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line">    my_result *= h;</span><br><span class="line"></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">pragma</span> omp critical</span></span><br><span class="line">    *global_result_p += my_result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注意：在parallel指令前已经被声明的变量拥有在线程组中共享作用域，</span></span><br><span class="line"><span class="comment">//      而在块中声明的变量（如函数中的局部变量）有私有作用域</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 加入规约子句的Trap版本</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 我们更加习惯于不使用指针来传递临界变量：</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">Local_trap</span><span class="params">(<span class="keyword">double</span> a, <span class="keyword">double</span> b, <span class="keyword">int</span> n)</span></span>;</span><br><span class="line"><span class="comment">// 而在调用的时候，会改变parallel块如下：</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">double global_result = 0.0;</span></span><br><span class="line"><span class="comment"># pragma omp parallel num_threads(thread.count)</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">    double my_result = 0.0;</span></span><br><span class="line"><span class="comment">    my_result += Local_trap(double a, double b, int n);</span></span><br><span class="line"><span class="comment">#   pragma omp critical</span></span><br><span class="line"><span class="comment">    global_result += my_result;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// OpenMP提供归约(将相同的归约操作符重复应用到操作数序列)操作符，</span></span><br><span class="line"><span class="comment">// 所有操作的中间结果储存在归约变量中</span></span><br><span class="line"><span class="comment">// 于是我们修改parallel块如下：</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">double global_result = 0.0;</span></span><br><span class="line"><span class="comment"># pragma omp parallel num_threads(thread.count) \</span></span><br><span class="line"><span class="comment">    reduction(+: global_result)</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">    global_result += Local_trap(double a, double b, int n);</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">// reduction子句的语法：reduction(&lt;operator&gt;: &lt;variable list&gt;)</span></span><br><span class="line"><span class="comment">// operator可以为：+ * - &amp; | ^ &amp;&amp; ||</span></span><br><span class="line"><span class="comment">// 注意：</span></span><br><span class="line"><span class="comment">// 1. - 不满足交换律和结合律，OpenMP不能保证正确运行</span></span><br><span class="line"><span class="comment">// 2. 归约变量如果为double or float，浮点数运算不满足结合律，可能会有不同</span></span><br><span class="line"><span class="comment">// 3. reduction中包含的变量是共享的，但是每个线程都会创建自己的私有变量（初始化为0或1（*）等情况）</span></span><br><span class="line"><span class="comment">//    当parallel块结束时会将私有变量的值整合到共享变量中</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// parallel for指令</span></span><br><span class="line"><span class="comment">// OpenMP提供parallel for 指令，能够并行化串行积分</span></span><br><span class="line"><span class="comment">// 串行积分改进：</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Serial_Trap</span><span class="params">(<span class="keyword">double</span> h, <span class="keyword">double</span> a, <span class="keyword">double</span> b, <span class="keyword">double</span> approx, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    h = (b - a) / n;</span><br><span class="line">    approx = (<span class="built_in">f</span>(a) + <span class="built_in">f</span>(b)) / <span class="number">2.0</span>;</span><br><span class="line"><span class="meta">#   <span class="meta-keyword">pragma</span> omp parallel for num_threads(thread_count) \</span></span><br><span class="line"><span class="meta">        reduction(+: approx)</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n - <span class="number">1</span>; i++)</span><br><span class="line">        approx += <span class="built_in">f</span>(a + i * h);</span><br><span class="line">    approx = h * approx;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// parallel for与parallel指令非常不同，</span></span><br><span class="line"><span class="comment">// 在parallel指令之前的块，其工作必须由线程本身在线程之间划分</span></span><br><span class="line"><span class="comment">// parallel for指令缺省划分方式由系统决定</span></span><br><span class="line"><span class="comment">// approx必须作为归约变量，否则approx += 将变成无保护临界区</span></span><br><span class="line"><span class="comment">// 注意：parallel for中循环变量缺省作用域是私有的</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 对于parallel for的警告</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    1. 只会并行化for循环，不会并行化while, do-while</span></span><br><span class="line"><span class="comment">    2. OpenMP只能并行化确定迭代次数的for循环</span></span><br><span class="line"><span class="comment">        - 由for语句本身确定</span></span><br><span class="line"><span class="comment">        - 在循环执行前确定</span></span><br><span class="line"><span class="comment">    3. OpenMP只能并行化典型结构for循环</span></span><br><span class="line"><span class="comment">        - index必须是整形或指针类型</span></span><br><span class="line"><span class="comment">        - start, end, incr必须有一个兼容类型</span></span><br><span class="line"><span class="comment">        - start, end, incr在循环执行期间不改变</span></span><br><span class="line"><span class="comment">        - index只能由for语句中增量表达式修改</span></span><br><span class="line"><span class="comment">    4. 唯一例外：循环体中可以有一个exit调用</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 数据依赖性</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    OpenMP编译器不检查被parallel for指令并行化的循环所包含的迭代间依赖关系</span></span><br><span class="line"><span class="comment">    当使用parallel for指令时要寻找循环依赖</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h2 id="parallel-for的数据-循环依赖"><a class="markdownIt-Anchor" href="#parallel-for的数据-循环依赖"></a> parallel for的数据、循环依赖</h2><p>以估算<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>π</mi></mrow><annotation encoding="application/x-tex">\pi</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">π</span></span></span></span>为例：</p><p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>π</mi><mo>=</mo><mn>4</mn><mo stretchy="false">[</mo><mn>1</mn><mo>−</mo><mstyle displaystyle="true" scriptlevel="0"><mfrac><mn>1</mn><mn>3</mn></mfrac></mstyle><mo>+</mo><mstyle displaystyle="true" scriptlevel="0"><mfrac><mn>1</mn><mn>5</mn></mfrac></mstyle><mo>−</mo><mstyle displaystyle="true" scriptlevel="0"><mfrac><mn>1</mn><mn>7</mn></mfrac></mstyle><mo>+</mo><mo>…</mo><mtext> </mtext><mo stretchy="false">]</mo><mo>=</mo><mn>4</mn><msubsup><mo>∑</mo><mrow><mi>k</mi><mo>=</mo><mn>0</mn></mrow><mi mathvariant="normal">∞</mi></msubsup><mstyle displaystyle="true" scriptlevel="0"><mfrac><mrow><mo stretchy="false">(</mo><mo>−</mo><mn>1</mn><msup><mo stretchy="false">)</mo><mi>k</mi></msup></mrow><mrow><mn>2</mn><mi>k</mi><mo>+</mo><mn>1</mn></mrow></mfrac></mstyle></mrow><annotation encoding="application/x-tex">\pi=4[1-\dfrac{1}{3}+\dfrac{1}{5}-\dfrac{1}{7}+\dots]=4\sum^{\infty}_{k=0}\dfrac{(-1)^k}{2k+1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">π</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">4</span><span class="mopen">[</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:2.00744em;vertical-align:-0.686em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.32144em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">3</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:2.00744em;vertical-align:-0.686em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.32144em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">5</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:2.00744em;vertical-align:-0.686em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.32144em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">7</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="minner">…</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.295438em;vertical-align:-0.7693300000000001em;"></span><span class="mord">4</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop"><span class="mop op-symbol small-op" style="position:relative;top:-0.0000050000000000050004em;">∑</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.804292em;"><span style="top:-2.40029em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span><span class="mrel mtight">=</span><span class="mord mtight">0</span></span></span></span><span style="top:-3.2029em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">∞</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.29971000000000003em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.526108em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">2</span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord">1</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mopen">(</span><span class="mord">−</span><span class="mord">1</span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.849108em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.7693300000000001em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 数据依赖性</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    OpenMP编译器不检查被parallel for指令并行化的循环所包含的迭代间依赖关系</span></span><br><span class="line"><span class="comment">    当使用parallel for指令时要寻找循环依赖</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> _OPENMP</span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">include</span><span class="meta-string">&lt;omp.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">serial_pai</span><span class="params">(<span class="keyword">int</span> thread_count, <span class="keyword">int</span> n)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">parallel_pai_1_0</span><span class="params">(<span class="keyword">int</span> thread_count, <span class="keyword">int</span> n)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">parallel_pai_1_1</span><span class="params">(<span class="keyword">int</span> thread_count, <span class="keyword">int</span> n)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">parallel_pai</span><span class="params">(<span class="keyword">int</span> thread_count, <span class="keyword">int</span> n)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> thread_count = <span class="built_in">strtol</span>(argv[<span class="number">1</span>], <span class="literal">NULL</span>, <span class="number">10</span>);</span><br><span class="line">    <span class="comment">// serial_pai(thread_count, 1000);</span></span><br><span class="line">    <span class="comment">// parallel_pai_1_0(thread_count, 1000);</span></span><br><span class="line">    <span class="comment">// parallel_pai_1_1(thread_count, 1000);</span></span><br><span class="line">    <span class="built_in">parallel_pai</span>(thread_count, <span class="number">1000</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 串行代码</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">serial_pai</span><span class="params">(<span class="keyword">int</span> thread_count, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">double</span> factor = <span class="number">1.0</span>;</span><br><span class="line">    <span class="keyword">double</span> sum = <span class="number">0.0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; n; k++) &#123;</span><br><span class="line">        sum += factor / (<span class="number">2</span> * k + <span class="number">1</span>);</span><br><span class="line">        factor = -factor;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">double</span> pi_approx = <span class="number">4.0</span> * sum;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;pai: %lf\n&quot;</span>, pi_approx);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 并行1.0</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">parallel_pai_1_0</span><span class="params">(<span class="keyword">int</span> thread_count,  <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">double</span> factor = <span class="number">1.0</span>;</span><br><span class="line">    <span class="keyword">double</span> sum = <span class="number">0.0</span>;</span><br><span class="line"><span class="meta">#   <span class="meta-keyword">pragma</span> omp parallel for num_threads(thread_count)\</span></span><br><span class="line"><span class="meta">        reduction(+: sum)</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; n; k++) &#123;</span><br><span class="line">        sum += factor / (<span class="number">2</span> * k + <span class="number">1</span>);</span><br><span class="line">        <span class="comment">// !!!该处存在数据依赖性，若k次迭代在一个线程，k+1次在另一个线程，</span></span><br><span class="line">        <span class="comment">// 会导致factor值错误</span></span><br><span class="line">        factor = -factor;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">double</span> pi_approx = <span class="number">4.0</span> * sum;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;pai: %lf\n&quot;</span>, pi_approx);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 并行1.1</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">parallel_pai_1_1</span><span class="params">(<span class="keyword">int</span> thread_count, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">double</span> factor = <span class="number">1.0</span>;</span><br><span class="line">    <span class="keyword">double</span> sum = <span class="number">0.0</span>;</span><br><span class="line"><span class="meta">#   <span class="meta-keyword">pragma</span> omp parallel for num_threads(thread_count)\</span></span><br><span class="line"><span class="meta">        reduction(+: sum)</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; n; k++) &#123;</span><br><span class="line">        factor = (k % <span class="number">2</span> == <span class="number">0</span>) ? <span class="number">1.0</span> : <span class="number">-1.0</span>;</span><br><span class="line">        sum += factor / (<span class="number">2</span> * k + <span class="number">1</span>);</span><br><span class="line">        <span class="comment">// factor = -factor;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">double</span> pi_approx = <span class="number">4.0</span> * sum;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;pai: %lf\n&quot;</span>, pi_approx);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 问题：</span></span><br><span class="line"><span class="comment">// 注意，缺省情况下任何在循环前声明的变量在线程间都是共享的</span></span><br><span class="line"><span class="comment">// 因此factor是共享的，可能存在线程间修改导致错误，因此要保证factor私有作用域</span></span><br><span class="line"><span class="comment">// 最终版本</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">parallel_pai</span><span class="params">(<span class="keyword">int</span> thread_count, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">double</span> factor = <span class="number">1.0</span>;</span><br><span class="line">    <span class="keyword">double</span> sum = <span class="number">0.0</span>;</span><br><span class="line"><span class="meta">#   <span class="meta-keyword">pragma</span> omp parallel for num_threads(thread_count)\</span></span><br><span class="line"><span class="meta">        reduction(+: sum) private(factor)</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; n; k++) &#123;</span><br><span class="line">        factor = (k % <span class="number">2</span> == <span class="number">0</span>) ? <span class="number">1.0</span> : <span class="number">-1.0</span>;</span><br><span class="line">        sum += factor / (<span class="number">2</span> * k + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">double</span> pi_approx = <span class="number">4.0</span> * sum;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;pai: %lf\n&quot;</span>, pi_approx);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Openmp提供一个子句default(none),要求用户明确每个变量的作用域</span></span><br><span class="line"><span class="comment">// 如对pai的计算可以修改为：</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">#   pragma omp parallel for num_threads(thread_count)\</span></span><br><span class="line"><span class="comment">        default(none) reduction(+: sum) private(k, factor)\</span></span><br><span class="line"><span class="comment">        shared(n)</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h2 id="openmp实现奇偶排序"><a class="markdownIt-Anchor" href="#openmp实现奇偶排序"></a> OpenMP实现奇偶排序</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="comment">// #ifdef _OPENMP</span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">include</span><span class="meta-string">&lt;omp.h&gt;</span></span></span><br><span class="line"><span class="comment">// #endif</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">serial_odd_even_order</span><span class="params">(<span class="keyword">int</span> thread_count, <span class="keyword">int</span> a[], <span class="keyword">int</span> n)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">parallel_odd_even_order</span><span class="params">(<span class="keyword">int</span> thread_count, <span class="keyword">int</span> a[], <span class="keyword">int</span> n)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">parallel_odd_even_order_2</span><span class="params">(<span class="keyword">int</span> thread_count, <span class="keyword">int</span> a[], <span class="keyword">int</span> n)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> &amp;a, <span class="keyword">int</span> &amp;b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t = a;</span><br><span class="line">    a = b;</span><br><span class="line">    b = t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a[<span class="number">10</span>] = &#123;<span class="number">2</span>, <span class="number">1</span>, <span class="number">16</span>, <span class="number">8</span>, <span class="number">6</span>, <span class="number">0</span>, <span class="number">7</span>, <span class="number">11</span>, <span class="number">12</span>, <span class="number">15</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> thread_num = <span class="built_in">strtol</span>(argv[<span class="number">1</span>], <span class="literal">NULL</span>, <span class="number">10</span>);</span><br><span class="line">    <span class="built_in">parallel_odd_even_order_2</span>(thread_num, a, <span class="number">10</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">serial_odd_even_order</span><span class="params">(<span class="keyword">int</span> thread_count, <span class="keyword">int</span> a[], <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> phase;</span><br><span class="line">    <span class="keyword">for</span> (phase = <span class="number">0</span>; phase &lt; n; phase++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (phase % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i += <span class="number">2</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (a[i - <span class="number">1</span>] &gt; a[i]) </span><br><span class="line">                    <span class="built_in">swap</span>(a[i - <span class="number">1</span>], a[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n - <span class="number">1</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (a[i] &gt; a[i + <span class="number">1</span>]) &#123;</span><br><span class="line">                    <span class="built_in">swap</span>(a[i], a[i + <span class="number">1</span>]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// parallel 1.0</span></span><br><span class="line"><span class="comment">// 我们发现，最外层的for循环具有循环依赖，并不适合并行化</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">parallel_odd_even_order</span><span class="params">(<span class="keyword">int</span> thread_count, <span class="keyword">int</span> a[], <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> phase;</span><br><span class="line">    <span class="keyword">for</span> (phase = <span class="number">0</span>; phase &lt; n; phase++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (phase % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="meta">#           <span class="meta-keyword">pragma</span> omp parallel for num_threads(thread_count) \</span></span><br><span class="line"><span class="meta">                default(none) shared(a, n)</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i += <span class="number">2</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (a[i - <span class="number">1</span>] &gt; a[i]) </span><br><span class="line">                    <span class="built_in">swap</span>(a[i - <span class="number">1</span>], a[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="meta">#           <span class="meta-keyword">pragma</span> omp parallel for num_threads(thread_count) \</span></span><br><span class="line"><span class="meta">                default(none) shared(a, n)</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n - <span class="number">1</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (a[i] &gt; a[i + <span class="number">1</span>]) &#123;</span><br><span class="line">                    <span class="built_in">swap</span>(a[i], a[i + <span class="number">1</span>]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// parallel 2.0</span></span><br><span class="line"><span class="comment">// parallel每进行一次外部循环都会创建和合并线程，产生开销</span></span><br><span class="line"><span class="comment">// 每次执行内部循环都会使用相同数量的线程，因此我们希望只创建一次线程，并在每次内部循环执行中重用</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">parallel_odd_even_order_2</span><span class="params">(<span class="keyword">int</span> thread_count, <span class="keyword">int</span> a[], <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> phase;</span><br><span class="line"><span class="meta">#   <span class="meta-keyword">pragma</span> omp parallel num_threads(thread_count) \</span></span><br><span class="line"><span class="meta">        default(none) shared(a, n) private(phase)</span></span><br><span class="line">    <span class="keyword">for</span> (phase = <span class="number">0</span>; phase &lt; n; phase++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (phase % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="meta">#           <span class="meta-keyword">pragma</span> omp for</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i += <span class="number">2</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (a[i - <span class="number">1</span>] &gt; a[i]) </span><br><span class="line">                    <span class="built_in">swap</span>(a[i - <span class="number">1</span>], a[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="meta">#           <span class="meta-keyword">pragma</span> omp for</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n - <span class="number">1</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (a[i] &gt; a[i + <span class="number">1</span>]) &#123;</span><br><span class="line">                    <span class="built_in">swap</span>(a[i], a[i + <span class="number">1</span>]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="线程调度子句schedule"><a class="markdownIt-Anchor" href="#线程调度子句schedule"></a> 线程调度子句schedule</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> _OPENMP</span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">include</span><span class="meta-string">&lt;omp.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;math.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">function</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> j, start = i * (i + <span class="number">1</span>) / <span class="number">2</span>, finish = start + i;</span><br><span class="line">    <span class="keyword">double</span> return_val = <span class="number">0.0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (j = start; j &lt;= finish; j++) &#123;</span><br><span class="line">        return_val += <span class="built_in">sin</span>(j);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> return_val;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">    <span class="comment">// parallel for只是粗略的使用块分割，如果调用函数与需要时间成正比(function())</span></span><br><span class="line">    <span class="comment">// 这样的分配方式显然不佳。于是我们使用schedule子句实现好的迭代分配</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 下面是对于几种schedule的尝试</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 无调度</span></span><br><span class="line">    <span class="keyword">int</span> thread_count = <span class="built_in">strtol</span>(argv[<span class="number">1</span>], <span class="literal">NULL</span>, <span class="number">10</span>);</span><br><span class="line">    <span class="keyword">double</span> result_sum = <span class="number">0.0</span>;</span><br><span class="line">    <span class="keyword">int</span> n = <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">double</span> start_time = (<span class="keyword">double</span>) <span class="built_in">clock</span>();</span><br><span class="line"><span class="meta">#   <span class="meta-keyword">pragma</span> opt parallel for num_threads(thread_count) \</span></span><br><span class="line"><span class="meta">        reduction(+: result_sum) shared(n)</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        result_sum += <span class="built_in">function</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">double</span> end_time = (<span class="keyword">double</span>) <span class="built_in">clock</span>();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;No schedule, time is %.4lf, result is %.4lf\n&quot;</span>, end_time - start_time, result_sum);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// dynamic调度</span></span><br><span class="line">    result_sum = <span class="number">0.0</span>;</span><br><span class="line">    start_time = (<span class="keyword">double</span>) <span class="built_in">clock</span>();</span><br><span class="line">    <span class="meta">#   <span class="meta-keyword">pragma</span> opt parallel for num_threads(thread_count) \</span></span><br><span class="line"><span class="meta">        reduction(+: result_sum) shared(n) schedule(dynamic)</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        result_sum += <span class="built_in">function</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">     end_time = (<span class="keyword">double</span>) <span class="built_in">clock</span>();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Dynamic schedule, time is %.4lf, result is %.4lf\n&quot;</span>, end_time - start_time, result_sum);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// guided调度</span></span><br><span class="line">    result_sum = <span class="number">0.0</span>;</span><br><span class="line">    start_time = (<span class="keyword">double</span>) <span class="built_in">clock</span>();</span><br><span class="line">    <span class="meta">#   <span class="meta-keyword">pragma</span> opt parallel for num_threads(thread_count) \</span></span><br><span class="line"><span class="meta">        reduction(+: result_sum) shared(n) schedule(guided)</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        result_sum += <span class="built_in">function</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">     end_time = (<span class="keyword">double</span>) <span class="built_in">clock</span>();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Guided schedule, time is %.4lf, result is %.4lf\n&quot;</span>, end_time - start_time, result_sum);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// runtime调度</span></span><br><span class="line">    result_sum = <span class="number">0.0</span>;</span><br><span class="line">    start_time = (<span class="keyword">double</span>) <span class="built_in">clock</span>();</span><br><span class="line">    <span class="meta">#   <span class="meta-keyword">pragma</span> opt parallel for num_threads(thread_count) \</span></span><br><span class="line"><span class="meta">        reduction(+: result_sum) shared(n) schedule(runtime)</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        result_sum += <span class="built_in">function</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">     end_time = (<span class="keyword">double</span>) <span class="built_in">clock</span>();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Runtime schedule, time is %.4lf, result is %.4lf\n&quot;</span>, end_time - start_time, result_sum);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 自动调度</span></span><br><span class="line">    result_sum = <span class="number">0.0</span>;</span><br><span class="line">    start_time = (<span class="keyword">double</span>) <span class="built_in">clock</span>();</span><br><span class="line">    <span class="meta">#   <span class="meta-keyword">pragma</span> opt parallel for num_threads(thread_count) \</span></span><br><span class="line"><span class="meta">        reduction(+: result_sum) shared(n) schedule(auto)</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        result_sum += <span class="built_in">function</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">     end_time = (<span class="keyword">double</span>) <span class="built_in">clock</span>();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Auto schedule, time is %.4lf, result is %.4lf\n&quot;</span>, end_time - start_time, result_sum);</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// eg. 三个线程，12个任务</span></span><br><span class="line"><span class="comment">// 调度方式：</span></span><br><span class="line"><span class="comment">// 1. static: 以轮转方式分配chunksize个线程给每个线程（chunksize 默认近似为total_iterations / thread_count)</span></span><br><span class="line"><span class="comment">// chunksize = 2</span></span><br><span class="line"><span class="comment">// Thread0: 0 1 6 7</span></span><br><span class="line"><span class="comment">// Thread1: 2 3 8 9</span></span><br><span class="line"><span class="comment">// Thread2: 4 5 10 11</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. dynamic: 迭代被分为chunksize个连续块，每个线程执行一块，执行完再向系统申请(chunksize默认为1)</span></span><br><span class="line"><span class="comment">// 3. guided: 类似于dynamic, 每个线程执行完一块后，向系统请求另一块，但是新块会变小</span></span><br><span class="line"><span class="comment">// guided如下图</span></span><br><span class="line"><span class="comment">// 4. runtime: 需要自己配置环境变量指定</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 调度选择</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    系统开销: guided &gt; dynamic &gt; static</span></span><br><span class="line"><span class="comment">    1. 如果每次迭代计算量几乎相同，默认调度方式性能最好</span></span><br><span class="line"><span class="comment">    2. 若计算量线性递增或递减，采用比较小的chunksize的static比较好</span></span><br><span class="line"><span class="comment">    3. 如果每次迭代事先不确定，需要进行调参，可以通过配置环境变量来比较不同调度策略下性能</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p><img src="/image/openmp/1.png" alt="1" /></p><h2 id="小结"><a class="markdownIt-Anchor" href="#小结"></a> 小结</h2><p><img src="/image/openmp/2.png" alt="1" /></p><p><img src="/image/openmp/3.png" alt="1" /></p><p><img src="/image/openmp/4.png" alt="1" /></p><p><img src="/image/openmp/5.png" alt="1" /></p><p><img src="/image/openmp/6.png" alt="1" /></p>]]></content>
    
    
    <summary type="html">高性能计算的编程基础，基于C++语言，入门HPC的第一站。</summary>
    
    
    
    <category term="CS" scheme="http://aflyingsheep.github.io/categories/CS/"/>
    
    <category term="HPC" scheme="http://aflyingsheep.github.io/categories/HPC/"/>
    
    
    <category term="HPC" scheme="http://aflyingsheep.github.io/tags/HPC/"/>
    
  </entry>
  
  <entry>
    <title>中位数问题（对顶堆的应用）</title>
    <link href="http://aflyingsheep.github.io/2022/06/30/algorithm/median_problem(for_top_stack)/"/>
    <id>http://aflyingsheep.github.io/2022/06/30/algorithm/median_problem(for_top_stack)/</id>
    <published>2022-06-30T07:49:03.000Z</published>
    <updated>2023-02-11T13:44:25.556Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="leetcode295-数据流的中位数"><a class="markdownIt-Anchor" href="#leetcode295-数据流的中位数"></a> Leetcode295. 数据流的中位数</h1><ul><li>设计一个支持以下两种操作的数据结构：<ul><li>void addNum(int num) - 从数据流中添加一个整数到数据结构中。</li><li>double findMedian() - 返回目前所有元素的中位数。</li></ul></li><li>设计思路：维护两个堆：左侧大顶堆，用于维护比中位数小的元素；右侧小顶堆，用于维护比中位数大的元素；平均值：当两堆元素个数相同，则中位数为堆顶元素平均值；不同时为左侧大顶堆的堆顶值。插入元素时，两堆元素同样多则插入到左侧大顶堆（先插入右侧，弹出堆顶再插入左侧），不同时左侧多，插入到左侧弹出堆顶再插入到右侧。</li><li><strong>注，less是大顶堆，greater是小顶堆！！！</strong></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MedianFinder</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 维护大顶堆、小顶堆</span></span><br><span class="line">    priority_queue&lt;<span class="keyword">int</span>, vector&lt;<span class="keyword">int</span>&gt;, less&lt;<span class="keyword">int</span>&gt;&gt; p1;</span><br><span class="line">    priority_queue&lt;<span class="keyword">int</span>, vector&lt;<span class="keyword">int</span>&gt;, greater&lt;<span class="keyword">int</span>&gt;&gt; p2;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">MedianFinder</span>() &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addNum</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (p1.<span class="built_in">empty</span>()) p1.<span class="built_in">push</span>(num);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (p1.<span class="built_in">size</span>() == p2.<span class="built_in">size</span>()) &#123;</span><br><span class="line">                p2.<span class="built_in">push</span>(num);</span><br><span class="line">                <span class="keyword">int</span> x = p2.<span class="built_in">top</span>();</span><br><span class="line">                p2.<span class="built_in">pop</span>();</span><br><span class="line">                p1.<span class="built_in">push</span>(x);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                p1.<span class="built_in">push</span>(num);</span><br><span class="line">                <span class="keyword">int</span> x = p1.<span class="built_in">top</span>();</span><br><span class="line">                p1.<span class="built_in">pop</span>();</span><br><span class="line">                p2.<span class="built_in">push</span>(x);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">findMedian</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (p1.<span class="built_in">size</span>() == p2.<span class="built_in">size</span>()) <span class="keyword">return</span> (p1.<span class="built_in">top</span>() + p2.<span class="built_in">top</span>()) * <span class="number">1.0</span> / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> p1.<span class="built_in">top</span>() * <span class="number">1.0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="leetcode480-滑动窗口中位数"><a class="markdownIt-Anchor" href="#leetcode480-滑动窗口中位数"></a> Leetcode480. 滑动窗口中位数</h1><ul><li><p>给你一个数组 nums，有一个长度为 k 的窗口从最左端滑动到最右端。窗口中有 k 个数，每次窗口向右移动 1 位。你的任务是找出每次窗口移动后得到的新窗口中元素的中位数，并输出由它们组成的数组。</p></li><li><p>思路：对顶堆+延迟删除</p></li><li><p>具体讲解见<a href="https://leetcode.cn/problems/sliding-window-median/solution/hua-dong-chuang-kou-zhong-wei-shu-by-lee-7ai6/">滑动窗口中位数 - 滑动窗口中位数 - 力扣（LeetCode）</a></p></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DualHeap</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 大根堆，维护较小的一半元素</span></span><br><span class="line">    priority_queue&lt;<span class="keyword">int</span>&gt; small;</span><br><span class="line">    <span class="comment">// 小根堆，维护较大的一半元素</span></span><br><span class="line">    priority_queue&lt;<span class="keyword">int</span>, vector&lt;<span class="keyword">int</span>&gt;, greater&lt;<span class="keyword">int</span>&gt;&gt; large;</span><br><span class="line">    <span class="comment">// 哈希表，记录「延迟删除」的元素，key 为元素，value 为需要删除的次数</span></span><br><span class="line">    unordered_map&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; delayed;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> k;</span><br><span class="line">    <span class="comment">// small 和 large 当前包含的元素个数，需要扣除被「延迟删除」的元素</span></span><br><span class="line">    <span class="keyword">int</span> smallSize, largeSize;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">DualHeap</span>(<span class="keyword">int</span> _k): <span class="built_in">k</span>(_k), <span class="built_in">smallSize</span>(<span class="number">0</span>), <span class="built_in">largeSize</span>(<span class="number">0</span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 不断地弹出 heap 的堆顶元素，并且更新哈希表</span></span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function">    <span class="keyword">void</span> <span class="title">prune</span><span class="params">(T&amp; heap)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (!heap.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="keyword">int</span> num = heap.<span class="built_in">top</span>();</span><br><span class="line">            <span class="keyword">if</span> (delayed.<span class="built_in">count</span>(num)) &#123;</span><br><span class="line">                --delayed[num];</span><br><span class="line">                <span class="keyword">if</span> (!delayed[num]) &#123;</span><br><span class="line">                    delayed.<span class="built_in">erase</span>(num);</span><br><span class="line">                &#125;</span><br><span class="line">                heap.<span class="built_in">pop</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调整 small 和 large 中的元素个数，使得二者的元素个数满足要求</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">makeBalance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (smallSize &gt; largeSize + <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">// small 比 large 元素多 2 个</span></span><br><span class="line">            large.<span class="built_in">push</span>(small.<span class="built_in">top</span>());</span><br><span class="line">            small.<span class="built_in">pop</span>();</span><br><span class="line">            --smallSize;</span><br><span class="line">            ++largeSize;</span><br><span class="line">            <span class="comment">// small 堆顶元素被移除，需要进行 prune</span></span><br><span class="line">            <span class="built_in">prune</span>(small);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (smallSize &lt; largeSize) &#123;</span><br><span class="line">            <span class="comment">// large 比 small 元素多 1 个</span></span><br><span class="line">            small.<span class="built_in">push</span>(large.<span class="built_in">top</span>());</span><br><span class="line">            large.<span class="built_in">pop</span>();</span><br><span class="line">            ++smallSize;</span><br><span class="line">            --largeSize;</span><br><span class="line">            <span class="comment">// large 堆顶元素被移除，需要进行 prune</span></span><br><span class="line">            <span class="built_in">prune</span>(large);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (small.<span class="built_in">empty</span>() || num &lt;= small.<span class="built_in">top</span>()) &#123;</span><br><span class="line">            small.<span class="built_in">push</span>(num);</span><br><span class="line">            ++smallSize;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            large.<span class="built_in">push</span>(num);</span><br><span class="line">            ++largeSize;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">makeBalance</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">erase</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        ++delayed[num];</span><br><span class="line">        <span class="keyword">if</span> (num &lt;= small.<span class="built_in">top</span>()) &#123;</span><br><span class="line">            --smallSize;</span><br><span class="line">            <span class="keyword">if</span> (num == small.<span class="built_in">top</span>()) &#123;</span><br><span class="line">                <span class="built_in">prune</span>(small);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            --largeSize;</span><br><span class="line">            <span class="keyword">if</span> (num == large.<span class="built_in">top</span>()) &#123;</span><br><span class="line">                <span class="built_in">prune</span>(large);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">makeBalance</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">getMedian</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> k &amp; <span class="number">1</span> ? small.<span class="built_in">top</span>() : ((<span class="keyword">double</span>)small.<span class="built_in">top</span>() + large.<span class="built_in">top</span>()) / <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">double</span>&gt; <span class="title">medianSlidingWindow</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="function">DualHeap <span class="title">dh</span><span class="params">(k)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; ++i) &#123;</span><br><span class="line">            dh.<span class="built_in">insert</span>(nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        vector&lt;<span class="keyword">double</span>&gt; ans = &#123;dh.<span class="built_in">getMedian</span>()&#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = k; i &lt; nums.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            dh.<span class="built_in">insert</span>(nums[i]);</span><br><span class="line">            dh.<span class="built_in">erase</span>(nums[i - k]);</span><br><span class="line">            ans.<span class="built_in">push_back</span>(dh.<span class="built_in">getMedian</span>());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">关于新建可以get中位数的数据结构，和滑动窗口中的中位数问题，均用两个堆实现。</summary>
    
    
    
    <category term="Algorithm" scheme="http://aflyingsheep.github.io/categories/Algorithm/"/>
    
    
    <category term="Algorithm" scheme="http://aflyingsheep.github.io/tags/Algorithm/"/>
    
  </entry>
  
</feed>
