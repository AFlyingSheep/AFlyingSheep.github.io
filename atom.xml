<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>AFlyingSheep&#39;s Blog</title>
  
  <subtitle>Keep coding, keep thinking.</subtitle>
  <link href="http://aflyingsheep.github.io/atom.xml" rel="self"/>
  
  <link href="http://aflyingsheep.github.io/"/>
  <updated>2023-02-11T08:41:34.155Z</updated>
  <id>http://aflyingsheep.github.io/</id>
  
  <author>
    <name>Johnson Shuangjian</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>线性方程组的迭代式求解方法</title>
    <link href="http://aflyingsheep.github.io/2023/02/10/math/sor/"/>
    <id>http://aflyingsheep.github.io/2023/02/10/math/sor/</id>
    <published>2023-02-10T12:22:06.000Z</published>
    <updated>2023-02-11T08:41:34.155Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="笔记图解"><a class="markdownIt-Anchor" href="#笔记图解"></a> 笔记图解</h1><p><img src="/image/j_gs_sor/1.jpeg" alt="1" /></p>]]></content>
    
    
    <summary type="html">详解Jacobi迭代法、Gauss-Seidel迭代法、SOR超松弛迭代法由一般形式转化为矩阵形式</summary>
    
    
    
    <category term="Math" scheme="http://aflyingsheep.github.io/categories/Math/"/>
    
    
    <category term="Math" scheme="http://aflyingsheep.github.io/tags/Math/"/>
    
  </entry>
  
  <entry>
    <title>cmake学习笔记</title>
    <link href="http://aflyingsheep.github.io/2023/01/30/linux/cmake/"/>
    <id>http://aflyingsheep.github.io/2023/01/30/linux/cmake/</id>
    <published>2023-01-30T13:27:06.000Z</published>
    <updated>2023-02-11T08:42:55.001Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>实验环境下载地址：<a href="https://github.com/AFlyingSheep/cmake-learn/archive/refs/heads/master.zip">Click me!</a></p><h1 id="cmake一个helloword"><a class="markdownIt-Anchor" href="#cmake一个helloword"></a> CMake一个HelloWord</h1><p>1、步骤一，写一个HelloWord</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#main.cpp</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">std::cout &lt;&lt;  <span class="string">&quot;hello word&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2、步骤二，写CMakeLists.txt</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">#CMakeLists.<span class="function">txt</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">PROJECT</span> <span class="params">(HELLO)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">SET</span><span class="params">(SRC_LIST main.cpp)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">MESSAGE</span><span class="params">(STATUS <span class="string">&quot;This is BINARY dir &quot;</span> $&#123;HELLO_BINARY_DIR&#125;)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">MESSAGE</span><span class="params">(STATUS <span class="string">&quot;This is SOURCE dir &quot;</span>$&#123;HELLO_SOURCE_DIR&#125;)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">ADD_EXECUTABLE</span><span class="params">(hello $&#123;SRC_LIST&#125;)</span></span></span><br></pre></td></tr></table></figure><p>3、步骤三、使用cmake，生成makefile文件</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">cmake .</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line">[root@localhost cmake]<span class="meta"># cmake .</span></span><br><span class="line"><span class="function">CMake <span class="title">Warning</span> <span class="params">(dev)</span> in CMakeLists.txt:</span></span><br><span class="line"><span class="function">  Syntax Warning in cmake code at</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">    /root/cmake/CMakeLists.txt:<span class="number">7</span>:<span class="number">37</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">  Argument not separated from preceding token by whitespace.</span></span><br><span class="line"><span class="function">This warning is for project developers.  Use -Wno-dev to suppress it.</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">-- The C compiler identification is GNU <span class="number">10.2</span><span class="number">.1</span></span></span><br><span class="line"><span class="function">-- The CXX compiler identification is GNU <span class="number">10.2</span><span class="number">.1</span></span></span><br><span class="line"><span class="function">-- Check for working C compiler: /usr/bin/cc</span></span><br><span class="line"><span class="function">-- Check for working C compiler: /usr/bin/cc -- works</span></span><br><span class="line"><span class="function">-- Detecting C compiler ABI info</span></span><br><span class="line"><span class="function">-- Detecting C compiler ABI info - done</span></span><br><span class="line"><span class="function">-- Check for working CXX compiler: /usr/bin/c++</span></span><br><span class="line"><span class="function">-- Check for working CXX compiler: /usr/bin/c++ -- works</span></span><br><span class="line"><span class="function">-- Detecting CXX compiler ABI info</span></span><br><span class="line"><span class="function">-- Detecting CXX compiler ABI info - done</span></span><br><span class="line"><span class="function">-- This is BINARY dir /root/cmake</span></span><br><span class="line"><span class="function">-- This is SOURCE dir /root/cmake</span></span><br><span class="line"><span class="function">-- Configuring done</span></span><br><span class="line"><span class="function">-- Generating done</span></span><br><span class="line"><span class="function">-- Build files have been written to: /root/cmake</span></span><br></pre></td></tr></table></figure><p>目录下就生成了这些文件-CMakeFiles, CMakeCache.txt, cmake_install.cmake 等文件，并且生成了Makefile.<br />现在不需要理会这些文件的作用，以后你也可以不去理会。最关键的是，它自动生成了Makefile.</p><p>4、使用make命令编译</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">root@localhost cmake]<span class="meta"># make</span></span><br><span class="line">Scanning dependencies of target hello</span><br><span class="line">[<span class="number">100</span>%] Building CXX object CMakeFiles/hello.dir/main.cpp.o</span><br><span class="line">Linking CXX executable hello</span><br><span class="line">[<span class="number">100</span>%] Built target hello</span><br></pre></td></tr></table></figure><p>5、最终生成了Hello的可执行程序</p><h1 id="cmake一个helloword-的语法介绍"><a class="markdownIt-Anchor" href="#cmake一个helloword-的语法介绍"></a> CMake一个HelloWord-的语法介绍</h1><h2 id="project关键字"><a class="markdownIt-Anchor" href="#project关键字"></a> PROJECT关键字</h2><p>可以用来指定工程的名字和支持的语言，默认支持所有语言</p><p>PROJECT (HELLO)   指定了工程的名字，并且支持所有语言—建议</p><p>PROJECT (HELLO CXX)      指定了工程的名字，并且支持语言是C++</p><p>PROJECT (HELLO C CXX)      指定了工程的名字，并且支持语言是C和C++</p><p>该指定隐式定义了两个CMAKE的变量</p><p><projectname>_BINARY_DIR，本例中是 HELLO_BINARY_DIR</p><p><projectname>_SOURCE_DIR，本例中是 HELLO_SOURCE_DIR</p><p>MESSAGE关键字就可以直接使用者两个变量，当前都指向当前的工作目录，后面会讲外部编译</p><p>问题：如果改了工程名，这两个变量名也会改变</p><p>解决：又定义两个预定义变量：PROJECT_BINARY_DIR和PROJECT_SOURCE_DIR，这两个变量和HELLO_BINARY_DIR，HELLO_SOURCE_DIR是一致的。所以改了工程名也没有关系</p><h2 id="set关键字"><a class="markdownIt-Anchor" href="#set关键字"></a> SET关键字</h2><p>用来显示的指定变量的</p><p>SET(SRC_LIST main.cpp)    SRC_LIST变量就包含了main.cpp</p><p>也可以 SET(SRC_LIST main.cpp t1.cpp t2.cpp)</p><h2 id="message关键字"><a class="markdownIt-Anchor" href="#message关键字"></a> MESSAGE关键字</h2><p>向终端输出用户自定义的信息</p><p>主要包含三种信息：</p><ul><li>SEND_ERROR，产生错误，生成过程被跳过。</li><li>SATUS，输出前缀为—的信息。</li><li>FATAL_ERROR，立即终止所有 cmake 过程.</li></ul><h2 id="add_executable关键字"><a class="markdownIt-Anchor" href="#add_executable关键字"></a> ADD_EXECUTABLE关键字</h2><p>生成可执行文件</p><p>ADD_EXECUTABLE(hello ${SRC_LIST})     生成的可执行文件名是hello，源文件读取变量SRC_LIST中的内容</p><p>也可以直接写 ADD_EXECUTABLE(hello main.cpp)</p><p>上述例子可以简化的写成</p><p>PROJECT(HELLO)<br />ADD_EXECUTABLE(hello main.cpp)</p><p>注意：工程名的 HELLO 和生成的可执行文件 hello 是没有任何关系的</p><h1 id="语法的基本原则"><a class="markdownIt-Anchor" href="#语法的基本原则"></a> 语法的基本原则</h1><ul><li><p>变量使用${}方式取值，但是在 IF 控制语句中是直接使用变量名</p></li><li><p>指令(参数 1 参数 2…) 参数使用括弧括起，参数之间使用空格或分号分开。 以上面的 ADD_EXECUTABLE 指令为例，如果存在另外一个 func.cpp 源文件</p><p>就要写成：ADD_EXECUTABLE(hello main.cpp func.cpp)或者ADD_EXECUTABLE(hello main.cpp;func.cpp)</p></li><li><p>指令是大小写无关的，参数和变量是大小写相关的。但，推荐你全部使用大写指令</p></li></ul><h2 id="语法注意事项"><a class="markdownIt-Anchor" href="#语法注意事项"></a> 语法注意事项</h2><ul><li>SET(SRC_LIST main.cpp) 可以写成 SET(SRC_LIST “main.cpp”)，如果源文件名中含有空格，就必须要加双引号</li><li>ADD_EXECUTABLE(hello main) 后缀可以不写，他会自动去找.c和.cpp，最好不要这样写，可能会有这两个文件main.cpp和main</li></ul><h1 id="内部构建和外部构建"><a class="markdownIt-Anchor" href="#内部构建和外部构建"></a> 内部构建和外部构建</h1><ul><li>上述例子就是内部构建，他生产的临时文件特别多，不方便清理</li><li>外部构建，就会把生成的临时文件放在build目录下，不会对源文件有任何影响强烈使用外部构建方式</li></ul><h2 id="外部构建方式举例"><a class="markdownIt-Anchor" href="#外部构建方式举例"></a> 外部构建方式举例</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//例子目录，CMakeLists.txt和上面例子一致</span></span><br><span class="line">[root@localhost cmake]<span class="meta"># pwd</span></span><br><span class="line">/root/cmake</span><br><span class="line">[root@localhost cmake]<span class="meta"># ll</span></span><br><span class="line">total <span class="number">8</span></span><br><span class="line">-rw-r--r--. <span class="number">1</span> root root <span class="number">198</span> Dec <span class="number">28</span> <span class="number">20</span>:<span class="number">59</span> CMakeLists.txt</span><br><span class="line">-rw-r--r--. <span class="number">1</span> root root  <span class="number">76</span> Dec <span class="number">28</span> <span class="number">00</span>:<span class="number">18</span> main.cpp</span><br></pre></td></tr></table></figure><p>1、建立一个build目录，可以在任何地方，建议在当前目录下</p><p>2、进入build，运行cmake …    当然…表示上一级目录，你可以写CMakeLists.txt所在的绝对路径，生产的文件都在build目录下了</p><p>3、在build目录下，运行make来构建工程</p><p>注意外部构建的两个变量</p><p>1、HELLO_SOURCE_DIR  还是工程路径</p><p>2、HELLO_BINARY_DIR   编译路径 也就是 /root/cmake/bulid</p><h1 id="让hello-world看起来更像一个工程"><a class="markdownIt-Anchor" href="#让hello-world看起来更像一个工程"></a> 让Hello World看起来更像一个工程</h1><ul><li>为工程添加一个子目录 src，用来放置工程源代码</li><li>添加一个子目录 doc，用来放置这个工程的文档 hello.txt</li><li>在工程目录添加文本文件 COPYRIGHT, README</li><li>在工程目录添加一个 <a href="http://runhello.sh/">runhello.sh</a> 脚本，用来调用 hello 二进制</li><li>将构建后的目标文件放入构建目录的 bin 子目录</li><li>将 doc 目录 的内容以及 COPYRIGHT/README 安装到/usr/share/doc/cmake/</li></ul><h2 id="将目标文件放入构建目录的-bin-子目录"><a class="markdownIt-Anchor" href="#将目标文件放入构建目录的-bin-子目录"></a> 将目标文件放入构建目录的 bin 子目录</h2><p>每个目录下都要有一个CMakeLists.txt说明</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost cmake]<span class="meta"># tree</span></span><br><span class="line">.</span><br><span class="line">├── build</span><br><span class="line">├── CMakeLists.txt</span><br><span class="line">└── src</span><br><span class="line">    ├── CMakeLists.txt</span><br><span class="line">    └── main.cpp</span><br></pre></td></tr></table></figure><p>外层CMakeLists.txt</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">PROJECT</span>(HELLO)</span><br><span class="line"><span class="built_in">ADD_SUBDIRECTORY</span>(src bin)</span><br></pre></td></tr></table></figure><p>src下的CMakeLists.txt</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">ADD_EXECUTABLE</span>(hello main.cpp)</span><br></pre></td></tr></table></figure><h3 id="add_subdirectory-指令"><a class="markdownIt-Anchor" href="#add_subdirectory-指令"></a> ADD_SUBDIRECTORY 指令</h3><p>ADD_SUBDIRECTORY(source_dir [binary_dir] [EXCLUDE_FROM_ALL])</p><ul><li><p>这个指令用于向当前工程添加存放源文件的子目录，并可以指定中间二进制和目标二进制存放的位置</p></li><li><p>EXCLUDE_FROM_ALL函数是将写的目录从编译中排除，如程序中的example</p></li><li><p>ADD_SUBDIRECTORY(src bin)</p><p>将 src 子目录加入工程并指定编译输出(包含编译中间结果)路径为bin 目录</p><p>如果不进行 bin 目录的指定，那么编译结果(包括中间结果)都将存放在build/src 目录</p></li></ul><h3 id="更改二进制的保存路径"><a class="markdownIt-Anchor" href="#更改二进制的保存路径"></a> 更改二进制的保存路径</h3><p>SET 指令重新定义 EXECUTABLE_OUTPUT_PATH 和 LIBRARY_OUTPUT_PATH 变量 来指定最终的目标二进制的位置</p><p>SET(EXECUTABLE_OUTPUT_PATH ${PROJECT_BINARY_DIR}/bin)<br />SET(LIBRARY_OUTPUT_PATH ${PROJECT_BINARY_DIR}/lib)</p><p>思考：加载哪个CMakeLists.txt当中</p><p>哪里要改变目标存放路径，就在哪里加入上述的定义，所以应该在src下的CMakeLists.txt下写</p><h1 id="安装"><a class="markdownIt-Anchor" href="#安装"></a> 安装</h1><ul><li>一种是从代码编译后直接 make install 安装</li><li>一种是打包时的指定 目录安装。<ul><li>简单的可以这样指定目录：make install DESTDIR=/tmp/test</li><li>稍微复杂一点可以这样指定目录：./configure –prefix=/usr</li></ul></li></ul><h2 id="如何安装helloword"><a class="markdownIt-Anchor" href="#如何安装helloword"></a> 如何安装HelloWord</h2><p>使用CMAKE一个新的指令：INSTALL</p><p>INSTALL的安装可以包括：二进制、动态库、静态库以及文件、目录、脚本等</p><p>使用CMAKE一个新的变量：CMAKE_INSTALL_PREFIX</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 目录树结构</span></span><br><span class="line">[root@localhost cmake]<span class="meta"># tree</span></span><br><span class="line">.</span><br><span class="line">├── build</span><br><span class="line">├── CMakeLists.txt</span><br><span class="line">├── COPYRIGHT</span><br><span class="line">├── doc</span><br><span class="line">│   └── hello.txt</span><br><span class="line">├── README</span><br><span class="line">├── runhello.sh</span><br><span class="line">└── src</span><br><span class="line">    ├── CMakeLists.txt</span><br><span class="line">    └── main.cpp</span><br><span class="line"></span><br><span class="line"><span class="number">3</span> directories, <span class="number">7</span> files</span><br></pre></td></tr></table></figure><h3 id="安装文件copyright和readme"><a class="markdownIt-Anchor" href="#安装文件copyright和readme"></a> 安装文件COPYRIGHT和README</h3><p>INSTALL(FILES COPYRIGHT README DESTINATION share/doc/cmake/)</p><p>FILES：文件</p><p>DESTINATION：</p><p>1、写绝对路径</p><p>2、可以写相对路径，相对路径实际路径是：${CMAKE_INSTALL_PREFIX}/&lt;DESTINATION 定义的路径&gt;</p><p>CMAKE_INSTALL_PREFIX  默认是在 /usr/local/</p><p>cmake -DCMAKE_INSTALL_PREFIX=/usr    在cmake的时候指定CMAKE_INSTALL_PREFIX变量的路径</p><h3 id="安装脚本runhellosh"><a class="markdownIt-Anchor" href="#安装脚本runhellosh"></a> <a href="http://xn--runhello-zh5o444ghv3d9ht.sh">安装脚本runhello.sh</a></h3><p>PROGRAMS：非目标文件的可执行程序安装(比如脚本之类)</p><p>INSTALL(PROGRAMS <a href="http://runhello.sh">runhello.sh</a> DESTINATION bin)</p><p>说明：实际安装到的是 /usr/bin</p><h3 id="安装-doc-中的-hellotxt"><a class="markdownIt-Anchor" href="#安装-doc-中的-hellotxt"></a> 安装 doc 中的 hello.txt</h3><ul><li><p>一、是通过在 doc 目录建立CMakeLists.txt ，通过install下的file</p></li><li><p>二、是直接在工程目录通过</p><p>INSTALL(DIRECTORY doc/ DESTINATION share/doc/cmake)</p></li></ul><p>DIRECTORY 后面连接的是所在 Source 目录的相对路径</p><p>注意：abc 和 abc/有很大的区别</p><p>目录名不以/结尾：这个目录将被安装为目标路径下的</p><p>目录名以/结尾：将这个目录中的内容安装到目标路径</p><h3 id="安装过程"><a class="markdownIt-Anchor" href="#安装过程"></a> 安装过程</h3><p>cmake …</p><p>make</p><p>make install</p><h1 id="静态库和动态库的构建"><a class="markdownIt-Anchor" href="#静态库和动态库的构建"></a> 静态库和动态库的构建</h1><p>任务：</p><p>１，建立一个静态库和动态库，提供 HelloFunc 函数供其他程序编程使用，HelloFunc 向终端输出 Hello World 字符串。</p><p>２，安装头文件与共享库。</p><p>静态库和动态库的区别</p><ul><li>静态库的扩展名一般为“.a”或“.lib”；动态库的扩展名一般为“.so”或“.dll”。</li><li>静态库在编译时会直接整合到目标程序中，编译成功的可执行文件可独立运行</li><li>动态库在编译时不会放到连接的目标程序中，即可执行文件无法单独运行。</li></ul><h2 id="构建实例"><a class="markdownIt-Anchor" href="#构建实例"></a> 构建实例</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost cmake2]<span class="meta"># tree</span></span><br><span class="line">.</span><br><span class="line">├── build</span><br><span class="line">├── CMakeLists.txt</span><br><span class="line">└── lib</span><br><span class="line">    ├── CMakeLists.txt</span><br><span class="line">    ├── hello.cpp</span><br><span class="line">    └── hello.h</span><br></pre></td></tr></table></figure><p>hello.h中的内容</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> HELLO_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Hello_H</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">HelloFunc</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>hello.cpp中的内容</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;hello.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">HelloFunc</span><span class="params">()</span></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Hello World&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>项目中的cmake内容</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">PROJECT</span>(HELLO)</span><br><span class="line"><span class="built_in">ADD_SUBDIRECTORY</span>(lib bin)</span><br></pre></td></tr></table></figure><p>lib中CMakeLists.txt中的内容</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">SET</span>(LIBHELLO_SRC hello.cpp)</span><br><span class="line"><span class="built_in">ADD_LIBRARY</span>(hello SHARED $&#123;LIBHELLO_SRC&#125;)</span><br></pre></td></tr></table></figure><h3 id="add_library"><a class="markdownIt-Anchor" href="#add_library"></a> ADD_LIBRARY</h3><p>ADD_LIBRARY(hello SHARED ${LIBHELLO_SRC})</p><ul><li>hello：就是正常的库名，生成的名字前面会加上lib，<a href="http://xn--libhello-x80mpzv93qwwbs3dby3f9mei53b.so">最终产生的文件是libhello.so</a></li><li>SHARED，动态库    STATIC，静态库</li><li>${LIBHELLO_SRC} ：源文件</li></ul><h3 id="同时构建静态和动态库"><a class="markdownIt-Anchor" href="#同时构建静态和动态库"></a> 同时构建静态和动态库</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 如果用这种方式，只会构建一个动态库，不会构建出静态库，虽然静态库的后缀是.a</span></span><br><span class="line"><span class="built_in">ADD_LIBRARY</span>(hello SHARED $&#123;LIBHELLO_SRC&#125;)</span><br><span class="line"><span class="built_in">ADD_LIBRARY</span>(hello STATIC $&#123;LIBHELLO_SRC&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 修改静态库的名字，这样是可以的，但是我们往往希望他们的名字是相同的，只是后缀不同而已</span></span><br><span class="line"><span class="built_in">ADD_LIBRARY</span>(hello SHARED $&#123;LIBHELLO_SRC&#125;)</span><br><span class="line"><span class="built_in">ADD_LIBRARY</span>(hello_static STATIC $&#123;LIBHELLO_SRC&#125;)</span><br></pre></td></tr></table></figure><h3 id="set_target_properties"><a class="markdownIt-Anchor" href="#set_target_properties"></a> SET_TARGET_PROPERTIES</h3><p>这条指令可以用来设置输出的名称，对于动态库，还可以用来指定动态库版本和 API 版本</p><p>同时构建静态和动态库</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">SET</span>(LIBHELLO_SRC hello.cpp)</span><br><span class="line"></span><br><span class="line"><span class="built_in">ADD_LIBRARY</span>(hello_static STATIC $&#123;LIBHELLO_SRC&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">//对hello_static的重名为hello</span></span><br><span class="line"><span class="built_in">SET_TARGET_PROPERTIES</span>(hello_static PROPERTIES  OUTPUT_NAME <span class="string">&quot;hello&quot;</span>)</span><br><span class="line"><span class="comment">//cmake 在构建一个新的target 时，会尝试清理掉其他使用这个名字的库，因为，在构建 libhello.so 时， 就会清理掉 libhello.a</span></span><br><span class="line"><span class="built_in">SET_TARGET_PROPERTIES</span>(hello_static PROPERTIES CLEAN_DIRECT_OUTPUT <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">ADD_LIBRARY</span>(hello SHARED $&#123;LIBHELLO_SRC&#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">SET_TARGET_PROPERTIES</span>(hello PROPERTIES  OUTPUT_NAME <span class="string">&quot;hello&quot;</span>)</span><br><span class="line"><span class="built_in">SET_TARGET_PROPERTIES</span>(hello PROPERTIES CLEAN_DIRECT_OUTPUT <span class="number">1</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="动态库的版本号"><a class="markdownIt-Anchor" href="#动态库的版本号"></a> 动态库的版本号</h3><p>一般动态库都有一个版本号的关联</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">libhello.so<span class="number">.1</span><span class="number">.2</span></span><br><span class="line">libhello.so -&gt;libhello.so<span class="number">.1</span></span><br><span class="line">libhello.so<span class="number">.1</span>-&gt;libhello.so<span class="number">.1</span><span class="number">.2</span></span><br></pre></td></tr></table></figure><p>CMakeLists.txt 插入如下</p><p><code>SET_TARGET_PROPERTIES(hello PROPERTIES VERSION 1.2 SOVERSION 1)</code></p><p>VERSION 指代动态库版本，SOVERSION 指代 API 版本。</p><h3 id="安装共享库和头文件"><a class="markdownIt-Anchor" href="#安装共享库和头文件"></a> 安装共享库和头文件</h3><p>本例中我们将 hello 的共享库安装到<prefix>/lib目录，</p><p>将 hello.h 安装到<prefix>/include/hello 目录</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//文件放到该目录下</span></span><br><span class="line"><span class="built_in">INSTALL</span>(FILES hello.h DESTINATION include/hello)</span><br><span class="line"></span><br><span class="line"><span class="comment">//二进制，静态库，动态库安装都用TARGETS</span></span><br><span class="line"><span class="comment">//ARCHIVE 特指静态库，LIBRARY 特指动态库，RUNTIME 特指可执行目标二进制。</span></span><br><span class="line"><span class="built_in">INSTALL</span>(TARGETS hello hello_static LIBRARY DESTINATION lib ARCHIVE DESTINATION lib)</span><br></pre></td></tr></table></figure><p>注意：</p><p>安装的时候，指定一下路径，放到系统下</p><p><code>cmake -DCMAKE_INSTALL_PREFIX=/usr ..</code></p><h3 id="使用外部共享库和头文件"><a class="markdownIt-Anchor" href="#使用外部共享库和头文件"></a> 使用外部共享库和头文件</h3><p>准备工作，新建一个目录来使用外部共享库和头文件</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@MiWiFi-R4CM-srv cmake3]<span class="meta"># tree</span></span><br><span class="line">.</span><br><span class="line">├── build</span><br><span class="line">├── CMakeLists.txt</span><br><span class="line">└── src</span><br><span class="line">    ├── CMakeLists.txt</span><br><span class="line">    └── main.cpp</span><br></pre></td></tr></table></figure><p>main.cpp</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;hello.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">HelloFunc</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="解决make后头文件找不到的问题"><a class="markdownIt-Anchor" href="#解决make后头文件找不到的问题"></a> 解决：make后头文件找不到的问题</h3><p>PS：include &lt;hello/hello.h&gt;  这样include是可以，这么做的话，就没啥好讲的了</p><p>关键字：INCLUDE_DIRECTORIES    这条指令可以用来向工程添加多个特定的头文件搜索路径，路径之间用空格分割</p><p>在CMakeLists.txt中加入头文件搜索路径</p><p>INCLUDE_DIRECTORIES(/usr/include/hello)</p><h3 id="解决找到引用的函数问题"><a class="markdownIt-Anchor" href="#解决找到引用的函数问题"></a> 解决：找到引用的函数问题</h3><p>报错信息：undefined reference to `HelloFunc()’</p><p>关键字：LINK_DIRECTORIES     添加非标准的共享库搜索路径</p><p>指定第三方库所在路径，LINK_DIRECTORIES(/home/myproject/libs)</p><p>关键字：TARGET_LINK_LIBRARIES    添加需要链接的共享库</p><p>TARGET_LINK_LIBRARIES的时候，只需要给出动态链接库的名字就行了。</p><p>在CMakeLists.txt中插入链接共享库，主要要插在executable的后面</p><p>查看main的链接情况</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[root@MiWiFi-R4CM-srv bin]<span class="meta"># ldd main </span></span><br><span class="line">linux-vdso.so<span class="number">.1</span> =&gt;  (<span class="number">0x00007ffedfda4000</span>)</span><br><span class="line">libhello.so =&gt; /lib64/libhello.<span class="built_in">so</span> (<span class="number">0x00007f41c0d8f000</span>)</span><br><span class="line">libstdc++.so<span class="number">.6</span> =&gt; /lib64/libstdc++.so<span class="number">.6</span> (<span class="number">0x00007f41c0874000</span>)</span><br><span class="line">libm.so<span class="number">.6</span> =&gt; /lib64/libm.so<span class="number">.6</span> (<span class="number">0x00007f41c0572000</span>)</span><br><span class="line">libgcc_s.so<span class="number">.1</span> =&gt; /lib64/libgcc_s.so<span class="number">.1</span> (<span class="number">0x00007f41c035c000</span>)</span><br><span class="line">libc.so<span class="number">.6</span> =&gt; /lib64/libc.so<span class="number">.6</span> (<span class="number">0x00007f41bff8e000</span>)</span><br><span class="line">/lib64/ld-linux-x86<span class="number">-64.</span>so<span class="number">.2</span> (<span class="number">0x00007f41c0b7c000</span>)</span><br></pre></td></tr></table></figure><p>链接静态库</p><p><code>TARGET_LINK_LIBRARIES(main libhello.a)</code></p><h3 id="特殊的环境变量-cmake_include_path-和-cmake_library_path"><a class="markdownIt-Anchor" href="#特殊的环境变量-cmake_include_path-和-cmake_library_path"></a> 特殊的环境变量 CMAKE_INCLUDE_PATH 和 CMAKE_LIBRARY_PATH</h3><p>注意：这两个是环境变量而不是 cmake 变量，可以在linux的bash中进行设置</p><p>我们上面例子中使用了绝对路径INCLUDE_DIRECTORIES(/usr/include/hello)来指明include路径的位置</p><p>我们还可以使用另外一种方式，使用环境变量export CMAKE_INCLUDE_PATH=/usr/include/hello</p><p>补充：生产debug版本的方法：<br />cmake … -DCMAKE_BUILD_TYPE=debug</p>]]></content>
    
    
    <summary type="html">cmake学习笔记，真好用真好用:-)</summary>
    
    
    
    <category term="linux" scheme="http://aflyingsheep.github.io/categories/linux/"/>
    
    
    <category term="C++" scheme="http://aflyingsheep.github.io/tags/C/"/>
    
    <category term="linux" scheme="http://aflyingsheep.github.io/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>C++：模板类和静态成员变量</title>
    <link href="http://aflyingsheep.github.io/2023/01/08/cpp/template_and_static/"/>
    <id>http://aflyingsheep.github.io/2023/01/08/cpp/template_and_static/</id>
    <published>2023-01-08T08:57:06.000Z</published>
    <updated>2023-02-11T13:10:34.737Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="c-模板类和静态成员变量"><a class="markdownIt-Anchor" href="#c-模板类和静态成员变量"></a> C++ 模板类和静态成员变量</h1><p>当一个模板类产生不同的类时，<strong>每个类产生的对象共享static变量</strong>，静态成员变量作用于类层面。即类间不共享，类内共享。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> size_type&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">hello</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> s_a;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">()</span> </span>&#123;</span><br><span class="line">s_a++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;; </span><br><span class="line"></span><br><span class="line"><span class="comment">// 模板类中静态变量的定义</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">size_type</span>&gt;</span> <span class="keyword">int</span> hello&lt;size_type&gt;::s_a = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">hello&lt;<span class="keyword">int</span>&gt; h3;</span><br><span class="line">hello&lt;<span class="keyword">char</span>&gt; h4; </span><br><span class="line"></span><br><span class="line">h3.<span class="built_in">add</span>();</span><br><span class="line">h4.<span class="built_in">add</span>();</span><br><span class="line">h4.<span class="built_in">add</span>();</span><br><span class="line"></span><br><span class="line">std::cout &lt;&lt; hello&lt;<span class="keyword">int</span>&gt;::s_a &lt;&lt; std::endl;</span><br><span class="line">std::cout &lt;&lt; hello&lt;<span class="keyword">char</span>&gt;::s_a &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    out:</span></span><br><span class="line"><span class="comment">    1</span></span><br><span class="line"><span class="comment">    2</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">当一个模板类产生不同的类时，每个类产生的对象共享static变量，静态成员变量作用于类层面</summary>
    
    
    
    <category term="C++" scheme="http://aflyingsheep.github.io/categories/C/"/>
    
    
    <category term="C++" scheme="http://aflyingsheep.github.io/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>C++杂谈笔记</title>
    <link href="http://aflyingsheep.github.io/2023/01/05/cpp/%E6%9D%82%E7%83%A9/"/>
    <id>http://aflyingsheep.github.io/2023/01/05/cpp/%E6%9D%82%E7%83%A9/</id>
    <published>2023-01-05T13:27:06.000Z</published>
    <updated>2023-02-11T13:08:54.894Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><strong>左值和右值</strong></p><p>左值的英文简写为“lvalue”，右值的英文简写为“rvalue”。很多人认为它们分别是&quot;left value&quot;、“right value” 的缩写，其实不然。lvalue 是“loactor value”的缩写，可意为存储在内存中、有明确存储地址（可寻址）的数据，而 rvalue 译为 “read value”，指的是那些可以提供数据值的数据（不一定可以寻址，例如存储于寄存器中的数据）。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 左值引用</span></span><br><span class="line"><span class="keyword">int</span> num = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> &amp;b = num;     <span class="comment">// 正确</span></span><br><span class="line"><span class="keyword">int</span> &amp;c = <span class="number">10</span>;      <span class="comment">// 错误</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">int</span> num = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> &amp;b = num;   <span class="comment">// 正确</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> &amp;c = <span class="number">10</span>;    <span class="comment">// 正确</span></span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="comment">// 右值引用</span></span><br><span class="line"><span class="keyword">int</span> num = <span class="number">10</span>;</span><br><span class="line"><span class="comment">//int &amp;&amp; a = num;    // 错误，右值引用不能初始化为左值</span></span><br><span class="line"><span class="keyword">int</span> &amp;&amp; a = <span class="number">10</span>;       <span class="comment">// 正确</span></span><br><span class="line"> </span><br><span class="line">a = <span class="number">100</span>;</span><br><span class="line">cout &lt;&lt; a &lt;&lt; endl;   <span class="comment">// 输出为100，右值引用可以修改值</span></span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="comment">// 右值引用的使用</span></span><br><span class="line"><span class="comment">// 如 thread argv 的传入</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Callable, <span class="keyword">typename</span>... _Args&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">explicit</span> <span class="title">thread</span><span class="params">(_Callable&amp;&amp; __f, _Args&amp;&amp;... __args)</span> </span>&#123; </span><br><span class="line"><span class="comment">//.... </span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Args&amp;&amp;... args 是对函数参数的类型 Args&amp;&amp; 进行展开</span></span><br><span class="line"><span class="comment">// args... 是对函数参数 args 进行展开</span></span><br><span class="line"><span class="comment">// explicit 只对构造函数起作用，用来抑制隐式转换</span></span><br></pre></td></tr></table></figure><p><a href="https://blog.csdn.net/TABE_/article/details/122609775">(2条消息) C++ 左值和右值_TABE_的博客-CSDN博客_左值和右值</a></p><p>讲的非常好</p><p><strong>可变参数</strong></p><p><a href="https://blog.csdn.net/wodownload2/article/details/117512062">(2条消息) C<ins>中可变参数…args_wodownload2的博客-CSDN博客_c</ins> args…</a></p><p><a href="https://blog.csdn.net/chenlong_cxy/article/details/126807356">(2条消息) C<ins>11 ——— 可变参数模板_2021dragon的博客-CSDN博客_c</ins>11 可变参数模板</a></p><p><a href="https://blog.csdn.net/f110300641/article/details/83477160">(2条消息) 理解std::move和std::forward_土戈的博客-CSDN博客_std::forward</a></p><p>C++ move &amp;&amp; forward</p><p><strong>std::move</strong></p><p>c++11中提供了std::move()来将左值转换为右值引用，从而方便的使用移动语义。move是将对象的状态或者所有权从一个对象转移到另一个对象，只是转移，没有内存拷贝。</p><p>c++中所有容器都实现了move语义，方便我们实现性能优化。move对于拥有形如对内存、文件句柄等资源的成员的对象有效。如果是一些基本类型，比如int或char[10]数组等，如果使用move，仍然会发生拷贝（因为没有对应的移动构造函数）。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">std::list&lt;std::string&gt; tokens;</span><br><span class="line"><span class="comment">// 发生了移动构造。list的实现，将目的资源句柄赋值为源资源句柄，而将源资源句柄清空</span></span><br><span class="line">std::list&lt;std::string&gt; t = std::<span class="built_in">move</span>(tokens);</span><br></pre></td></tr></table></figure><p><strong>std::forward</strong></p><p>右值引用类型是独立于值的，一个右值引用参数作为函数的形参，在函数内部再转发该参数的时候它已经变成一个左值，并不是他原来的类型。</p><p>需要一种方法能够按照参数原来的类型转发到另一个函数，这种转发类型称为<strong>完美转发</strong>。</p><p>完美转发（Perfect Forwarding），是指在函数模板中，完全依照模板的参数的类型（即保持参数的左值、右值特征），将参数传递给函数模板中调用的另外一个函数。C++11中提供了这样的一个函数std::forward，它是为转发而生的，不管参数是T&amp;&amp;这种未定的引用还是明确的左值引用或者右值引用，它会按照参数本来的类型转发。</p><p><strong>tuple</strong></p><p><a href="https://blog.csdn.net/sinat_31608641/article/details/123315773">(2条消息) C<ins>的tuple_物随心转的博客-CSDN博客_c</ins> tuple</a></p><p><strong>C++模板 - index_sequence</strong></p><p><a href="https://blog.csdn.net/qq_51986723/article/details/127602490">(2条消息) C++模板 - index_sequence_AMjieker的博客-CSDN博客_std::index_sequence</a></p><p>// vector.reserve() 更改vector的容量（capacity），使vector至少可以容纳n个元素。</p><p>// 如果n大于vector当前的容量，reserve会对vector进行扩容。其他情况下都不会重新分配vector的存储空间</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="C++" scheme="http://aflyingsheep.github.io/categories/C/"/>
    
    
    <category term="C++" scheme="http://aflyingsheep.github.io/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>Codelet调度模型与Swdarts</title>
    <link href="http://aflyingsheep.github.io/2022/12/31/science_research/Codelet/"/>
    <id>http://aflyingsheep.github.io/2022/12/31/science_research/Codelet/</id>
    <published>2022-12-31T10:27:06.000Z</published>
    <updated>2023-02-11T13:11:54.313Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="codelet程序执行模型"><a class="markdownIt-Anchor" href="#codelet程序执行模型"></a> Codelet程序执行模型</h1><h2 id="基本单元"><a class="markdownIt-Anchor" href="#基本单元"></a> 基本单元</h2><ul><li>codelet程序执行模型的基本调度和执行单元</li><li>一个codelet是一些机器指令的集合（代码片段）</li><li>codelet一旦开始执行，不会被中断或迁移</li><li>codelet中不包括延迟时间长或等待的操作</li><li>codelet间异步、并发，产生若干token(数据)作为输出</li></ul><h2 id="激发规则"><a class="markdownIt-Anchor" href="#激发规则"></a> 激发规则</h2><ol><li>休眠状态：数据依赖未满足</li><li>就绪状态：数据依赖满足</li><li>激发状态：有空闲的计算单元且事件依赖被满足</li><li>完成状态：完成计算</li></ol><h2 id="codelet-graph"><a class="markdownIt-Anchor" href="#codelet-graph"></a> Codelet Graph</h2><p>计算任务被划分成大量的codelet, 这些codelet及其依赖关系构成一张数据流图，称位Codelet Graph(CDG)。CDG是一个有向无环图。</p><p>CDG被划分为一个个子图，每个子图被分配一个Threaded Procedure（TP），由TP对其调度和执行。</p><h2 id="threaded-procedure"><a class="markdownIt-Anchor" href="#threaded-procedure"></a> Threaded Procedure</h2><p>TP是异步的函数，以控制流的方式被调用，包括一个<strong>上下文框架</strong>和<strong>CDG子图</strong>。</p><ul><li>上下文框架：为CDG中的codelet提供所需所有数据操作服务（初始化输入数据、为中间数据分配和释放空间、输出数据分配空间）</li><li>TP被实例化后，绑定到一个核簇（cluster）上。TP的CDG子图中所有codelet被分配给该cluster调度执行。</li><li>TP被实例化之前可以在cluster间迁移，以进行负载平衡。一旦被分配给一个cluster后，TP便不可移动。</li></ul><h2 id="抽象机器模型"><a class="markdownIt-Anchor" href="#抽象机器模型"></a> 抽象机器模型</h2><p>抽象机器系统由若干计算节点（node）构成，计算节点以互联网络连接。每个计算节点由一个或者多个many-core chip构成，节点内chip以高速开关或总线互联。</p><p>Chip上的cluster以片上网络互联，每个cluster上有多个core。core分为计算单元（CU）和调度单元（SU）。CU负责执行codelet，SU负责：(1) 管理cluster所有硬件资源 (2) 在cluster间调度TP (3) 将处于就绪态的codelet依据一定调度策略给合适的CU执行。</p><p><img src="/image/codelet/1.png" alt="1" /></p><h1 id="swdarts"><a class="markdownIt-Anchor" href="#swdarts"></a> Swdarts</h1><h2 id="抽象机器模型-2"><a class="markdownIt-Anchor" href="#抽象机器模型-2"></a> 抽象机器模型</h2><p>为了利用申威众核异构平台，需要将Codelet抽象机器模型映射到国产异构众核平台上。</p><ul><li>核组即可映射为Codelet抽象机器模型中的cluster，包含两种不同功能的core：<ul><li>主核：调度单元，负责任务分配和调度</li><li>从核：计算单元，负责任务计算</li></ul></li></ul><p><img src="/image/codelet/2.png" alt="2" /></p><h2 id="runtime-system设计与实现"><a class="markdownIt-Anchor" href="#runtime-system设计与实现"></a> Runtime system设计与实现</h2><p>Runtime system主要负责任务的分配调度和任务间通信，是核心组件。</p><p>整个系统分为两层：</p><ul><li>用户层：提供给用户描述、生成、调度可执行任务的接口，<strong>用户通过所提供接口</strong>对应用程序进行<strong>数据流风格的抽象</strong>，并使用接口将可执行任务交给下一层</li><li>运行时执行层：负责将以满足数据依赖关系的计算任务分配给空闲的硬件资源<ul><li>设置了任务队列，入队的任务表示依赖关系已经满足</li></ul></li></ul><h3 id="前端接口设计"><a class="markdownIt-Anchor" href="#前端接口设计"></a> 前端接口设计</h3><ol><li>Task类：所有任务的抽象基类<ul><li>主要包括计算任务需要的上下文数据、可并行的计算任务、任务之间的数据依赖（CDG子图）</li><li>对应Codelet中的TP</li><li>可以发起生成一段可以并行执行的tasklet和task任务</li><li>需要维护任务之间的链接关系来维护上下文数据的生命周期<ul><li>execute(): task的执行函数，函数中可以做计算，也可以启动其他并行任务(task, tasklet)，再次声明任务之间的依赖关系</li><li>invoke(task) 启动并行执行的task任务</li><li>spawn_task(task_ptr) 将满足依赖关系的task任务放到任务队列中</li></ul></li></ul></li><li>Tasklet类：对应codelet，是运行时系统中的基本执行和调度单元<ul><li>tasklet无需维护上下文数据，只需管理tasklet任务间的依赖关系</li><li>tasklet组成：依赖计数、执行函数、通知函数<ul><li>spawn_tasklet(tasklet_ptr): 将tasklet放入tasklet队列中</li><li>release(): 释放tasklet的依赖计数，当计数为0时，调用spawn_tasklet()函数</li><li>execute(): 执行函数，执行过程调用激发函数，通过上述函数声明tasklet之间的依赖关系（？？）</li><li>can_spawn_on_cpe(): 表示tasklet在主核上还是从核上执行</li></ul></li></ul></li><li>enable_cpe_spawn类：与tasklet类基本相同，定义为可以在从核上运行的代码，只有执行函数<ul><li>创建该类原因：tasklet或enable_cpe_spawn依赖计数减为0时，被放入任务队列。依赖计数操作和通知操作会放在主核上执行，但是从核如果可以依赖计数操作和通知操作，需要对主核队列进行读写原子操作，代价大、成本高。<ul><li>spawn__(): 主从核之间的任务传递，并在从核上执行计算任务</li></ul></li></ul></li><li>Runtime类：要负责任务的调度和执行，以及判断tasklet任务是否可以放到从核上执行，由用户声明。<ul><li>make_tasklet(): 用于将函数定义或转换为tasklet</li><li>execute_and_wait(): 用于启动运行时系统和定义运行时系统停止的条件，并将数据流抽象化的应用交给运行时系统。</li><li>launch(Args…): 用户构造task时，通过launch()函数将任务需要的上下文传递给task</li></ul></li></ol><h3 id="运行时系统设计"><a class="markdownIt-Anchor" href="#运行时系统设计"></a> 运行时系统设计</h3><p>运行时系统：负责任务分配调度和执行；负责启动、管理从核</p><ul><li>给从核队列中每个从核设置三种状态：初始化、空闲和繁忙</li><li>从核完成tasklet计算任务后，主核完成tasklet的通知任务，并将满足数据依赖的任务push到对应任务队列中</li><li>循环检查task任务队列，将队首任务取出并执行；循环检查tasklet任务队列，将队首tasklet根据用户声明交给主核或从核执行</li></ul><p>运行时系统执行流程：</p><ol><li>用户完成应用的数据流化抽象，通过接口交给运行时系统</li><li>将满足依赖关系的任务放入任务队列</li><li>查询从核阵列状态，如果有空间资源，将任务分配计算</li><li>从核计算完成，改变对应从核状态</li></ol><p><img src="/image/codelet/3.png" alt="3" /></p><h3 id="继承关系"><a class="markdownIt-Anchor" href="#继承关系"></a> 继承关系</h3><ul><li>std::enable_shared_from_this&lt;task&gt;<ul><li>task<ul><li>tasklet<ul><li>mem_fn_tasklet</li></ul></li><li>task_context</li></ul></li></ul></li></ul>]]></content>
    
    
    <summary type="html">Codelet是一种针对E级计算机的需求而进行设计的细粒度并行、事件驱动的程序执行模型。</summary>
    
    
    
    <category term="HPC" scheme="http://aflyingsheep.github.io/categories/HPC/"/>
    
    
    <category term="HPC" scheme="http://aflyingsheep.github.io/tags/HPC/"/>
    
  </entry>
  
  <entry>
    <title>C++智能指针：shared_ptr</title>
    <link href="http://aflyingsheep.github.io/2022/12/12/cpp/shared_pointer/"/>
    <id>http://aflyingsheep.github.io/2022/12/12/cpp/shared_pointer/</id>
    <published>2022-12-12T13:22:06.000Z</published>
    <updated>2023-02-11T13:16:32.235Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>使用raw pointer管理动态内存出现的问题：</p><ol><li>忘记delete内存，造成内存泄露；</li><li>抛出异常时，无法执行delete，造成内存泄漏。</li></ol><h1 id="智能指针shared_ptrの原理"><a class="markdownIt-Anchor" href="#智能指针shared_ptrの原理"></a> 智能指针shared_ptrの原理</h1><p>shared_ptr是最常用的C++11提供的智能指针。shared_ptr采用了引用计数器，多个shared_ptr中的T *ptr指向同一个内存区域（同一个对象），并<strong>共同维护同一个引用计数器</strong>。shared_ptr定义如下，记录同一个实例被引用的次数，当引用次数大于0时可用，等于0时释放内存。</p><p>从而可以在任何地方都不使用时自动删除相关指针，从而帮助彻底消除内存泄漏和悬空指针的问题。</p><p>每个 shared_ptr 对象在内部维护着两个内存位置：</p><ol><li><strong>指向对象</strong>的指针。</li><li>用于<strong>控制引用计数数据</strong>的指针。</li></ol><ul><li><p><strong>共享所有权如何在参考计数的帮助下工作的？</strong></p><ol><li><p>当新的 shared_ptr 对象与指针关联时，则在其构造函数中，将与此指针关联的引用计数增加1。</p></li><li><p>当任何 shared_ptr 对象超出作用域时，则在其析构函数中，它将关联指针的引用计数减1。如果引用计数变为0，则表</p><p>示没有其他 shared_ptr 对象与此内存关联，在这种情况下，它使用delete函数删除该内存。</p></li></ol></li><li><p><strong>注意避免循环引用</strong>，shared_ptr的一个最大的陷阱是循环引用，循环，循环引用会导致堆内存无法正确释放，导致内存泄漏。循环引用在weak_ptr中介绍。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">temple&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SharedPtr</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">   ...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T *_ptr;</span><br><span class="line">    <span class="keyword">int</span> *_refCount;     <span class="comment">//should be int*, rather than int</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><p>一、 构造函数与析构函数</p><ol><li><p>shared_ptr对象每次离开作用域时会自动调用析构函数，而析构函数并不像其他类的析构函数一样，而是在释放内存是先判断引用计数器是否为0。等于0才做delete操作，否则只对引用计数器左减一操作。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">~<span class="built_in">SharedPtr</span>() &#123;</span><br><span class="line">    <span class="keyword">if</span> (_ptr &amp;&amp; --*_refCount == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">delete</span> _ptr;</span><br><span class="line">        <span class="keyword">delete</span> _refCount;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>构造函数：<strong>默认构造函数的引用计数器为0，ptr指向NULL</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">SharedPtr</span>() : _ptr((T *)<span class="number">0</span>), _refCount(<span class="number">0</span>) &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>用<strong>普通指针初始化智能指针时，引用计数器初始化为1</strong>：</p><p>创建空的 shared_ptr 对象</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">explicit</span> <span class="title">SharedPtr</span><span class="params">(T *obj)</span> : _ptr(obj), _refCount(new int(<span class="number">1</span>)) &#123;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 这里无法防止循环引用，若我们用同一个普通指针去初始化两个shared_ptr，</span></span><br><span class="line"><span class="comment">// 此时两个ptr均指向同一片内存区域，但是引用计数器均为1，使用时需要注意</span></span><br></pre></td></tr></table></figure><p>因为带有参数的 shared_ptr 构造函数是 explicit 类型的，所以不能像这样<code>std::shared_ptr&lt;int&gt; p1 = new int();</code>隐式调用它构造函数。创建新的shared_ptr对象的最佳方法是使用<code>std :: make_shared</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::shared_ptr&lt;<span class="keyword">int</span>&gt; p1 = std::make_shared&lt;<span class="keyword">int</span>&gt;();</span><br></pre></td></tr></table></figure><p><strong>std::make_shared</strong> 一次性为<code>int</code>对象和用于引用计数的数据都分配了内存，而<code>new</code>操作符只是为<code>int</code>分配了内存。</p></li><li><p><strong>拷贝构造函数</strong>需要注意，用一个shared_ptr对象去初始化另一个shared_ptr对象时，<strong>引用计数器加一，并指向同一片内存区域</strong>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">SharedPtr</span>(SharedPtr &amp;other) : _ptr(other._ptr), _refCount(&amp;(++*other._refCount)) &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="5"><li>赋值运算符的重载</li></ol><p>当用一个shared_ptr<T> other去给另一个 shared_ptr<T> sp赋值时，发生了两件事情：</p><ul><li><p>sp指针指向发生变化，不再指向之前的内存区域，所以赋值前原来的_refCount要自减</p></li><li><p>sp指针指向other.ptr，所以other的引用计数器_refCount要做++操作。</p></li></ul> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">SharedPtr &amp;<span class="keyword">operator</span>=(SharedPtr &amp;other) &#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">this</span>==&amp;other)</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line"> </span><br><span class="line">    ++*other._refCount;</span><br><span class="line">    <span class="keyword">if</span> (--*_refCount == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">delete</span> _ptr;</span><br><span class="line">        <span class="keyword">delete</span> _refCount;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    _ptr = other._ptr;</span><br><span class="line">    _refCount = other._refCount;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>二、 自定义运算符</p><ol><li><p>定义解引用运算符，直接返回底层指针的引用：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">T &amp;<span class="keyword">operator</span>*() &#123;</span><br><span class="line">    <span class="keyword">if</span> (_refCount == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> (T*)<span class="number">0</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> *_ptr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>定义指针运算符-&gt;</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">T *<span class="keyword">operator</span>-&gt;() &#123;</span><br><span class="line">    <span class="keyword">if</span>(_refCount == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> _ptr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h1 id="shared_ptr-使用の注意事项"><a class="markdownIt-Anchor" href="#shared_ptr-使用の注意事项"></a> shared_ptr 使用の注意事项</h1><ol><li><p><strong>缺少<code>++，––, [] </code>运算符，仅提供 <code>--&gt;, *, ==</code>运算符。</strong></p></li><li><p><strong>NULL检测</strong></p><p>当我们创建 shared_ptr 对象而不分配任何值时，它就是空的；普通指针不分配空间的时候相当于一个野指针，指向垃圾空间，且无法判断指向的是否是有用数据。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">std::shared_ptr&lt;Sample&gt; ptr3;</span><br><span class="line"><span class="keyword">if</span>(!ptr3)</span><br><span class="line">std::cout&lt;&lt;<span class="string">&quot;Yes, ptr3 is empty&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"><span class="keyword">if</span>(ptr3 == <span class="literal">NULL</span>)</span><br><span class="line">std::cout&lt;&lt;<span class="string">&quot;ptr3 is empty&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"><span class="keyword">if</span>(ptr3 == <span class="literal">nullptr</span>)</span><br><span class="line">std::cout&lt;&lt;<span class="string">&quot;ptr3 is empty&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">输出结果：</span></span><br><span class="line"><span class="comment">Yes, ptr3 is empty</span></span><br><span class="line"><span class="comment">ptr3 is empty</span></span><br><span class="line"><span class="comment">ptr3 is empty</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></li><li><p><strong>创建 shared_ptr 的注意事项</strong></p><p><strong>不要使用同一个原始指针构造 shared_ptr</strong></p><p>创建多个 shared_ptr 的正常方法是使用一个已存在的shared_ptr 进行创建，而不是使用同一个原始指针进行创建。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> *num = <span class="keyword">new</span> <span class="built_in"><span class="keyword">int</span></span>(<span class="number">23</span>);</span><br><span class="line"><span class="function">std::shared_ptr&lt;<span class="keyword">int</span>&gt; <span class="title">p1</span><span class="params">(num)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">std::shared_ptr&lt;<span class="keyword">int</span>&gt; <span class="title">p2</span><span class="params">(p1)</span></span>;  <span class="comment">// 正确使用方法</span></span><br><span class="line"><span class="function">std::shared_ptr&lt;<span class="keyword">int</span>&gt; <span class="title">p3</span><span class="params">(num)</span></span>; <span class="comment">// 不推荐</span></span><br><span class="line"></span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;p1 Reference = &quot;</span> &lt;&lt; p1.<span class="built_in">use_count</span>() &lt;&lt; std::endl; <span class="comment">// 输出 2</span></span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;p2 Reference = &quot;</span> &lt;&lt; p2.<span class="built_in">use_count</span>() &lt;&lt; std::endl; <span class="comment">// 输出 2</span></span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;p3 Reference = &quot;</span> &lt;&lt; p3.<span class="built_in">use_count</span>() &lt;&lt; std::endl; <span class="comment">// 输出 1</span></span><br></pre></td></tr></table></figure><p>假如使用原始指针<code>num</code>创建了p1，又同样方法创建了p3，当p1超出作用域时会调用<code>delete</code>释放<code>num</code>内存，此时num成了悬空指针，当p3超出作用域再次<code>delete</code>的时候就可能会出错。</p></li><li><p><strong>不要用栈中的指针构造 shared_ptr 对象</strong></p><p>shared_ptr 默认的构造函数中使用的是<code>delete</code>来删除关联的指针，所以构造的时候也必须使用<code>new</code>出来的堆空间的指针。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;memory&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">int</span> x = <span class="number">12</span>;</span><br><span class="line">   <span class="function">std::shared_ptr&lt;<span class="keyword">int</span>&gt; <span class="title">ptr</span><span class="params">(&amp;x)</span></span>;</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当 shared_ptr 对象超出作用域调用析构函数<code>delete</code> 指针<code>&amp;x</code>时会出错。</p></li><li><p><strong>建议使用 make_shared</strong></p><p>为了避免以上两种情形，建议使用<code>make_shared()&lt;&gt;</code>创建 shared_ptr 对象，而不是使用默认构造函数创建。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">std::shared_ptr&lt;<span class="keyword">int</span>&gt; ptr_1 = make_shared&lt;<span class="keyword">int</span>&gt;();</span><br><span class="line"><span class="function">std::shared_ptr&lt;<span class="keyword">int</span>&gt; <span class="title">ptr_2</span> <span class="params">(ptr_1)</span></span>;</span><br></pre></td></tr></table></figure><p>另外不建议使用<code>get()</code>函数获取 shared_ptr 关联的原始指针，因为如果在 shared_ptr 析构之前手动调用了<code>delete</code>函数，同样会导致类似的错误。</p></li></ol>]]></content>
    
    
    <summary type="html">C++引入智能指针，可用于动态资源管理，资源即对象的管理策略。</summary>
    
    
    
    <category term="CS" scheme="http://aflyingsheep.github.io/categories/CS/"/>
    
    
    <category term="CS" scheme="http://aflyingsheep.github.io/tags/CS/"/>
    
    <category term="C/C++" scheme="http://aflyingsheep.github.io/tags/C-C/"/>
    
  </entry>
  
  <entry>
    <title>C++：explicit</title>
    <link href="http://aflyingsheep.github.io/2022/12/12/cpp/explicit/"/>
    <id>http://aflyingsheep.github.io/2022/12/12/cpp/explicit/</id>
    <published>2022-12-12T13:21:06.000Z</published>
    <updated>2023-02-11T13:20:19.730Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="cexplicit关键字详解"><a class="markdownIt-Anchor" href="#cexplicit关键字详解"></a> C++explicit关键字详解</h1><p>C++中的explicit关键字只能用于<strong>修饰只有一个参数的类构造函数</strong>，它的作用是<strong>表明该构造函数是显式的, 而非隐式的</strong>，跟它相对应的另一个关键字是implicit，意思是隐藏的，<strong>类构造函数默认情况下即声明为implicit(隐式)</strong>。</p><p>下面是显式声明与隐式声明构造函数的区别例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CxString</span>  // 没有使用<span class="title">explicit</span>关键字的类声明, 即默认为隐式声明  </span></span><br><span class="line"><span class="class">&#123;</span>  </span><br><span class="line"><span class="keyword">public</span>:  </span><br><span class="line">    <span class="keyword">char</span> *_pstr;  </span><br><span class="line">    <span class="keyword">int</span> _size;  </span><br><span class="line">    <span class="built_in">CxString</span>(<span class="keyword">int</span> size)  </span><br><span class="line">    &#123;  </span><br><span class="line">        _size = size;                <span class="comment">// string的预设大小  </span></span><br><span class="line">        _pstr = <span class="built_in">malloc</span>(size + <span class="number">1</span>);    <span class="comment">// 分配string的内存  </span></span><br><span class="line">        <span class="built_in">memset</span>(_pstr, <span class="number">0</span>, size + <span class="number">1</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="built_in">CxString</span>(<span class="keyword">const</span> <span class="keyword">char</span> *p)  </span><br><span class="line">    &#123;  </span><br><span class="line">        <span class="keyword">int</span> size = <span class="built_in">strlen</span>(p);  </span><br><span class="line">        _pstr = <span class="built_in">malloc</span>(size + <span class="number">1</span>);    <span class="comment">// 分配string的内存  </span></span><br><span class="line">        <span class="built_in">strcpy</span>(_pstr, p);            <span class="comment">// 复制字符串  </span></span><br><span class="line">        _size = <span class="built_in">strlen</span>(_pstr);  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="comment">// 析构函数这里不讨论, 省略...  </span></span><br><span class="line">&#125;;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 下面是调用:  </span></span><br><span class="line">  </span><br><span class="line">    <span class="function">CxString <span class="title">string1</span><span class="params">(<span class="number">24</span>)</span></span>;     <span class="comment">// 这样是OK的, 为CxString预分配24字节的大小的内存  </span></span><br><span class="line">    CxString string2 = <span class="number">10</span>;    <span class="comment">// 这样是OK的, 为CxString预分配10字节的大小的内存  </span></span><br><span class="line">    CxString string3;         <span class="comment">// 这样是不行的, 因为没有默认构造函数, 错误为: &quot;CxString&quot;: 没有合适的默认构造函数可用  </span></span><br><span class="line">    <span class="function">CxString <span class="title">string4</span><span class="params">(<span class="string">&quot;aaaa&quot;</span>)</span></span>; <span class="comment">// 这样是OK的  </span></span><br><span class="line">    CxString string5 = <span class="string">&quot;bbb&quot;</span>; <span class="comment">// 这样也是OK的, 调用的是CxString(const char *p)  </span></span><br><span class="line">    CxString string6 = <span class="string">&#x27;c&#x27;</span>;   <span class="comment">// 这样也是OK的, 其实调用的是CxString(int size), 且size等于&#x27;c&#x27;的ascii码  </span></span><br><span class="line">    string1 = <span class="number">2</span>;              <span class="comment">// 这样也是OK的, 为CxString预分配2字节的大小的内存  </span></span><br><span class="line">    string2 = <span class="number">3</span>;              <span class="comment">// 这样也是OK的, 为CxString预分配3字节的大小的内存  </span></span><br><span class="line">    string3 = string1;        <span class="comment">// 这样也是OK的, 至少编译是没问题的, 但是如果析构函数里用</span></span><br></pre></td></tr></table></figure><p>free释放_pstr内存指针的时候可能会报错，完整的代码必须重载运算符&quot;=&quot;，并在其中处理内存释放。</p><p><strong>&quot;CxString string2 = 10;&quot;这句为什么是可以的呢?</strong></p><p>在C++中, 如果的<strong>构造函数只有一个参数时</strong>，那么在编译的时候就会有一个<strong>缺省的转换操作</strong>：将该构造函数对应数据类型的数据转换为该类对象。也就是说&quot;CxString string2 = 10;&quot;这段代码，<strong>编译器自动将整型转换为CxString类对象</strong>, 实际上等同于下面的操作：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">CxString <span class="title">string2</span><span class="params">(<span class="number">10</span>)</span></span>;  </span><br><span class="line"></span><br><span class="line"><span class="comment">// 或者</span></span><br><span class="line"><span class="function">CxString <span class="title">temp</span><span class="params">(<span class="number">10</span>)</span></span>;  </span><br><span class="line">CxString string2 = temp; </span><br></pre></td></tr></table></figure><p>但是, 上面的代码中的_size代表的是字符串内存分配的大小，那么调用的第二句 &quot;CxString string2 = 10;&quot;和第六句 “CxString string6 = ‘c’;” 就显得不伦不类，而且容易让人疑惑。有什么办法阻止这种用法呢？答案就是使用explicit关键字。我们把上面的代码修改一下，如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CxString</span>  // 使用关键字<span class="title">explicit</span>的类声明, 显示转换  </span></span><br><span class="line"><span class="class">&#123;</span>  </span><br><span class="line"><span class="keyword">public</span>:  </span><br><span class="line">    <span class="keyword">char</span> *_pstr;  </span><br><span class="line">    <span class="keyword">int</span> _size;  </span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">CxString</span><span class="params">(<span class="keyword">int</span> size)</span>  </span></span><br><span class="line"><span class="function">    </span>&#123;  </span><br><span class="line">        _size = size;  </span><br><span class="line">        <span class="comment">// 代码同上, 省略...  </span></span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="built_in">CxString</span>(<span class="keyword">const</span> <span class="keyword">char</span> *p)  </span><br><span class="line">    &#123;  </span><br><span class="line">        <span class="comment">// 代码同上, 省略...  </span></span><br><span class="line">    &#125;  </span><br><span class="line">&#125;;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 下面是调用:  </span></span><br><span class="line">  </span><br><span class="line">    <span class="function">CxString <span class="title">string1</span><span class="params">(<span class="number">24</span>)</span></span>;     <span class="comment">// 这样是OK的  </span></span><br><span class="line">    CxString string2 = <span class="number">10</span>;    <span class="comment">// 这样是不行的, 因为explicit关键字取消了隐式转换  </span></span><br><span class="line">    CxString string3;         <span class="comment">// 这样是不行的, 因为没有默认构造函数  </span></span><br><span class="line">    <span class="function">CxString <span class="title">string4</span><span class="params">(<span class="string">&quot;aaaa&quot;</span>)</span></span>; <span class="comment">// 这样是OK的  </span></span><br><span class="line">    CxString string5 = <span class="string">&quot;bbb&quot;</span>; <span class="comment">// 这样也是OK的, 调用的是CxString(const char *p)  </span></span><br><span class="line">    CxString string6 = <span class="string">&#x27;c&#x27;</span>;   <span class="comment">// 这样是不行的, 其实调用的是CxString(int size), 且size等于&#x27;c&#x27;的ascii码, 但explicit关键字取消了隐式转换  </span></span><br><span class="line">    string1 = <span class="number">2</span>;              <span class="comment">// 这样也是不行的, 因为取消了隐式转换  </span></span><br><span class="line">    string2 = <span class="number">3</span>;              <span class="comment">// 这样也是不行的, 因为取消了隐式转换  </span></span><br><span class="line">    string3 = string1;        <span class="comment">// 这样也是不行的, 因为取消了隐式转换, 除非类实现操作符&quot;=&quot;的重载 </span></span><br></pre></td></tr></table></figure><p>explicit关键字的作用就是<strong>防止类构造函数的隐式自动转换</strong></p><p>上面也已经说过了，explicit关键字只对有一个参数的类构造函数有效，<strong>如果类构造函数参数大于或等于两个时,是不会产生隐式转换的，所以explicit关键字也就无效了</strong>。</p><p>但是, 也有一个例外，就是<strong>当除了第一个参数以外的其他参数都有默认值的时候，explicit关键字依然有效</strong>，此时，当调用构造函数时只传入一个参数，等效于只有一个参数的类构造函数。</p><h1 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h1><p>explicit关键字只需用于类内的单参数构造函数前面。由于无参数的构造函数和多参数的构造函数总是显示调用，这种情况在构造函数前加explicit无意义。</p><p>google的c++规范中提到explicit的优点是可以避免不合时宜的类型变换，缺点无。所以google约定所有单参数的构造函数都必须是显示的，只有极少数情况下拷贝构造函数可以不声明称explicit。例如作为其他类的透明包装器的类。</p><p>effective c++中说：被声明为explicit的构造函数通常比其non-explicit兄弟更受欢迎。因为它们禁止编译器执行非预期（往往也不被期望）的类型转换。除非我有一个好理由允许构造函数被用于隐式类型转换，否则我会把它声明为explicit，鼓励大家遵循相同的政策。</p>]]></content>
    
    
    <summary type="html">C++ explicit关键字详解。</summary>
    
    
    
    <category term="CS" scheme="http://aflyingsheep.github.io/categories/CS/"/>
    
    
    <category term="CS" scheme="http://aflyingsheep.github.io/tags/CS/"/>
    
    <category term="C/C++" scheme="http://aflyingsheep.github.io/tags/C-C/"/>
    
  </entry>
  
  <entry>
    <title>树状数组理解</title>
    <link href="http://aflyingsheep.github.io/2022/11/16/algorithm/binary_indexed_tree/"/>
    <id>http://aflyingsheep.github.io/2022/11/16/algorithm/binary_indexed_tree/</id>
    <published>2022-11-16T12:28:06.000Z</published>
    <updated>2022-11-16T13:39:06.339Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="树状数组的问题模型"><a class="markdownIt-Anchor" href="#树状数组的问题模型"></a> 树状数组的问题模型</h1><p>朴素的查询区间和+修改操作的时间复杂度为O(1) &amp; O(n)，树状数组将其时间复杂度降低至均为O(logn)。</p><h1 id="lowbit函数"><a class="markdownIt-Anchor" href="#lowbit函数"></a> lowbit函数</h1><p>顾名思义，<code>lowbit</code>这个函数的功能就是求某一个数的二进制表示中最低的一位<code>1</code>，举个例子，<code>x = 6</code>，它的二进制为<code>110</code>，那么<code>lowbit(x)</code>就返回<code>2</code>，因为最后一位<code>1</code>表示<code>2</code>。</p><p>两种方法实现：</p><ol><li>消除最后一位1，再用原数减去消除最后一位<code>1</code>的数，答案即为<code>lowbit(x)</code>的结果。</li><li>用补码来运算。</li></ol><p>实现的代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 方法1</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lowbit</span><span class="params">(x)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x - (x &amp; (x - <span class="number">1</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 方法2</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lowbit</span><span class="params">(x)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x &amp; -x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="树状数组的思想"><a class="markdownIt-Anchor" href="#树状数组的思想"></a> 树状数组的思想</h1><p>一些定义：<code>arr</code>是原数组，<code>c</code>是新开的一个数组，这个数组代表后缀和;</p><p>二进制的视角：一个数<code>n</code>，假设<code>n = 6</code>，它的二进制为<code>110</code>，我们把它表示成累加的形式<code>110 = 100 + 10</code>，前<code>6(110)</code>项的和可以这样求：</p><p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msubsup><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mn>6</mn></msubsup><mo>=</mo><mo stretchy="false">(</mo><mi>a</mi><mi>r</mi><msub><mi>r</mi><mn>1</mn></msub><mo>+</mo><mi>a</mi><mi>r</mi><msub><mi>r</mi><mn>2</mn></msub><mo>+</mo><mi>a</mi><mi>r</mi><msub><mi>r</mi><mn>3</mn></msub><mo>+</mo><mi>a</mi><mi>r</mi><msub><mi>r</mi><mn>4</mn></msub><mo stretchy="false">)</mo><mo>+</mo><mo stretchy="false">(</mo><mi>a</mi><mi>r</mi><msub><mi>r</mi><mn>5</mn></msub><mo>+</mo><mi>a</mi><mi>r</mi><msub><mi>r</mi><mn>6</mn></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\sum_{i=1}^6=(arr_1+arr_2+arr_3+arr_4)+(arr_5+arr_6)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.253718em;vertical-align:-0.29971000000000003em;"></span><span class="mop"><span class="mop op-symbol small-op" style="position:relative;top:-0.0000050000000000050004em;">∑</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.954008em;"><span style="top:-2.40029em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.2029em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">6</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.29971000000000003em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal">a</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.73333em;vertical-align:-0.15em;"></span><span class="mord mathnormal">a</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.73333em;vertical-align:-0.15em;"></span><span class="mord mathnormal">a</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">a</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">4</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal">a</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">5</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">a</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">6</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></p><p>括号中的元素个数，是不是<code>4(100)</code>个加<code>2(10)</code>个，和<code>110 = 100 + 10</code>很像</p><p>同时，<code>10</code>就是<code>lowbit(110)</code>的结果，<code>100</code>是<code>lowbit(100)</code>的结果。求和的时候我们总是把<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msubsup><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>n</mi></msubsup></mrow><annotation encoding="application/x-tex">\sum_{i=1}^n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.104002em;vertical-align:-0.29971000000000003em;"></span><span class="mop"><span class="mop op-symbol small-op" style="position:relative;top:-0.0000050000000000050004em;">∑</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.804292em;"><span style="top:-2.40029em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.2029em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.29971000000000003em;"><span></span></span></span></span></span></span></span></span></span>拆分成这样的几段区间和来计算，而如何去确定这些区间的起点和长度呢？就是根据n的二进制来的，二进制怎么拆的，就怎么拆分，而拆分二进制就要用到上面说的<code>lowbit</code>函数了。这里也可以顺理成章得给出c数组的表示了。</p><p>例如：</p><p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msubsup><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mn>6</mn></msubsup><mo>=</mo><mo stretchy="false">(</mo><mi>a</mi><mi>r</mi><msub><mi>r</mi><mn>1</mn></msub><mo>+</mo><mi>a</mi><mi>r</mi><msub><mi>r</mi><mn>2</mn></msub><mo>+</mo><mi>a</mi><mi>r</mi><msub><mi>r</mi><mn>3</mn></msub><mo>+</mo><mi>a</mi><mi>r</mi><msub><mi>r</mi><mn>4</mn></msub><mo stretchy="false">)</mo><mo>+</mo><mo stretchy="false">(</mo><mi>a</mi><mi>r</mi><msub><mi>r</mi><mn>5</mn></msub><mo>+</mo><mi>a</mi><mi>r</mi><msub><mi>r</mi><mn>6</mn></msub><mo stretchy="false">)</mo><mo>=</mo><mo stretchy="false">(</mo><mi>a</mi><mi>r</mi><msub><mi>r</mi><mn>1</mn></msub><mo>+</mo><mi>a</mi><mi>r</mi><msub><mi>r</mi><mn>2</mn></msub><mo>+</mo><mi>a</mi><mi>r</mi><msub><mi>r</mi><mn>3</mn></msub><mo>+</mo><mi>a</mi><mi>r</mi><msub><mi>r</mi><mn>4</mn></msub><mo stretchy="false">)</mo><mo>+</mo><mi>c</mi><mo stretchy="false">[</mo><mn>6</mn><mo stretchy="false">]</mo><mspace linebreak="newline"></mspace><mo>=</mo><msubsup><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mn>4</mn></msubsup><mo>+</mo><mi>c</mi><mo stretchy="false">[</mo><mn>6</mn><mo stretchy="false">]</mo><mo>=</mo><mi>c</mi><mo stretchy="false">[</mo><mn>6</mn><mo>−</mo><mi>l</mi><mi>o</mi><mi>w</mi><mi>b</mi><mi>i</mi><mi>t</mi><mo stretchy="false">(</mo><mn>6</mn><mo stretchy="false">)</mo><mo stretchy="false">]</mo><mo>+</mo><mi>c</mi><mo stretchy="false">[</mo><mn>6</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">\sum_{i=1}^6=(arr_1+arr_2+arr_3+arr_4)+(arr_5+arr_6)=(arr_1+arr_2+arr_3+arr_4)+c[6]\\=\sum_{i=1}^4+c[6]=c[6-lowbit(6)]+c[6]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.253718em;vertical-align:-0.29971000000000003em;"></span><span class="mop"><span class="mop op-symbol small-op" style="position:relative;top:-0.0000050000000000050004em;">∑</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.954008em;"><span style="top:-2.40029em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.2029em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">6</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.29971000000000003em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal">a</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.73333em;vertical-align:-0.15em;"></span><span class="mord mathnormal">a</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.73333em;vertical-align:-0.15em;"></span><span class="mord mathnormal">a</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">a</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">4</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal">a</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">5</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">a</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">6</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal">a</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.73333em;vertical-align:-0.15em;"></span><span class="mord mathnormal">a</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.73333em;vertical-align:-0.15em;"></span><span class="mord mathnormal">a</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">a</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">4</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">c</span><span class="mopen">[</span><span class="mord">6</span><span class="mclose">]</span></span><span class="mspace newline"></span><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.253718em;vertical-align:-0.29971000000000003em;"></span><span class="mop"><span class="mop op-symbol small-op" style="position:relative;top:-0.0000050000000000050004em;">∑</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.954008em;"><span style="top:-2.40029em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.2029em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">4</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.29971000000000003em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">+</span><span class="mord mathnormal">c</span><span class="mopen">[</span><span class="mord">6</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">c</span><span class="mopen">[</span><span class="mord">6</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="mord mathnormal">b</span><span class="mord mathnormal">i</span><span class="mord mathnormal">t</span><span class="mopen">(</span><span class="mord">6</span><span class="mclose">)</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">c</span><span class="mopen">[</span><span class="mord">6</span><span class="mclose">]</span></span></span></span></p><h1 id="树状数组的实现"><a class="markdownIt-Anchor" href="#树状数组的实现"></a> 树状数组的实现</h1><h2 id="查询"><a class="markdownIt-Anchor" href="#查询"></a> 查询</h2><p>这里说的查询是查询任一区间的和，由于区间和具有可加减性，故转化为求前缀和；</p><p>查询前缀和刚刚在树状数组的思想中已经说过了，就是把大区间分成几段长度不等的小区间，然后求和。区间的个数为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(logn)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>，所以查询的时间复杂度为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(logn)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></p><h2 id="修改"><a class="markdownIt-Anchor" href="#修改"></a> 修改</h2><p><img src="/image/binary_tree/1.png" alt="1" /></p><p>可以得到树状数组的性值：</p><ol><li>后缀和的长度是2的幂；</li><li>上一层后缀和的长度是下一层后缀和长度的两倍；</li><li>一层后缀和只要补上自己后缀和的长度就可以得到上面层的后缀和(图中的虚框框)，注意，是上面的后缀和，而不是上一层的后缀和，这个性质就是更新操作的依据；</li><li>最后一位1右边有多少个0(可以用<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>l</mi><mi>o</mi><msub><mi>g</mi><mn>2</mn></msub><mo stretchy="false">(</mo><mi>l</mi><mi>o</mi><mi>w</mi><mi>b</mi><mi>i</mi><mi>t</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">log_2(lowbit(x))</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">o</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="mord mathnormal">b</span><span class="mord mathnormal">i</span><span class="mord mathnormal">t</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mclose">)</span><span class="mclose">)</span></span></span></span>表示)就表示这一层有多少个直系子层(子层的意思就是这一层的和包含下面某一层的和)。</li></ol><p>更新操作：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这里的val应该是修改值的变化量</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> val, <span class="keyword">int</span> *c, <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> ( ; x &lt;= n; c[x] += val, x += <span class="built_in">lowbit</span>(x));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="leetcode775-全局倒置与局部倒置"><a class="markdownIt-Anchor" href="#leetcode775-全局倒置与局部倒置"></a> Leetcode.775 全局倒置与局部倒置</h1><p><a href="https://leetcode.cn/problems/global-and-local-inversions/">775. 全局倒置与局部倒置 - 力扣（LeetCode）</a></p><p>根据题意，对于每个<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mi>u</mi><mi>m</mi><mi>s</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">nums[i]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">n</span><span class="mord mathnormal">u</span><span class="mord mathnormal">m</span><span class="mord mathnormal">s</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">]</span></span></span></span>而言：</p><ul><li><p>其左边比它大的<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mi>u</mi><mi>m</mi><mi>s</mi><mo stretchy="false">[</mo><mi>j</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">nums[j]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">n</span><span class="mord mathnormal">u</span><span class="mord mathnormal">m</span><span class="mord mathnormal">s</span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mclose">]</span></span></span></span>的个数，是以<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mi>u</mi><mi>m</mi><mi>s</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">nums[i]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">n</span><span class="mord mathnormal">u</span><span class="mord mathnormal">m</span><span class="mord mathnormal">s</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">]</span></span></span></span>为右端点的“全局倒置”数量，统计所有以<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mi>u</mi><mi>m</mi><mi>s</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">nums[i]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">n</span><span class="mord mathnormal">u</span><span class="mord mathnormal">m</span><span class="mord mathnormal">s</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">]</span></span></span></span>为右端点的“全局倒置”数量即是总的“全局倒置”数量<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi></mrow><annotation encoding="application/x-tex">a</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">a</span></span></span></span></p></li><li><p>同时我们可以将每个<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mi>u</mi><mi>m</mi><mi>s</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">nums[i]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">n</span><span class="mord mathnormal">u</span><span class="mord mathnormal">m</span><span class="mord mathnormal">s</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">]</span></span></span></span>与前一个值进行比较，从而统计总的“局部倒置”数量<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>b</mi></mrow><annotation encoding="application/x-tex">b</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal">b</span></span></span></span>，其中 ii 的取值范围为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mn>1</mn><mo separator="true">,</mo><mi>n</mi><mtext>−</mtext><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">[1,n−1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">n</span><span class="mord">−</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></p></li></ul><p>一个容易想到的做法是利用「树状数组」，虽然该做法没有利用到核心条件「<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mi>u</mi><mi>m</mi><mi>s</mi></mrow><annotation encoding="application/x-tex">nums</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">n</span><span class="mord mathnormal">u</span><span class="mord mathnormal">m</span><span class="mord mathnormal">s</span></span></span></span>是一个<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mn>0</mn><mo separator="true">,</mo><mi>n</mi><mtext>−</mtext><mn>1</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[0,n−1]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">n</span><span class="mord">−</span><span class="mord">1</span><span class="mclose">]</span></span></span></span>的排列」，但根据数据范围n可知该复杂度为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(nlogn)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>的做法可过，且依赖的条件更少，适用范围更广。</p><p>! 没太看明白，后期更</p>]]></content>
    
    
    <summary type="html">又称二叉索引树，使得查询区间和与修改的时间复杂度将为O(logn)</summary>
    
    
    
    <category term="Algorithm" scheme="http://aflyingsheep.github.io/categories/Algorithm/"/>
    
    
    <category term="Algorithm" scheme="http://aflyingsheep.github.io/tags/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>SWSPH - 论文阅读笔记</title>
    <link href="http://aflyingsheep.github.io/2022/11/15/science_research/swsph/"/>
    <id>http://aflyingsheep.github.io/2022/11/15/science_research/swsph/</id>
    <published>2022-11-15T14:28:06.000Z</published>
    <updated>2022-12-02T13:16:42.730Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="优化方法"><a class="markdownIt-Anchor" href="#优化方法"></a> 优化方法</h2><ol><li><p>域分解策略：</p><ol><li><p>基于单元列表的成对交互：引入模拟域中分配均匀的空间网格，将整个粒子系统根据位空间坐标将粒子放置到cell中。</p><p>进行粒子对交互时，每个中心单元根据自身和相邻的cell执行计算。第一层循环迭代当前cell，第二层迭代周围cell。</p><p>确定粒子与周围cell的最小距离是否大于其支持域(剪枝)</p><p>充分保持了数据的局部性，提高搜索成功率，减少分支数，有利于矢量化。</p><img src="C:\Users\赵阳\AppData\Roaming\Typora\typora-user-images\image-20221114160055315.png" alt="image-20221114160055315" style="zoom:80%;" /></li></ol></li><li><p>负载平衡——自适应粒子分割 &amp; 体积自适应方案</p><ol><li><p>自适应粒子分割</p><ul><li>传统SPH：为每个core分配统一数量的粒子，效率不高</li><li>改进SPH：使用每个单元粒子最大支持域半径估算计算量，收敛区域使用树状自适应网格细化，直到计算量降至平均值以下，算法如下图：</li><li>将单元半径设置为略大于支持域半径，减少无效搜索</li></ul><img src="C:\Users\赵阳\AppData\Roaming\Typora\typora-user-images\image-20221114192107755.png" alt="image-20221114192107755" style="zoom:80%;" /></li><li><p>体积自适应方案</p><ol><li><p>冲击模拟带来的问题：</p><ul><li><p>粒子压缩：局部负荷增加</p></li><li><p>过度膨胀粒子：更大的支撑域收集足够粒子用于SPH插值，需要更大区域长度并增加没有膨胀波区域的计算负荷</p></li></ul></li><li><p>体积自适应方案解决：</p><ul><li>粒子体积大于预设上限，母粒子拆分为8个子粒子(物理量继承母粒子物理数量)</li><li>粒子体积小于预设下限，中心距离小于预设最大长度的一对粒子：合并为一个母粒子，物理量通过子粒子加权和计算</li></ul></li></ol></li></ol></li><li><p>通信优化策略</p><p>将存储在每个节点的cell分为三种类型：<strong>core cell, edge cell and ghost cell</strong></p><ol><li><p>点对点通信模式：</p><p>SPH中存在两种通信：粒子迁移(发送粒子到目标进程)、halo-exchange，采用非阻塞式点对点通信方法</p><ul><li><p>核心单元粒子计算与原子迁移、halo-exchange的堆叠</p><img src="C:\Users\赵阳\AppData\Roaming\Typora\typora-user-images\image-20221114215342162.png" alt="image-20221114215342162" style="zoom:80%;" /></li></ul></li><li><p>ghost单元冗余删除</p><ul><li>大多数框架，halo-exchange直接pack并发送，但包含大量冗余数据。</li><li>优化：细化子单元，分析支持域有效半径，提前消除ghost单元中冗余粒子数据</li></ul></li></ol></li><li><p>390-cores CPU细粒度任务映射策略</p><ol><li><p>全共享模式：Sunway提供全共享模式：使用1个MPI进程+6个OpenMP线程能够控制6个CG，6*64个slave cores可以共享92GB内存</p></li><li><p>计算核心分组方案：</p><ul><li><p>根据牛顿第三定律(作用力与反作用力，计算量减半)：1. 找到比当前索引小的相邻cells并构建数据副本(之前已经计算过作用力，直接赋值即可); 2. 遍历比自己索引大的相邻cells，完成作用计算</p></li><li><p>原分组方案：粗粒度并行(将整个i cell list分配给slave core，写入时j cell core的粒子数据也会被更新(牛顿第三定律))与细粒度并行(把每个cell list分配给64个slave core，但由于没有足够任务支持64个core parallel，将近一半的core处于忙等状态)</p></li><li><p>现改进方案：将64个CPE按行划分为16个计算组(一组4个CPE)，每个计算组负责一个cell list，每个CPE负责计算一对cell</p><img src="C:\Users\赵阳\AppData\Roaming\Typora\typora-user-images\image-20221114231825086.png" alt="image-20221114231825086" style="zoom:80%;" /><ul><li>组中没有写入冲突，但组间写入冲突依旧存在——在列0的CPE的LDM中设置一个数据副本，当一个组所有成员完成cell list计算后，每个CPE将数据归约为第0列CPE的副本，并使用DMA更新内存数据</li><li>数据归约：树约简方法更适合从核阵列的互联结构</li></ul></li></ul></li><li><p>数据布局优化与矢量化</p><img src="C:\Users\赵阳\AppData\Roaming\Typora\typora-user-images\image-20221114232342268.png" alt="image-20221114232342268" style="zoom:80%;" /><ol><li>排序(根据相对位置，由CPE并行实现)</li><li>AoS-&gt;AoSoA</li><li>可以使用simd加载指令从LDM读取8个连续的双数据并将它们放入向量寄存器中</li></ol></li></ol></li></ol>]]></content>
    
    
    <summary type="html">SWSPH-A Massively Parallel SPH Implementation for Hundred-Billion-Particle Simulation on New Sunway Supercomputer</summary>
    
    
    
    <category term="HPC" scheme="http://aflyingsheep.github.io/categories/HPC/"/>
    
    
    <category term="Paper Reading" scheme="http://aflyingsheep.github.io/tags/Paper-Reading/"/>
    
  </entry>
  
  <entry>
    <title>C++11:原子操作与memory_order</title>
    <link href="http://aflyingsheep.github.io/2022/10/31/linux/aotomic_and_memory_order/"/>
    <id>http://aflyingsheep.github.io/2022/10/31/linux/aotomic_and_memory_order/</id>
    <published>2022-10-31T11:27:06.000Z</published>
    <updated>2023-02-11T13:22:54.559Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="原子操作"><a class="markdownIt-Anchor" href="#原子操作"></a> 原子操作</h1><h2 id="概念"><a class="markdownIt-Anchor" href="#概念"></a> 概念</h2><p>原子操作是多线程程序中&quot;<strong>最小且不可并行化</strong>&quot;的操作。通常对一个共享资源的操作是原子操作的话，意味着多个线程访问该资源时，有且仅有唯一一个线程在对这个资源进行操作。</p><p>通常情况下，原子操作通过&quot;互斥&quot;（mutual exclusive）的访问来保证。实现互斥通常需要平台相关的特殊指令，在c++11标准之前，这常常意味着需要在c/c++代码中嵌入内联汇编代码。</p><h2 id="问题"><a class="markdownIt-Anchor" href="#问题"></a> 问题</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">static</span> <span class="keyword">long</span> <span class="keyword">long</span> total=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">pthread_mutex_t</span> m=PTHREAD_MUTEX_INITIALIZER;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">func</span><span class="params">(<span class="keyword">void</span>*)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">     <span class="keyword">long</span> <span class="keyword">long</span> i;</span><br><span class="line">     <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">100000000</span>;i++)</span><br><span class="line">     &#123;</span><br><span class="line">         <span class="built_in">pthread_mutex_lock</span>(&amp;m);</span><br><span class="line">         total+=i;</span><br><span class="line">         <span class="built_in">pthread_mutex_unlock</span>(&amp;m);</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">     <span class="keyword">pthread_t</span> thread1,thread2;</span><br><span class="line">     <span class="keyword">if</span>(<span class="built_in">pthread_create</span>(&amp;thread1,<span class="literal">NULL</span>,&amp;func,<span class="literal">NULL</span>))</span><br><span class="line">     &#123;</span><br><span class="line">        <span class="keyword">throw</span>;</span><br><span class="line">     &#125;</span><br><span class="line"> </span><br><span class="line">     <span class="keyword">if</span>(<span class="built_in">pthread_create</span>(&amp;thread2,<span class="literal">NULL</span>,&amp;func,<span class="literal">NULL</span>))</span><br><span class="line">     &#123;</span><br><span class="line">        <span class="keyword">throw</span>;</span><br><span class="line">     &#125;</span><br><span class="line"> </span><br><span class="line">     <span class="built_in">pthread_join</span>(thread1,<span class="literal">NULL</span>);</span><br><span class="line">     <span class="built_in">pthread_join</span>(thread2,<span class="literal">NULL</span>);</span><br><span class="line">     cout&lt;&lt;total&lt;&lt;endl;<span class="comment">//9999999900000000</span></span><br><span class="line">     <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码中为了防止数据竞争，我们使用了pthread_mutex_t的互斥锁保证两个线程可以正确的访问total。</p><ul><li>加锁和解锁会消耗系统资源</li><li>代码移植性较差，像我们实际开发过程中，一套代码中兼容windows和linux等的地方比比皆是，这其实是程序员做了&quot;妥协&quot;。</li></ul><h2 id="c11的改进"><a class="markdownIt-Anchor" href="#c11的改进"></a> C++11的改进</h2><p>c++11对数据进行了更加良好的抽象，引入“原子数据类型”（atomic）,以达到对开发者掩盖互斥锁、临界区的目的。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;atomic&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">std::<span class="keyword">atomic_llong</span> total&#123; <span class="number">0</span> &#125;;<span class="comment">//原子数据类型</span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">long</span> <span class="keyword">long</span> i = <span class="number">0</span>; i&lt;<span class="number">100000000</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        total += i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">thread <span class="title">t1</span><span class="params">(func, <span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="function">thread <span class="title">t2</span><span class="params">(func, <span class="number">0</span>)</span></span>;</span><br><span class="line">    t1.<span class="built_in">join</span>();</span><br><span class="line">    t2.<span class="built_in">join</span>();</span><br><span class="line">    cout&lt;&lt;total&lt;&lt;endl;<span class="comment">//9999999900000000</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将total定义为原子类型std::atomic_llong，使得程序不需要显示的调用API来加锁、解锁，对于代码来说，即容易又简洁。</p><h1 id="atomic"><a class="markdownIt-Anchor" href="#atomic"></a> atomic</h1><p><code>template &lt;class T&gt; struct atomic;</code></p><p>参考手册：<a href="http://cplusplus.com/reference/atomic/atomic/?kw=atomic">http://cplusplus.com/reference/atomic/atomic/?kw=atomic</a></p><h1 id="内存模型与memory_order"><a class="markdownIt-Anchor" href="#内存模型与memory_order"></a> 内存模型与memory_order</h1><h2 id="强顺序与弱顺序"><a class="markdownIt-Anchor" href="#强顺序与弱顺序"></a> 强顺序与弱顺序</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;atomic&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"> </span><br><span class="line">atomic&lt;<span class="keyword">int</span>&gt; m&#123;<span class="number">0</span>&#125;;</span><br><span class="line">atomic&lt;<span class="keyword">int</span>&gt; n&#123;<span class="number">0</span>&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> tmp = <span class="number">1</span>;</span><br><span class="line">    m = tmp;</span><br><span class="line">    n = <span class="number">3</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>汇编代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">loadi reg3, <span class="number">1</span>;    #将<span class="number">1</span>放入寄存器reg3</span><br><span class="line">move reg4, reg3;  #将reg3的数据放入reg4 </span><br><span class="line">store reg4, m;    #将寄存器reg4中的数据存入内存地址m</span><br><span class="line">loadi reg5, <span class="number">2</span>;    #将立即数<span class="number">2</span>放入寄存器reg5</span><br><span class="line">store reg5, n;    #将寄存器<span class="number">5</span>中的数据存入内存地址n</span><br></pre></td></tr></table></figure><p>强顺序：指令执行顺序为1-&gt;2-&gt;3-&gt;4-&gt;5</p><p>弱顺序：执行可能的执行顺序为1-&gt;4-&gt;2-&gt;5-&gt;3（指的是执行顺序存在一定的不确定性）</p><h2 id="优势与劣势"><a class="markdownIt-Anchor" href="#优势与劣势"></a> 优势与劣势</h2><p>优势：提高指令执行性能</p><p>劣势：多线程下，可能会造成程序运行错误；</p><p>例：单例模式中经典的double check双检查锁的实现方式</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Singleton* <span class="title">Singleton::getInstance</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (m_instance == <span class="literal">nullptr</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        std::mutex mtx;           <span class="comment">//函数结束时锁资源释放</span></span><br><span class="line">        m_instance = <span class="built_in"><span class="keyword">new</span></span>(std::nothrow) <span class="built_in">Singleton</span>();</span><br><span class="line">        <span class="keyword">if</span> (m_instance == <span class="literal">nullptr</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> m_instance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>默认构造顺序：分配内存、调用构造器、返回指针至instance</p><p>reorder后可能为：分配内存、指针返回值给instance、调用构造器</p><p><strong>导致问题：当一个线程执行到第二步时，假如此时有另外一个线程访问，会默认m_instance不为空返回，此时实际还未调用构造器，进而导致不可预知的问题。</strong></p><h2 id="memory_order"><a class="markdownIt-Anchor" href="#memory_order"></a> memory_order</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">enum</span> <span class="title">memory_order</span> &#123;</span></span><br><span class="line">memory_order_relaxed,</span><br><span class="line">memory_order_consume,</span><br><span class="line">memory_order_acquire,</span><br><span class="line">memory_order_release,</span><br><span class="line">memory_order_acq_rel,</span><br><span class="line">memory_order_seq_cst</span><br><span class="line">&#125; memory_order;</span><br></pre></td></tr></table></figure><p><img src="/image/aotomic/1.png" alt="1" /></p><p>对于单例构造的修改：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">std::atomic&lt;Singleton*&gt; Singleton::m_instance;   <span class="comment">//原子对象</span></span><br><span class="line">std::mutex Singleton::m_mutex;</span><br><span class="line"> </span><br><span class="line"><span class="function">Singleton* <span class="title">Singleton::getInstance</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Singleton* s = m_instance.<span class="built_in">load</span>(std::memory_order_relaxed);  <span class="comment">//屏蔽编译器的reorder</span></span><br><span class="line">    std::_Atomic_thread_fence(std::memory_order_acquire);       <span class="comment">//本线程中，所有后续的读操作必须在本条原子操作完成后执行</span></span><br><span class="line">    <span class="keyword">if</span> (s == <span class="literal">nullptr</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(m_mutex)</span></span>;</span><br><span class="line">        s = m_instance.<span class="built_in">load</span>(std::memory_order_relaxed);  <span class="comment">//取变量</span></span><br><span class="line">        <span class="keyword">if</span> (s == <span class="literal">nullptr</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            s = <span class="keyword">new</span> Singleton;   <span class="comment">//保证不出现reorder</span></span><br><span class="line">            std::_Atomic_thread_fence(std::memory_order_release);  <span class="comment">//释放内存fence</span></span><br><span class="line">            m_instance.<span class="built_in">store</span>(s, std::memory_order_relaxed);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><em>memory_order</em>参数的默认值是std::memory_order_seq_cst。<strong>实际上，atomic类型的其他原子操作接口都有memory_order这个参数，而且默认值都是std::memory_order_seq_cst。</strong></p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="C++" scheme="http://aflyingsheep.github.io/categories/C/"/>
    
    <category term="HPC" scheme="http://aflyingsheep.github.io/categories/HPC/"/>
    
    
    <category term="HPC" scheme="http://aflyingsheep.github.io/tags/HPC/"/>
    
  </entry>
  
  <entry>
    <title>Compare And Swap(CAS)原理分析</title>
    <link href="http://aflyingsheep.github.io/2022/10/31/linux/CAS/"/>
    <id>http://aflyingsheep.github.io/2022/10/31/linux/CAS/</id>
    <published>2022-10-31T11:04:06.000Z</published>
    <updated>2023-02-11T13:24:51.030Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="cas概论"><a class="markdownIt-Anchor" href="#cas概论"></a> CAS概论</h1><h2 id="cas定义"><a class="markdownIt-Anchor" href="#cas定义"></a> CAS定义</h2><p><strong>Compare and swap，解决多线程并行情况下使用锁造成性能损耗的一种机制</strong>，CAS操作包含三个操作数——<strong>内存位置</strong>（V）、<strong>预期原值</strong>（A）和<strong>新值</strong>(B)。如果<strong>内存位置的值与预期原值相匹配，那么处理器会自动将该位置值更新为新值。否则，处理器不做任何操作</strong>。无论哪种情况，它都会在CAS指令之前返回该位置的值。CAS有效地说明了“我认为位置V应该包含值A；如果包含该值，则将B放到这个位置；否则，不要更改该位置，只告诉我这个位置现在的值即可。&quot;</p><p>CAS操作是一条CPU的原子指令，所以不会有线程安全问题。</p><p><img src="/image/CAS/1.png" alt="1" /></p><h2 id="加锁和cas解决原子性问题的不同原理"><a class="markdownIt-Anchor" href="#加锁和cas解决原子性问题的不同原理"></a> 加锁和CAS解决原子性问题的不同原理</h2><p>考虑如下代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//共享资源</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">increase</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    i++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    Runnable r = () -&gt; &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">1000</span>; j++) &#123;</span><br><span class="line">            increase();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    List&lt;Thread&gt; threads = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">10</span>; j++) &#123;</span><br><span class="line">        Thread thread = <span class="keyword">new</span> Thread(r);</span><br><span class="line">        threads.add(thread);</span><br><span class="line">        thread.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//确保前面10个线程都走完</span></span><br><span class="line">    <span class="keyword">for</span> (Thread thread : threads) &#123;</span><br><span class="line">        thread.join();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    System.out.println(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于i++，并不是原子性操作，导致10个线程执行后i的值并不是10*1000.</p><p>加锁解决的方式：</p><p><img src="/image/CAS/2.png" alt="2" /></p><p>CAS解决方式：</p><p><img src="/image/CAS/3.png" alt="3" /></p><h1 id="c中的cas操作"><a class="markdownIt-Anchor" href="#c中的cas操作"></a> C++中的CAS操作</h1><p>C++ 中的 CAS 操作用于操作原子变量，它是 <code>atomic&lt;T&gt; </code>的成员函数。</p><p><strong>在进行判等操作时，它执行的是物理上的比较，即直接比较内存值，而不是使用 <code>T</code> 的 <code>==</code> 操作符进行比较。此外，它允许虚假失败，也就是当前原子变量的内容与 <code>expected</code> 相等，但是它仍然返回 <code>false</code> ，但它不会修改 <code>expected</code> 。它需要放在循环中使用。</strong></p><p><a href="https://blog.csdn.net/www_dong/article/details/119920236">c++ CAS API接口(click me!)</a></p><h2 id="示例"><a class="markdownIt-Anchor" href="#示例"></a> 示例</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;atomic&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    T data;</span><br><span class="line">    node* next;</span><br><span class="line">    <span class="built_in">node</span>(<span class="keyword">const</span> T&amp; data) : <span class="built_in">data</span>(data), <span class="built_in">next</span>(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">stack</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    std::atomic&lt;node&lt;T&gt;*&gt; head;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">const</span> T&amp; data)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        node&lt;T&gt;* new_node = <span class="keyword">new</span> node&lt;T&gt;(data);</span><br><span class="line"> </span><br><span class="line">        new_node-&gt;next = head.<span class="built_in">load</span>(std::memory_order_relaxed);</span><br><span class="line"> </span><br><span class="line">        <span class="comment">//std::memory_order_release: 本线程中，所有之前的写操作完成后才能执行本条原子操作</span></span><br><span class="line">        <span class="comment">//memory_order_relaxed: 不对执行的顺序作任何保证</span></span><br><span class="line">        <span class="keyword">while</span>(!std::<span class="built_in">atomic_compare_exchange_weak_explicit</span>(</span><br><span class="line">                                &amp;head,</span><br><span class="line">                                &amp;new_node-&gt;next,</span><br><span class="line">                                new_node,</span><br><span class="line">                                std::memory_order_release,     </span><br><span class="line">                                std::memory_order_relaxed))</span><br><span class="line">                ; </span><br><span class="line">   &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    stack&lt;<span class="keyword">int</span>&gt; s;</span><br><span class="line">    s.<span class="built_in">push</span>(<span class="number">1</span>);</span><br><span class="line">    s.<span class="built_in">push</span>(<span class="number">2</span>);</span><br><span class="line">    s.<span class="built_in">push</span>(<span class="number">3</span>);</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">compare and swap，解决多线程并行情况下使用锁造成性能损耗的一种机制</summary>
    
    
    
    <category term="CS" scheme="http://aflyingsheep.github.io/categories/CS/"/>
    
    <category term="HPC" scheme="http://aflyingsheep.github.io/categories/HPC/"/>
    
    
    <category term="HPC" scheme="http://aflyingsheep.github.io/tags/HPC/"/>
    
  </entry>
  
  <entry>
    <title>自旋锁</title>
    <link href="http://aflyingsheep.github.io/2022/10/31/linux/spinlock/"/>
    <id>http://aflyingsheep.github.io/2022/10/31/linux/spinlock/</id>
    <published>2022-10-31T10:43:06.000Z</published>
    <updated>2023-02-11T13:25:13.115Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="前言"><a class="markdownIt-Anchor" href="#前言"></a> 前言</h1><p>在有些场景中，同步资源的锁定时间很短，为了这一小段时间去切换线程，线程挂起和恢复现场的花费可能会让系统得不偿失。</p><p>如果机器有多个CPU核心，能够让两个或以上的线程同时并行执行，我们就可以让后面那个请求锁的线程不放弃CPU的执行时间，看看持有锁的线程是否很快就会释放锁。</p><p>为了让当前线程“稍等一下”，我们需让当前线程进行自旋，如果在自旋完成后前面锁定同步资源的线程已经释放了锁，那么当前线程就可以不必阻塞而是直接获取同步资源，从而避免切换线程的开销。这就是自旋锁。</p><img src="/image/spinlock/1.png" alt="1" style="zoom:50%;" /><h1 id="缺点"><a class="markdownIt-Anchor" href="#缺点"></a> 缺点</h1><p>不能代替阻塞。自旋等待虽然避免了线程切换的开销，但它要占用处理器时间。</p><ul><li>如果锁被占用的时间很短，自旋等待的效果就会非常好；</li><li>如果锁被占用的时间很长，那么自旋的线程只会白浪费处理器资源。</li></ul><p>自旋等待的时间必须要有一定的限度，如果自旋超过了限定次数没有成功获得锁，就应当挂起线程。（这个次数默认是10次，可以配置）</p>]]></content>
    
    
    <summary type="html">同步资源，切换线程，让两个或以上的线程同时并行执行，后面请求锁的线程不放弃CPU的执行时间，看看持有锁的线程是否很快就会释放锁。</summary>
    
    
    
    <category term="CS" scheme="http://aflyingsheep.github.io/categories/CS/"/>
    
    <category term="HPC" scheme="http://aflyingsheep.github.io/categories/HPC/"/>
    
    
    <category term="HPC" scheme="http://aflyingsheep.github.io/tags/HPC/"/>
    
  </entry>
  
  <entry>
    <title>软中断、tasklet和工作队列详解</title>
    <link href="http://aflyingsheep.github.io/2022/10/31/linux/tasklet/"/>
    <id>http://aflyingsheep.github.io/2022/10/31/linux/tasklet/</id>
    <published>2022-10-31T08:19:06.000Z</published>
    <updated>2023-02-11T13:25:33.830Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="引言"><a class="markdownIt-Anchor" href="#引言"></a> 引言</h1><p>软中断、tasklet和工作队列并不是Linux内核中一直存在的机制，而是由更早版本的内核中的“下半部”（bottom half）演变而来。</p><p>上半部指的是中断处理程序，下半部则指的是一些虽然与中断有相关性但是可以延后执行的任务。举个例子：在网络传输中，网卡接收到数据包这个事件不一定需要马上被处理，适合用下半部去实现；但是用户敲击键盘这样的事件就必须马上被响应，应该用中断实现。<br />两者的主要区别在于：中断不能被相同类型的中断打断，而下半部依然可以被中断打断；中断对于时间非常敏感，而下半部基本上都是一些可以延迟的工作。由于二者的这种区别，所以对于一个工作是放在上半部还是放在下半部去执行，可以参考下面4条：</p><ol><li>如果一个任务对时间非常敏感，将其放在中断处理程序中执行。</li><li>如果一个任务和硬件相关，将其放在中断处理程序中执行。</li><li>如果一个任务要保证不被其他中断（特别是相同的中断）打断，将其放在中断处理程序中执行。</li><li>其他所有任务，考虑放在下半部去执行。</li></ol><p>有写内核任务需要延后执行，因此才有的下半部，进而实现了三种实现下半部的方法。这就是本文要讨论的<strong>软中断</strong>、<strong>Tasklet</strong>和<strong>工作队列</strong>。</p><p><img src="/image/tasklet/1.png" alt="1" /></p><h1 id="软中断"><a class="markdownIt-Anchor" href="#软中断"></a> 软中断</h1><p>软中断作为下半部机制的代表，是随着SMP（share memory processor）的出现应运而生的，它也是tasklet实现的基础（tasklet实际上只是在软中断的基础上添加了一定的机制）。软中断一般是“可延迟函数”的总称，有时候也包括了tasklet（请读者在遇到的时候根据上下文推断是否包含tasklet）。它的出现就是因为要满足上面所提出的上半部和下半部的区别，使得对时间不敏感的任务延后执行，而且可以在多个CPU上并行执行，使得总的系统效率可以更高。它的特性包括：</p><ul><li>产生后并不是马上可以执行，必须要等待内核的调度才能执行。软中断不能被自己打断(即单个cpu上软中断不能嵌套执行)，只能被硬件中断打断（上半部）。</li><li>可以并发运行在多个CPU上（即使同一类型的也可以）。所以软中断必须设计为可重入的函数（一个函数在被调用执行期间（尚未调用结束），由于某种时序又被重复调用，称之为重入; 允许多个CPU同时操作），因此也需要使用自旋锁来保其数据结构。</li></ul><h1 id="tasklet"><a class="markdownIt-Anchor" href="#tasklet"></a> tasklet</h1><p>由于软中断必须使用可重入函数，这就导致设计上的复杂度变高，作为设备驱动程序的开发者来说，增加了负担。而如果某种应用并不需要在多个CPU上并行执行，那么软中断其实是没有必要的。因此诞生了弥补以上两个要求的tasklet。它具有以下特性：</p><ul><li>一种特定类型的tasklet只能运行在一个CPU上，不能并行，只能串行执行。</li><li>多个不同类型的tasklet可以并行在多个CPU上。</li><li>软中断是静态分配的，在内核编译好之后，就不能改变。但tasklet就灵活许多，可以在运行时改变（比如添加模块时）。</li></ul><p>tasklet是在两种软中断类型的基础上实现的，因此如果不需要软中断的并行特性，tasklet就是最好的选择。也就是说tasklet是软中断的一种特殊用法，即延迟情况下的串行执行。</p><h1 id="工作队列"><a class="markdownIt-Anchor" href="#工作队列"></a> 工作队列</h1><p>从上面的介绍看以看出，软中断运行在中断上下文中，因此不能阻塞和睡眠，而tasklet使用软中断实现，当然也不能阻塞和睡眠。但如果某延迟处理函数需要睡眠或者阻塞呢？便使用工作队列来实现。</p><p>内核定义了一组队列，其中每个队列都包含一个由等待调用的函数组成的链表。根据其所处队列的位置，这些函数会在某个时刻执行。驱动程序可以把它们的下半部注册到合适的队列上去。缺点是，对于一些性能要求较高的子系统（例如定时器、网络部分），它则不能胜任。</p><p>把推后执行的任务叫做工作（work），描述它的数据结构为work_struct ，这些工作以队列结构组织成工作队列（workqueue），其数据结构为workqueue_struct ，而工作线程就是负责执行工作队列中的工作。系统默认的工作者线程为events。</p><p>工作队列(work queue)是另外一种将工作推后执行的形式。工作队列可以把工作推后，交由一个内核线程去执行—这个下半部分总是会在进程上下文执行，但由于是内核线程，其不能访问用户空间。最重要特点的就是工作队列允许重新调度甚至是睡眠。</p><h1 id="软中断-tasklet与工作队列的区别与联系"><a class="markdownIt-Anchor" href="#软中断-tasklet与工作队列的区别与联系"></a> 软中断、tasklet与工作队列的区别与联系</h1><h2 id="软中断-2"><a class="markdownIt-Anchor" href="#软中断-2"></a> 软中断</h2><ol><li><p>软中断是在编译期间静态分配的。</p></li><li><p>最多可以有32个软中断。</p></li><li><p>软中断不会抢占另外一个软中断，唯一可以抢占软中断的是中断处理程序。</p></li><li><p>可以并发运行在多个CPU上（即使同一类型的也可以）。所以软中断必须设计为可重入的函数（允许多个CPU同时操作），因此也需要使用自旋锁来保护其数据结构。</p></li><li><p>目前只有两个子系直接使用软中断：网络和SCSI。</p></li><li><p>执行时间有：从硬件中断代码返回时、在ksoftirqd内核线程中和某些显示检查并执行软中断的代码中。</p></li></ol><h2 id="tasklet-2"><a class="markdownIt-Anchor" href="#tasklet-2"></a> tasklet</h2><ol><li>tasklet是使用两类软中断实现的：HI_SOFTIRQ和TASKLET_SOFTIRQ。</li><li>可以动态增加减少，没有数量限制。</li><li>同一类tasklet不能并发执行。</li><li>不同类型可以并发执行。</li><li>大部分情况使用tasklet。</li></ol><h2 id="工作队列-2"><a class="markdownIt-Anchor" href="#工作队列-2"></a> 工作队列</h2><ol><li>由内核线程去执行，换句话说总在进程上下文执行。</li><li>可以睡眠，阻塞。</li></ol><p><img src="/image/tasklet/2.png" alt="2" /></p><h2 id="选择方法"><a class="markdownIt-Anchor" href="#选择方法"></a> 选择方法</h2><ul><li>如果推后执行的任务<strong>需要睡眠</strong>，那么只能选择<strong>工作队列</strong>。</li><li>如果推后执行的任务<strong>需要延时指定的时间再触发</strong>，那么使用<strong>工作队列</strong>，因为其可以利用timer延时(内核定时器实现)。</li><li>如果推后执行的任务<strong>需要在一个tick之内处理</strong>，则使用<strong>软中断或tasklet</strong>，因为其可以抢占普通进程和内核线程，同时不可睡眠。</li><li>如果推后执行的任务对延迟的时间<strong>没有任何要求</strong>，则使用<strong>工作队列</strong>，此时通常为无关紧要的任务。</li></ul><blockquote><p>参考：</p><p><a href="https://blog.csdn.net/godleading/article/details/52971179">https://blog.csdn.net/godleading/article/details/52971179</a></p><p><a href="https://blog.csdn.net/Ivan804638781/article/details/115312421">https://blog.csdn.net/Ivan804638781/article/details/115312421</a></p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="CS" scheme="http://aflyingsheep.github.io/categories/CS/"/>
    
    <category term="HPC" scheme="http://aflyingsheep.github.io/categories/HPC/"/>
    
    
    <category term="HPC" scheme="http://aflyingsheep.github.io/tags/HPC/"/>
    
  </entry>
  
  <entry>
    <title>HPC基础：MPI+OPENMP</title>
    <link href="http://aflyingsheep.github.io/2022/08/05/mpi%20and%20openmp/openmp_MPI/"/>
    <id>http://aflyingsheep.github.io/2022/08/05/mpi%20and%20openmp/openmp_MPI/</id>
    <published>2022-08-05T12:38:06.000Z</published>
    <updated>2022-11-07T09:21:39.206Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="mpi"><a class="markdownIt-Anchor" href="#mpi"></a> MPI</h1><h2 id="第一个并行程序"><a class="markdownIt-Anchor" href="#第一个并行程序"></a> 第一个并行程序</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 第一个MPI程序</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">hello_world</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> greeting[MAX_STRING];</span><br><span class="line">    <span class="keyword">int</span> comm_sz; <span class="comment">// 进程核数</span></span><br><span class="line">    <span class="keyword">int</span> my_rank; <span class="comment">// 进程等级</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 进行所有必要的初始化设置，调用该函数前不得调用其他MPI函数</span></span><br><span class="line">    <span class="comment">// 同样存在MPI_Finalize()与其对应，在他们中间可以使用MPI函数</span></span><br><span class="line">    <span class="built_in">MPI_Init</span>(<span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Init的一个目的为用户启动程序时定义由用户启动所有进程所组成的通信子，成为MPI_COMM_WORLD</span></span><br><span class="line">    <span class="comment">// 注：下面两个函数第一个参数为通信子，第二个为输出</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回通信子进程数</span></span><br><span class="line">    <span class="built_in">MPI_Comm_size</span>(MPI_COMM_WORLD, &amp;comm_sz);</span><br><span class="line">    <span class="comment">// 返回正在调用进程在通信子中的进程号</span></span><br><span class="line">    <span class="built_in">MPI_Comm_rank</span>(MPI_COMM_WORLD, &amp;my_rank);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 消息发送与接收</span></span><br><span class="line">    <span class="comment">// 消息发送</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    int MPI_Send(</span></span><br><span class="line"><span class="comment">        void* msg_buf_p      , //指向包含信息内容的指针</span></span><br><span class="line"><span class="comment">        int   msg_size       ,</span></span><br><span class="line"><span class="comment">        MPI_Datatype msg_type, //数据量</span></span><br><span class="line"><span class="comment">        int   dest           , //目的</span></span><br><span class="line"><span class="comment">        int   tag            , //标签</span></span><br><span class="line"><span class="comment">        MPI_Comm communicator);//通信子</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="comment">// 消息接收</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    int MPI_Recv(</span></span><br><span class="line"><span class="comment">        void* msg_buf_p      ,</span></span><br><span class="line"><span class="comment">        int   buf_size       ,</span></span><br><span class="line"><span class="comment">        MPI_Datatype         ,</span></span><br><span class="line"><span class="comment">        int   source         ,</span></span><br><span class="line"><span class="comment">        int   tag            ,</span></span><br><span class="line"><span class="comment">        MPI_Comm communicator,</span></span><br><span class="line"><span class="comment">        MPI_Status* status_p //是一个输出！</span></span><br><span class="line"><span class="comment">        );</span></span><br><span class="line"><span class="comment">    )</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="comment">// 当recv_type = send_type &amp;&amp; recv_buf_sz &gt;= send_buf_sz，则可以被接受</span></span><br><span class="line">    <span class="comment">// 接收的SOURCE核TAG有通配符，但通信子没有。</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 0号进程用于接收信息并打印</span></span><br><span class="line">    <span class="keyword">if</span> (my_rank == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;I&#x27;m main process, greetings from process %d of %d!\n&quot;</span>, my_rank, comm_sz);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; comm_sz; i++) &#123;</span><br><span class="line">            <span class="comment">// 使用MPI_ANY_SOURCE保证按完成工作顺序打印,MPI_ANY_TAG同理</span></span><br><span class="line">            <span class="comment">//MPI_Recv(greeting, MAX_STRING, MPI_CHAR, i, 0, MPI_COMM_WORLD, MPI_STATUSES_IGNORE);</span></span><br><span class="line">            <span class="built_in">MPI_Recv</span>(greeting, MAX_STRING, MPI_CHAR, MPI_ANY_SOURCE, <span class="number">0</span>, MPI_COMM_WORLD, MPI_STATUSES_IGNORE);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, greeting);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 其他进程用于发送信息</span></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 输出信息到字符串greeting中</span></span><br><span class="line">        <span class="built_in">sprintf_s</span>(greeting, <span class="string">&quot;Greetings from process %d of %d!&quot;</span>, my_rank, comm_sz);</span><br><span class="line">        <span class="comment">// 将消息发送给0号进程</span></span><br><span class="line">        <span class="built_in">MPI_Send</span>(greeting, <span class="built_in">strlen</span>(greeting) + <span class="number">1</span>, MPI_CHAR, <span class="number">0</span>, <span class="number">0</span>, MPI_COMM_WORLD);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// MPI_Status 结构体，对其成员访问分别获取source和tag信息：</span></span><br><span class="line">    <span class="comment">// status.MPI_SOURCE</span></span><br><span class="line">    <span class="comment">// status.MPI_TAG</span></span><br><span class="line">    <span class="comment">// 通过MPI_Get_count(&amp;status, recv_type, &amp;count)获取到接受元素的数量（返回到count中）</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="built_in">MPI_Finalize</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="利用mpi实现梯形积分点对点通信"><a class="markdownIt-Anchor" href="#利用mpi实现梯形积分点对点通信"></a> 利用MPI实现梯形积分（点对点通信）</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 2. 利用MPI实现梯形积分（点对点通信）</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    设计一个并行程序：</span></span><br><span class="line"><span class="comment">    1. 将问题划分为多个任务</span></span><br><span class="line"><span class="comment">    2. 在任务间识别出需要的通信信道</span></span><br><span class="line"><span class="comment">    3. 将任务聚合为复合任务</span></span><br><span class="line"><span class="comment">    4. 在核上分配任务</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">this_function</span><span class="params">(<span class="keyword">double</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    输入：只允许0号进程进行输入</span></span><br><span class="line"><span class="comment">    输出：可能乱序，需要自己进行编写</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">Trap</span><span class="params">(<span class="keyword">double</span> left, <span class="keyword">double</span> right, <span class="keyword">double</span> n, <span class="keyword">double</span> h)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">double</span> res = <span class="built_in">this_function</span>(left) / <span class="number">2</span> + <span class="built_in">this_function</span>(right) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        res += <span class="built_in">this_function</span>(left + h * i);</span><br><span class="line">    &#125;</span><br><span class="line">    res = res * h;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Trapezoids</span> <span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> my_rank, comm_sz, n;</span><br><span class="line">    <span class="built_in">MPI_Init</span>(<span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">int</span> left, right;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">MPI_Comm_size</span>(MPI_COMM_WORLD, &amp;comm_sz);</span><br><span class="line">    <span class="built_in">MPI_Comm_rank</span>(MPI_COMM_WORLD, &amp;my_rank);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 0号进程进行输入</span></span><br><span class="line">    <span class="keyword">if</span> (my_rank == <span class="number">0</span>) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Input a, b and n\n&quot;</span>;</span><br><span class="line">        cin &gt;&gt; left &gt;&gt; right &gt;&gt; n;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> dest = <span class="number">1</span>; dest &lt; comm_sz; dest++) &#123;</span><br><span class="line">            <span class="built_in">MPI_Send</span>(&amp;left, <span class="number">1</span>, MPI_INT, dest, <span class="number">0</span>, MPI_COMM_WORLD);</span><br><span class="line">            <span class="built_in">MPI_Send</span>(&amp;right, <span class="number">1</span>, MPI_INT, dest, <span class="number">0</span>, MPI_COMM_WORLD);</span><br><span class="line">            <span class="built_in">MPI_Send</span>(&amp;n, <span class="number">1</span>, MPI_INT, dest, <span class="number">0</span>, MPI_COMM_WORLD);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 其他进程读取输入</span></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">MPI_Recv</span>(&amp;left, <span class="number">1</span>, MPI_INT, <span class="number">0</span>, <span class="number">0</span>, MPI_COMM_WORLD, MPI_STATUS_IGNORE);</span><br><span class="line">        <span class="built_in">MPI_Recv</span>(&amp;right, <span class="number">1</span>, MPI_INT, <span class="number">0</span>, <span class="number">0</span>, MPI_COMM_WORLD, MPI_STATUS_IGNORE);</span><br><span class="line">        <span class="built_in">MPI_Recv</span>(&amp;n, <span class="number">1</span>, MPI_INT, <span class="number">0</span>, <span class="number">0</span>, MPI_COMM_WORLD, MPI_STATUS_IGNORE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算负责区域的左右区间、分段数量</span></span><br><span class="line">    <span class="keyword">int</span> h = (right - left) / n;</span><br><span class="line">    <span class="keyword">int</span> local_n = n / comm_sz;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> local_left = left + my_rank * h * local_n;</span><br><span class="line">    <span class="keyword">int</span> local_right = right + my_rank * h * local_n;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在负责区域进行串行计算</span></span><br><span class="line">    <span class="keyword">double</span> local_res = <span class="built_in">Trap</span>(local_left, local_right, local_n, h);</span><br><span class="line">    <span class="keyword">double</span> total_res = local_res;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回结果</span></span><br><span class="line">    <span class="keyword">if</span> (my_rank != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">MPI_Send</span>(&amp;local_res, <span class="number">1</span>, MPI_DOUBLE, <span class="number">0</span>, <span class="number">0</span>, MPI_COMM_WORLD);</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;I&#x27;m process &quot;</span> &lt;&lt; my_rank &lt;&lt; <span class="string">&quot;, I send the result&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; comm_sz; i++) &#123;</span><br><span class="line">            <span class="built_in">MPI_Recv</span>(&amp;local_res, <span class="number">1</span>, MPI_DOUBLE, i, <span class="number">0</span>, MPI_COMM_WORLD, MPI_STATUS_IGNORE);</span><br><span class="line">            total_res += local_res;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 0号进程输出结果</span></span><br><span class="line">    <span class="keyword">if</span> (my_rank == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;With n = %d trapezoids, our estimate\n&quot;</span>, n);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;of the integral from %f to %f = %.15e\n&quot;</span>, left, right, total_res);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">MPI_Finalize</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="集合通信"><a class="markdownIt-Anchor" href="#集合通信"></a> 集合通信</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    集合通信：设计通信子中所有进程的通信函数</span></span><br><span class="line"><span class="comment">    点对点通信：MPI_Send类似</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    一些集合通信的注意事项：</span></span><br><span class="line"><span class="comment">    1. 通信子内所有进程必须调用相同的集合通信函数</span></span><br><span class="line"><span class="comment">    2. 参数必须相容，如dest_process都应该相同</span></span><br><span class="line"><span class="comment">    3. output_data_p只作用于dest_process</span></span><br><span class="line"><span class="comment">    4. 集合通信函数只通过通信子和调用顺序进行匹配！！！调用顺序很重要！P69表3-3</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 集合通信解决梯形积分</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">int MPI_Reduce(</span></span><br><span class="line"><span class="comment">    void*           input_data_p,</span></span><br><span class="line"><span class="comment">    void*           output_data_p,</span></span><br><span class="line"><span class="comment">    int             count,</span></span><br><span class="line"><span class="comment">    MPI_Datatype    datatype,</span></span><br><span class="line"><span class="comment">    MPI_Op          operator,</span></span><br><span class="line"><span class="comment">    int             dest_process,</span></span><br><span class="line"><span class="comment">    MPI_Comm        comm</span></span><br><span class="line"><span class="comment">)</span></span><br><span class="line"><span class="comment">    MPI_Allreduce 将计算的结果返回给所有进程，参数表同Reduce，但是没有dest</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    广播函数：MPI_Bcast(data_p(in/out), count, data_type, source_proc, comm)</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">// 使用广播函数获取输入并分发</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Get_input</span><span class="params">(<span class="keyword">int</span> my_rank, <span class="keyword">int</span> comm_sz, <span class="keyword">double</span>* a_p, <span class="keyword">double</span>* b_p, <span class="keyword">int</span>* n_p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (my_rank == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Input a, b and n.\n&quot;</span>);</span><br><span class="line">        <span class="built_in">scanf_s</span>(<span class="string">&quot;%lf%lf%d&quot;</span>, a_p, b_p, n_p);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">MPI_Bcast</span>(a_p, <span class="number">1</span>, MPI_DOUBLE, <span class="number">0</span>, MPI_COMM_WORLD);</span><br><span class="line">    <span class="built_in">MPI_Bcast</span>(b_p, <span class="number">1</span>, MPI_DOUBLE, <span class="number">0</span>, MPI_COMM_WORLD);</span><br><span class="line">    <span class="built_in">MPI_Bcast</span>(n_p, <span class="number">1</span>, MPI_INT, <span class="number">0</span>, MPI_COMM_WORLD);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    散射：MPI_Scatter()</span></span><br><span class="line"><span class="comment">    限制：块划分法+块大小相同</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">// 读取向量并划分分发</span></span><br><span class="line"><span class="comment">// 以下仅考虑可以整除的情况，习题3.13将讨论不可整除</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Read_vector</span><span class="params">(<span class="keyword">double</span> local_a[], <span class="keyword">int</span> local_n, <span class="keyword">int</span> n, </span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">char</span> vector_name[], <span class="keyword">int</span> my_rank, MPI_Comm comm)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">double</span>* a = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span> (my_rank == <span class="number">0</span>) &#123;</span><br><span class="line">        a = (<span class="keyword">double</span>*) <span class="built_in">malloc</span>(n * <span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">double</span>));</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="built_in">scanf_s</span>(<span class="string">&quot;%lf&quot;</span>, &amp;a[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">MPI_Scatter</span>(a, local_n, MPI_DOUBLE, local_a, local_n, MPI_DOUBLE, <span class="number">0</span>, comm);</span><br><span class="line">        <span class="built_in">free</span>(a);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">MPI_Scatter</span>(a, local_n, MPI_DOUBLE, local_a, local_n, MPI_DOUBLE, <span class="number">0</span>, comm);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    聚集：MPI_Gather()</span></span><br><span class="line"><span class="comment">    注：recv_count 指的是每个进程接收到的数据量</span></span><br><span class="line"><span class="comment">    限制：块划分法+块大小相同</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Print_vector</span><span class="params">(<span class="keyword">double</span> local_b[], <span class="keyword">int</span> local_n, <span class="keyword">int</span> n, <span class="keyword">char</span> title[], <span class="keyword">int</span> my_rank, MPI_Comm comm)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">double</span>* a = (<span class="keyword">double</span>*)<span class="built_in">malloc</span>(n * <span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">double</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (my_rank == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">MPI_Gather</span>(local_b, local_n, MPI_DOUBLE, a, local_n, MPI_DOUBLE, <span class="number">0</span>, MPI_COMM_WORLD);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, title);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) <span class="built_in">printf</span>(<span class="string">&quot;%lf &quot;</span>, a[i]);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">        <span class="built_in">free</span>(a);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">MPI_Gather</span>(local_b, local_n, MPI_DOUBLE, a, local_n, MPI_DOUBLE, <span class="number">0</span>, MPI_COMM_WORLD);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    全局聚集：MPI_Allgather()：相当于MPI_Gather + MPI_Bcast</span></span><br><span class="line"><span class="comment">    将每个进程Send_p的内容串联起来放到Recv_p中</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">// 矩阵与向量相乘</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Matirx_Mul_Vector</span><span class="params">(<span class="keyword">double</span> local_A[], <span class="keyword">double</span> local_x[], <span class="keyword">double</span> local_y[], </span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">int</span> local_m, <span class="keyword">int</span> n,<span class="keyword">int</span> local_n, <span class="keyword">int</span> my_rank, MPI_Comm comm)</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">double</span>* x;</span><br><span class="line"></span><br><span class="line">    x = (<span class="keyword">double</span>*)<span class="built_in">malloc</span>(n * <span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">double</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 因为此处，函数得到的是划分后的x，但是运算需要整个x向量，故需要Allgather进行向量补全</span></span><br><span class="line">    <span class="built_in">MPI_Allgather</span>(local_x, local_n, MPI_DOUBLE, x, local_n, MPI_DOUBLE, comm);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> local_i = <span class="number">0</span>; local_i &lt; local_m; local_i++) &#123;</span><br><span class="line">        local_y[local_i] = <span class="number">0.0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++)</span><br><span class="line">            local_y[local_i] += local_A[local_i * n + j] * x[j];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">free</span>(x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="信息整合"><a class="markdownIt-Anchor" href="#信息整合"></a> 信息整合</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    MPI提供的三个整合多条消息数据的手段：</span></span><br><span class="line"><span class="comment">    1. count</span></span><br><span class="line"><span class="comment">    2. 派生数据类型</span></span><br><span class="line"><span class="comment">    3. pack/unpack</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 派生数据类型：如果发送数据的函数知道数据项的类型以及在内存中数据项集合的相对位置，</span></span><br><span class="line"><span class="comment">   就可以在数据项被发送出去之前在内存中将数据项聚集起来。</span></span><br><span class="line"><span class="comment">   组成：数据类型 + 偏移</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">   派生数据类型更像是将每一个指定位移的数据的偏移量记录下来，每次通信的时候传输这些数据</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">// 创建派生数据类型</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">int MPI_Type_create_struct(</span></span><br><span class="line"><span class="comment">    int count,                          // 数据类型中的元素个数，下面各个参数数组都有count个元素</span></span><br><span class="line"><span class="comment">    int array_of_blocklengths[],        // 允许单独数据项为数组或子数组，如第一个元素是一个含5个元素的数组，则aob[0] = 5</span></span><br><span class="line"><span class="comment">    MPI_Aint array_of_displacements[],  // 距离消息起始位置的偏移量,单位为字节</span></span><br><span class="line"><span class="comment">    MPI_Datatype array_of_types[],      // 数据类型</span></span><br><span class="line"><span class="comment">    MPI_Datatype* new_type_p    (out)</span></span><br><span class="line"><span class="comment">    )</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">// 使用前需要指定</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">int MPI_Type_commit(MPI_Datatype* new_type_p);</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用派生数据类型的Get_input</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">原：</span></span><br><span class="line"><span class="comment">void Get_input(int my_rank, int comm_sz, double* a_p, double* b_p, int* n_p) &#123;</span></span><br><span class="line"><span class="comment">    if (my_rank == 0) &#123;</span></span><br><span class="line"><span class="comment">        printf(&quot;Input a, b and n.\n&quot;);</span></span><br><span class="line"><span class="comment">        scanf_s(&quot;%lf%lf%d&quot;, a_p, b_p, n_p);</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    MPI_Bcast(a_p, 1, MPI_DOUBLE, 0, MPI_COMM_WORLD);</span></span><br><span class="line"><span class="comment">    MPI_Bcast(b_p, 1, MPI_DOUBLE, 0, MPI_COMM_WORLD);</span></span><br><span class="line"><span class="comment">    MPI_Bcast(n_p, 1, MPI_INT, 0, MPI_COMM_WORLD);</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    修改后</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Build_mpi_type</span><span class="params">(<span class="keyword">double</span>* a_p, <span class="keyword">double</span>* b_p, <span class="keyword">int</span>* n_p, MPI_Datatype* data_type)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> array_of_blocklengths[<span class="number">3</span>] = &#123; <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span> &#125;;</span><br><span class="line">    MPI_Datatype array_of_types[<span class="number">3</span>] = &#123; MPI_DOUBLE, MPI_DOUBLE, MPI_INT &#125;;</span><br><span class="line">    MPI_Aint a_addr, b_addr, n_addr;</span><br><span class="line">    MPI_Aint array_of_addr[<span class="number">3</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">MPI_Get_address</span>(a_p, &amp;a_addr);</span><br><span class="line">    <span class="built_in">MPI_Get_address</span>(b_p, &amp;b_addr);</span><br><span class="line">    <span class="built_in">MPI_Get_address</span>(n_p, &amp;n_addr);</span><br><span class="line"></span><br><span class="line">    array_of_addr[<span class="number">1</span>] = b_addr - a_addr;</span><br><span class="line">    array_of_addr[<span class="number">2</span>] = n_addr - b_addr;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">MPI_Type_create_struct</span>(<span class="number">3</span>, array_of_blocklengths, array_of_addr, array_of_types, data_type);</span><br><span class="line">    <span class="built_in">MPI_Type_commit</span>(data_type);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Get_input_new</span><span class="params">(<span class="keyword">int</span> my_rank, <span class="keyword">int</span> comm_sz, <span class="keyword">double</span>* a_p, <span class="keyword">double</span>* b_p, <span class="keyword">int</span>* n_p)</span> </span>&#123;</span><br><span class="line">    MPI_Datatype <span class="keyword">input_mpi_t</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Build_mpi_type</span>(a_p, b_p, n_p, &amp;<span class="keyword">input_mpi_t</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (my_rank == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Input a, b and n.\n&quot;</span>);</span><br><span class="line">        <span class="built_in">scanf_s</span>(<span class="string">&quot;%lf%lf%d&quot;</span>, a_p, b_p, n_p);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">MPI_Bcast</span>(a_p, <span class="number">1</span>, <span class="keyword">input_mpi_t</span>, <span class="number">0</span>, MPI_COMM_WORLD);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">MPI_Type_free</span>(&amp;<span class="keyword">input_mpi_t</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="并行排序算法分布式算法实现"><a class="markdownIt-Anchor" href="#并行排序算法分布式算法实现"></a> 并行排序算法——分布式算法实现</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 冒泡排序变种——奇偶交换排序</span></span><br><span class="line"><span class="comment">// 找寻交换进程号</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ComputePartner</span><span class="params">(<span class="keyword">int</span> my_rank, <span class="keyword">int</span> comm_sz, <span class="keyword">int</span> phase, <span class="keyword">int</span>&amp; partner)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (phase % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (my_rank % <span class="number">2</span> == <span class="number">0</span>)</span><br><span class="line">            partner = my_rank + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> partner = my_rank - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (my_rank % <span class="number">2</span> == <span class="number">0</span>)</span><br><span class="line">            partner = my_rank - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> partner = my_rank + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (partner == <span class="number">-1</span> || partner == comm_sz)</span><br><span class="line">        <span class="comment">// 注：MPI_PROC_NULL作为源进程或目标进程进程号时，调用通信函数直接返回，不产生通信</span></span><br><span class="line">        partner = MPI_PROC_NULL;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注：MPI_Send有两种发送方式，如果数据量较大可能会造成阻塞发送，可能导致死锁。</span></span><br><span class="line"><span class="comment">// 问题：程序安全如何保证？使用MPI_Ssend（表示同步，发送如果没被接受便阻塞）</span></span><br><span class="line"><span class="comment">// 问题：怎么修改奇偶排序使其安全？重构通信。</span></span><br><span class="line"><span class="comment">// MPI_Sendrecv() 阻塞式发送接收，可以保证安全</span></span><br><span class="line"><span class="comment">// MPI_Sendrecv_replace() 发送和接受使用的是同一个缓冲区</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 奇偶冒泡</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Merge_low</span><span class="params">(<span class="keyword">int</span> my_keys[], <span class="keyword">int</span> recv_keys[], <span class="keyword">int</span> temp_keys[], <span class="keyword">int</span> local_n, <span class="keyword">bool</span> flag)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> m_i = <span class="number">0</span>, r_i = <span class="number">0</span>, t_i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (!flag) &#123;</span><br><span class="line">        m_i = local_n - <span class="number">1</span>;</span><br><span class="line">        r_i = local_n - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// flag为true时，交换代表前一个线程（取小），反之取大。</span></span><br><span class="line">    <span class="comment">// 每次前一线程取小，后一线程取大</span></span><br><span class="line">    <span class="keyword">while</span> (t_i &lt; local_n) &#123;</span><br><span class="line">        <span class="keyword">if</span> (flag) &#123;</span><br><span class="line">            <span class="keyword">if</span> (my_keys[m_i] &lt; recv_keys[r_i]) &#123;</span><br><span class="line">                temp_keys[t_i] = my_keys[m_i];</span><br><span class="line">                t_i++; m_i++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                temp_keys[t_i] = recv_keys[r_i];</span><br><span class="line">                t_i++; r_i++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (my_keys[m_i] &gt; recv_keys[r_i]) &#123;</span><br><span class="line">                temp_keys[t_i] = my_keys[m_i];</span><br><span class="line">                t_i++; m_i--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                temp_keys[t_i] = recv_keys[r_i];</span><br><span class="line">                t_i++; r_i--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (flag) <span class="keyword">for</span> (m_i = <span class="number">0</span>; m_i &lt; local_n; m_i++) my_keys[m_i] = temp_keys[m_i];</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">for</span> (m_i = local_n - <span class="number">1</span>; m_i &gt;= <span class="number">0</span>; m_i--) my_keys[local_n - m_i - <span class="number">1</span>] = temp_keys[m_i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">compare</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span>* e1, <span class="keyword">const</span> <span class="keyword">void</span>* e2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//将void*类型的指针e1和e2强制类型转换成int*型</span></span><br><span class="line">    <span class="keyword">return</span>  *((<span class="keyword">int</span>*)e1) - *((<span class="keyword">int</span>*)e2);</span><br><span class="line">    <span class="comment">//一定要强制类型转换，因为e1和e2都是void*指针，没有类型的指针</span></span><br><span class="line">    <span class="comment">//如果不想要升序排列，想要按降序排列，就可以return  *((int*)e2) - *((int *)e1);</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">My_Sort</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> my_rank, comm_sz, n;</span><br><span class="line">    <span class="keyword">int</span>* array = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="built_in">MPI_Init</span>(<span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">MPI_Comm_size</span>(MPI_COMM_WORLD, &amp;comm_sz);</span><br><span class="line">    <span class="built_in">MPI_Comm_rank</span>(MPI_COMM_WORLD, &amp;my_rank);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 进程0读入</span></span><br><span class="line">    <span class="keyword">if</span> (my_rank == <span class="number">0</span>) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Input size of array:&quot;</span>;</span><br><span class="line">        cin &gt;&gt; n;</span><br><span class="line"></span><br><span class="line">        array = (<span class="keyword">int</span>*)<span class="built_in">malloc</span>(<span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">int</span>) * n);</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            cin &gt;&gt; array[i];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 广播总个数</span></span><br><span class="line">    <span class="built_in">MPI_Bcast</span>(&amp;n, <span class="number">1</span>, MPI_INT, <span class="number">0</span>, MPI_COMM_WORLD);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// local_n代表每个进程分配的元素个数</span></span><br><span class="line">    <span class="keyword">int</span> local_n = n / comm_sz;</span><br><span class="line">    <span class="comment">// cout &lt;&lt; &quot;local_n&quot; &lt;&lt; local_n &lt;&lt; endl;</span></span><br><span class="line">    <span class="keyword">int</span>* local_array = (<span class="keyword">int</span>*)<span class="built_in">malloc</span>(<span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">int</span>) * local_n);</span><br><span class="line">    <span class="comment">// if (my_rank == 0) for (int i = 0; i &lt; local_n; i++) local_array[i] = array[i];</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 分配元素</span></span><br><span class="line">    <span class="built_in">MPI_Scatter</span>(array, local_n, MPI_INT, local_array, local_n, MPI_INT, <span class="number">0</span>, MPI_COMM_WORLD);</span><br><span class="line">    <span class="comment">//cout &lt;&lt; &quot;Process&quot; &lt;&lt; my_rank &lt;&lt; &quot; &#x27;s array is &quot; &lt;&lt; local_array[0] &lt;&lt; endl;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">101</span>; i++) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>* local_receive = (<span class="keyword">int</span>*)<span class="built_in">malloc</span>(<span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">int</span>) * local_n);</span><br><span class="line">        <span class="keyword">int</span>* local_temp = (<span class="keyword">int</span>*)<span class="built_in">malloc</span>(<span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">int</span>) * local_n);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> partner;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 计算本回合交换目标</span></span><br><span class="line">        <span class="built_in">ComputePartner</span>(my_rank, comm_sz, i, partner);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// cout &lt;&lt; &quot;epoch&quot; &lt;&lt; i &lt;&lt; &quot; &quot; &lt;&lt; &quot;Process&quot; &lt;&lt; my_rank &lt;&lt; &quot; &#x27;s partner is &quot; &lt;&lt; partner &lt;&lt; endl;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 本进程元素排序</span></span><br><span class="line">        <span class="built_in">qsort</span>(local_array, local_n, <span class="built_in"><span class="keyword">sizeof</span></span>(local_array[<span class="number">0</span>]), compare);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 互发元素元素</span></span><br><span class="line">        <span class="built_in">MPI_Sendrecv</span>(local_array, local_n, MPI_INT, partner, <span class="number">0</span>, </span><br><span class="line">            local_receive, local_n, MPI_INT, partner, <span class="number">0</span>, MPI_COMM_WORLD, MPI_STATUSES_IGNORE);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// cout &lt;&lt; &quot;epoch&quot; &lt;&lt; i &lt;&lt; &quot; &quot; &lt;&lt; &quot;Process&quot; &lt;&lt; my_rank &lt;&lt; &quot; &#x27;s recv is &quot; &lt;&lt; local_receive[0] &lt;&lt; &quot;and&quot; &lt;&lt; local_receive[1] &lt;&lt; endl;</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">bool</span> flag = (i % <span class="number">2</span> == <span class="number">0</span>) &amp;&amp; (my_rank % <span class="number">2</span> == <span class="number">0</span>) || (i % <span class="number">2</span> == <span class="number">1</span>) &amp;&amp; (my_rank % <span class="number">2</span> == <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (partner != MPI_PROC_NULL)</span><br><span class="line">            <span class="built_in">Merge_low</span>(local_array, local_receive, local_temp, local_n, flag);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// cout &lt;&lt; &quot;epoch&quot; &lt;&lt; i &lt;&lt; &quot; &quot; &lt;&lt; &quot;Process&quot; &lt;&lt; my_rank &lt;&lt; &quot; &#x27;s sorted array is &quot; &lt;&lt; local_array[0] &lt;&lt; &quot;and&quot; &lt;&lt; local_array[1] &lt;&lt; endl;</span></span><br><span class="line"></span><br><span class="line">        <span class="built_in">free</span>(local_receive);</span><br><span class="line">        <span class="built_in">free</span>(local_temp);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 收集最后结果</span></span><br><span class="line">    <span class="built_in">MPI_Gather</span>(local_array, local_n, MPI_INT, array, local_n, MPI_INT, <span class="number">0</span>, MPI_COMM_WORLD);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (my_rank == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) cout &lt;&lt; array[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    <span class="built_in">MPI_Finalize</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="openmp"><a class="markdownIt-Anchor" href="#openmp"></a> OpenMP</h1><h2 id="第一个openmp程序"><a class="markdownIt-Anchor" href="#第一个openmp程序"></a> 第一个OpenMP程序</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> _OPENMP</span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">include</span><span class="meta-string">&lt;omp.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Hello_world</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span> </span>&#123;</span><br><span class="line">    <span class="comment">/* 得到线程数 */</span></span><br><span class="line">    <span class="keyword">int</span> thread_count = <span class="built_in">strtol</span>(argv[<span class="number">1</span>], <span class="literal">NULL</span>, <span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// #pragma 开头，代表预处理器指令，如果不支持pragma的编译器会忽略该指令</span></span><br><span class="line">    <span class="comment">// parallel代表结构化代码块，是一条C语句或一个入口和一个出口的复合C语句</span></span><br><span class="line">    <span class="comment">// parallel指令添加num_threads子句(子句是修改指令的文本)</span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">pragma</span> omp parallel num_threads(thread_count)</span></span><br><span class="line">    <span class="built_in">Hello_world</span>();</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        执行parallel指令后，thread_count - 1个线程被启动，</span></span><br><span class="line"><span class="comment">        原始线程成为主线程master,额外线程称为从线程slave</span></span><br><span class="line"><span class="comment">        master + slave称为线程组，线程组每个线程都执行parallel后的代码块</span></span><br><span class="line"><span class="comment">        该处存在一个隐式路障，当所有线程执行完代码块，从线程终止，主线程才继续执行</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Hello_world</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 得到自己的线程编号</span></span><br><span class="line">    <span class="keyword">int</span> my_rank = <span class="built_in">omp_get_thread_num</span>();</span><br><span class="line">    <span class="comment">// 得到线程组中的线程数</span></span><br><span class="line">    <span class="keyword">int</span> thread_count = <span class="built_in">omp_get_num_threads</span>();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Hello world from thread %d of %d\n&quot;</span>, my_rank, thread_count);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="openmp实现梯形积分法"><a class="markdownIt-Anchor" href="#openmp实现梯形积分法"></a> OpenMP实现梯形积分法</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> _OPENMP</span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">include</span><span class="meta-string">&lt;omp.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Trap</span><span class="params">(<span class="keyword">double</span> a, <span class="keyword">double</span> b, <span class="keyword">int</span> n, </span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">double</span>* global_result_p)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">f</span><span class="params">(<span class="keyword">double</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">double</span> y = x;</span><br><span class="line">    <span class="keyword">return</span> y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">double</span> global_result = <span class="number">0.0</span>;</span><br><span class="line">    <span class="keyword">double</span> a, b;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">int</span> thread_count = <span class="built_in">strtol</span>(argv[<span class="number">1</span>], <span class="literal">NULL</span>, <span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Input a, b and n\n&quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%lf %lf %d&quot;</span>, &amp;a, &amp;b, &amp;n);</span><br><span class="line"></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">pragma</span> omp parallel num_threads(thread_count)</span></span><br><span class="line">    <span class="built_in">Trap</span>(a, b, n, &amp;global_result);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Estimate of the integral = %.14e\n&quot;</span>, global_result);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Trap</span><span class="params">(<span class="keyword">double</span> a, <span class="keyword">double</span> b, <span class="keyword">int</span> n, </span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">double</span>* global_result_p)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 注意，计算并没有检查n是否能被thread_num整除，如不能需要另加修改</span></span><br><span class="line">    <span class="keyword">double</span> h, x, my_result;</span><br><span class="line">    <span class="keyword">double</span> local_a, local_b;</span><br><span class="line">    <span class="keyword">int</span> i, local_n;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> my_rank = <span class="built_in">omp_get_thread_num</span>();</span><br><span class="line">    <span class="keyword">int</span> thread_count = <span class="built_in">omp_get_num_threads</span>();</span><br><span class="line"></span><br><span class="line">    h = (b - a) / n;</span><br><span class="line">    local_n = n / thread_count;</span><br><span class="line">    local_a = a + my_rank * local_n * h;</span><br><span class="line">    local_b = local_a + h * local_n;</span><br><span class="line"></span><br><span class="line">    my_result = (<span class="built_in">f</span>(local_a) + <span class="built_in">f</span>(local_b)) / <span class="number">2.0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= local_n - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        x = local_a + i * h;</span><br><span class="line">        my_result += <span class="built_in">f</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line">    my_result *= h;</span><br><span class="line"></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">pragma</span> omp critical</span></span><br><span class="line">    *global_result_p += my_result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注意：在parallel指令前已经被声明的变量拥有在线程组中共享作用域，</span></span><br><span class="line"><span class="comment">//      而在块中声明的变量（如函数中的局部变量）有私有作用域</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 加入规约子句的Trap版本</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 我们更加习惯于不使用指针来传递临界变量：</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">Local_trap</span><span class="params">(<span class="keyword">double</span> a, <span class="keyword">double</span> b, <span class="keyword">int</span> n)</span></span>;</span><br><span class="line"><span class="comment">// 而在调用的时候，会改变parallel块如下：</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">double global_result = 0.0;</span></span><br><span class="line"><span class="comment"># pragma omp parallel num_threads(thread.count)</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">    double my_result = 0.0;</span></span><br><span class="line"><span class="comment">    my_result += Local_trap(double a, double b, int n);</span></span><br><span class="line"><span class="comment">#   pragma omp critical</span></span><br><span class="line"><span class="comment">    global_result += my_result;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// OpenMP提供归约(将相同的归约操作符重复应用到操作数序列)操作符，</span></span><br><span class="line"><span class="comment">// 所有操作的中间结果储存在归约变量中</span></span><br><span class="line"><span class="comment">// 于是我们修改parallel块如下：</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">double global_result = 0.0;</span></span><br><span class="line"><span class="comment"># pragma omp parallel num_threads(thread.count) \</span></span><br><span class="line"><span class="comment">    reduction(+: global_result)</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">    global_result += Local_trap(double a, double b, int n);</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">// reduction子句的语法：reduction(&lt;operator&gt;: &lt;variable list&gt;)</span></span><br><span class="line"><span class="comment">// operator可以为：+ * - &amp; | ^ &amp;&amp; ||</span></span><br><span class="line"><span class="comment">// 注意：</span></span><br><span class="line"><span class="comment">// 1. - 不满足交换律和结合律，OpenMP不能保证正确运行</span></span><br><span class="line"><span class="comment">// 2. 归约变量如果为double or float，浮点数运算不满足结合律，可能会有不同</span></span><br><span class="line"><span class="comment">// 3. reduction中包含的变量是共享的，但是每个线程都会创建自己的私有变量（初始化为0或1（*）等情况）</span></span><br><span class="line"><span class="comment">//    当parallel块结束时会将私有变量的值整合到共享变量中</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// parallel for指令</span></span><br><span class="line"><span class="comment">// OpenMP提供parallel for 指令，能够并行化串行积分</span></span><br><span class="line"><span class="comment">// 串行积分改进：</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Serial_Trap</span><span class="params">(<span class="keyword">double</span> h, <span class="keyword">double</span> a, <span class="keyword">double</span> b, <span class="keyword">double</span> approx, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    h = (b - a) / n;</span><br><span class="line">    approx = (<span class="built_in">f</span>(a) + <span class="built_in">f</span>(b)) / <span class="number">2.0</span>;</span><br><span class="line"><span class="meta">#   <span class="meta-keyword">pragma</span> omp parallel for num_threads(thread_count) \</span></span><br><span class="line"><span class="meta">        reduction(+: approx)</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n - <span class="number">1</span>; i++)</span><br><span class="line">        approx += <span class="built_in">f</span>(a + i * h);</span><br><span class="line">    approx = h * approx;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// parallel for与parallel指令非常不同，</span></span><br><span class="line"><span class="comment">// 在parallel指令之前的块，其工作必须由线程本身在线程之间划分</span></span><br><span class="line"><span class="comment">// parallel for指令缺省划分方式由系统决定</span></span><br><span class="line"><span class="comment">// approx必须作为归约变量，否则approx += 将变成无保护临界区</span></span><br><span class="line"><span class="comment">// 注意：parallel for中循环变量缺省作用域是私有的</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 对于parallel for的警告</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    1. 只会并行化for循环，不会并行化while, do-while</span></span><br><span class="line"><span class="comment">    2. OpenMP只能并行化确定迭代次数的for循环</span></span><br><span class="line"><span class="comment">        - 由for语句本身确定</span></span><br><span class="line"><span class="comment">        - 在循环执行前确定</span></span><br><span class="line"><span class="comment">    3. OpenMP只能并行化典型结构for循环</span></span><br><span class="line"><span class="comment">        - index必须是整形或指针类型</span></span><br><span class="line"><span class="comment">        - start, end, incr必须有一个兼容类型</span></span><br><span class="line"><span class="comment">        - start, end, incr在循环执行期间不改变</span></span><br><span class="line"><span class="comment">        - index只能由for语句中增量表达式修改</span></span><br><span class="line"><span class="comment">    4. 唯一例外：循环体中可以有一个exit调用</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 数据依赖性</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    OpenMP编译器不检查被parallel for指令并行化的循环所包含的迭代间依赖关系</span></span><br><span class="line"><span class="comment">    当使用parallel for指令时要寻找循环依赖</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h2 id="parallel-for的数据-循环依赖"><a class="markdownIt-Anchor" href="#parallel-for的数据-循环依赖"></a> parallel for的数据、循环依赖</h2><p>以估算<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>π</mi></mrow><annotation encoding="application/x-tex">\pi</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">π</span></span></span></span>为例：</p><p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>π</mi><mo>=</mo><mn>4</mn><mo stretchy="false">[</mo><mn>1</mn><mo>−</mo><mstyle displaystyle="true" scriptlevel="0"><mfrac><mn>1</mn><mn>3</mn></mfrac></mstyle><mo>+</mo><mstyle displaystyle="true" scriptlevel="0"><mfrac><mn>1</mn><mn>5</mn></mfrac></mstyle><mo>−</mo><mstyle displaystyle="true" scriptlevel="0"><mfrac><mn>1</mn><mn>7</mn></mfrac></mstyle><mo>+</mo><mo>…</mo><mtext> </mtext><mo stretchy="false">]</mo><mo>=</mo><mn>4</mn><msubsup><mo>∑</mo><mrow><mi>k</mi><mo>=</mo><mn>0</mn></mrow><mi mathvariant="normal">∞</mi></msubsup><mstyle displaystyle="true" scriptlevel="0"><mfrac><mrow><mo stretchy="false">(</mo><mo>−</mo><mn>1</mn><msup><mo stretchy="false">)</mo><mi>k</mi></msup></mrow><mrow><mn>2</mn><mi>k</mi><mo>+</mo><mn>1</mn></mrow></mfrac></mstyle></mrow><annotation encoding="application/x-tex">\pi=4[1-\dfrac{1}{3}+\dfrac{1}{5}-\dfrac{1}{7}+\dots]=4\sum^{\infty}_{k=0}\dfrac{(-1)^k}{2k+1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">π</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">4</span><span class="mopen">[</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:2.00744em;vertical-align:-0.686em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.32144em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">3</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:2.00744em;vertical-align:-0.686em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.32144em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">5</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:2.00744em;vertical-align:-0.686em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.32144em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">7</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="minner">…</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.295438em;vertical-align:-0.7693300000000001em;"></span><span class="mord">4</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop"><span class="mop op-symbol small-op" style="position:relative;top:-0.0000050000000000050004em;">∑</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.804292em;"><span style="top:-2.40029em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span><span class="mrel mtight">=</span><span class="mord mtight">0</span></span></span></span><span style="top:-3.2029em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">∞</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.29971000000000003em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.526108em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">2</span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord">1</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mopen">(</span><span class="mord">−</span><span class="mord">1</span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.849108em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.7693300000000001em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 数据依赖性</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    OpenMP编译器不检查被parallel for指令并行化的循环所包含的迭代间依赖关系</span></span><br><span class="line"><span class="comment">    当使用parallel for指令时要寻找循环依赖</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> _OPENMP</span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">include</span><span class="meta-string">&lt;omp.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">serial_pai</span><span class="params">(<span class="keyword">int</span> thread_count, <span class="keyword">int</span> n)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">parallel_pai_1_0</span><span class="params">(<span class="keyword">int</span> thread_count, <span class="keyword">int</span> n)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">parallel_pai_1_1</span><span class="params">(<span class="keyword">int</span> thread_count, <span class="keyword">int</span> n)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">parallel_pai</span><span class="params">(<span class="keyword">int</span> thread_count, <span class="keyword">int</span> n)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> thread_count = <span class="built_in">strtol</span>(argv[<span class="number">1</span>], <span class="literal">NULL</span>, <span class="number">10</span>);</span><br><span class="line">    <span class="comment">// serial_pai(thread_count, 1000);</span></span><br><span class="line">    <span class="comment">// parallel_pai_1_0(thread_count, 1000);</span></span><br><span class="line">    <span class="comment">// parallel_pai_1_1(thread_count, 1000);</span></span><br><span class="line">    <span class="built_in">parallel_pai</span>(thread_count, <span class="number">1000</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 串行代码</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">serial_pai</span><span class="params">(<span class="keyword">int</span> thread_count, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">double</span> factor = <span class="number">1.0</span>;</span><br><span class="line">    <span class="keyword">double</span> sum = <span class="number">0.0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; n; k++) &#123;</span><br><span class="line">        sum += factor / (<span class="number">2</span> * k + <span class="number">1</span>);</span><br><span class="line">        factor = -factor;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">double</span> pi_approx = <span class="number">4.0</span> * sum;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;pai: %lf\n&quot;</span>, pi_approx);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 并行1.0</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">parallel_pai_1_0</span><span class="params">(<span class="keyword">int</span> thread_count,  <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">double</span> factor = <span class="number">1.0</span>;</span><br><span class="line">    <span class="keyword">double</span> sum = <span class="number">0.0</span>;</span><br><span class="line"><span class="meta">#   <span class="meta-keyword">pragma</span> omp parallel for num_threads(thread_count)\</span></span><br><span class="line"><span class="meta">        reduction(+: sum)</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; n; k++) &#123;</span><br><span class="line">        sum += factor / (<span class="number">2</span> * k + <span class="number">1</span>);</span><br><span class="line">        <span class="comment">// !!!该处存在数据依赖性，若k次迭代在一个线程，k+1次在另一个线程，</span></span><br><span class="line">        <span class="comment">// 会导致factor值错误</span></span><br><span class="line">        factor = -factor;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">double</span> pi_approx = <span class="number">4.0</span> * sum;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;pai: %lf\n&quot;</span>, pi_approx);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 并行1.1</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">parallel_pai_1_1</span><span class="params">(<span class="keyword">int</span> thread_count, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">double</span> factor = <span class="number">1.0</span>;</span><br><span class="line">    <span class="keyword">double</span> sum = <span class="number">0.0</span>;</span><br><span class="line"><span class="meta">#   <span class="meta-keyword">pragma</span> omp parallel for num_threads(thread_count)\</span></span><br><span class="line"><span class="meta">        reduction(+: sum)</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; n; k++) &#123;</span><br><span class="line">        factor = (k % <span class="number">2</span> == <span class="number">0</span>) ? <span class="number">1.0</span> : <span class="number">-1.0</span>;</span><br><span class="line">        sum += factor / (<span class="number">2</span> * k + <span class="number">1</span>);</span><br><span class="line">        <span class="comment">// factor = -factor;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">double</span> pi_approx = <span class="number">4.0</span> * sum;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;pai: %lf\n&quot;</span>, pi_approx);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 问题：</span></span><br><span class="line"><span class="comment">// 注意，缺省情况下任何在循环前声明的变量在线程间都是共享的</span></span><br><span class="line"><span class="comment">// 因此factor是共享的，可能存在线程间修改导致错误，因此要保证factor私有作用域</span></span><br><span class="line"><span class="comment">// 最终版本</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">parallel_pai</span><span class="params">(<span class="keyword">int</span> thread_count, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">double</span> factor = <span class="number">1.0</span>;</span><br><span class="line">    <span class="keyword">double</span> sum = <span class="number">0.0</span>;</span><br><span class="line"><span class="meta">#   <span class="meta-keyword">pragma</span> omp parallel for num_threads(thread_count)\</span></span><br><span class="line"><span class="meta">        reduction(+: sum) private(factor)</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; n; k++) &#123;</span><br><span class="line">        factor = (k % <span class="number">2</span> == <span class="number">0</span>) ? <span class="number">1.0</span> : <span class="number">-1.0</span>;</span><br><span class="line">        sum += factor / (<span class="number">2</span> * k + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">double</span> pi_approx = <span class="number">4.0</span> * sum;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;pai: %lf\n&quot;</span>, pi_approx);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Openmp提供一个子句default(none),要求用户明确每个变量的作用域</span></span><br><span class="line"><span class="comment">// 如对pai的计算可以修改为：</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">#   pragma omp parallel for num_threads(thread_count)\</span></span><br><span class="line"><span class="comment">        default(none) reduction(+: sum) private(k, factor)\</span></span><br><span class="line"><span class="comment">        shared(n)</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h2 id="openmp实现奇偶排序"><a class="markdownIt-Anchor" href="#openmp实现奇偶排序"></a> OpenMP实现奇偶排序</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="comment">// #ifdef _OPENMP</span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">include</span><span class="meta-string">&lt;omp.h&gt;</span></span></span><br><span class="line"><span class="comment">// #endif</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">serial_odd_even_order</span><span class="params">(<span class="keyword">int</span> thread_count, <span class="keyword">int</span> a[], <span class="keyword">int</span> n)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">parallel_odd_even_order</span><span class="params">(<span class="keyword">int</span> thread_count, <span class="keyword">int</span> a[], <span class="keyword">int</span> n)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">parallel_odd_even_order_2</span><span class="params">(<span class="keyword">int</span> thread_count, <span class="keyword">int</span> a[], <span class="keyword">int</span> n)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> &amp;a, <span class="keyword">int</span> &amp;b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t = a;</span><br><span class="line">    a = b;</span><br><span class="line">    b = t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a[<span class="number">10</span>] = &#123;<span class="number">2</span>, <span class="number">1</span>, <span class="number">16</span>, <span class="number">8</span>, <span class="number">6</span>, <span class="number">0</span>, <span class="number">7</span>, <span class="number">11</span>, <span class="number">12</span>, <span class="number">15</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> thread_num = <span class="built_in">strtol</span>(argv[<span class="number">1</span>], <span class="literal">NULL</span>, <span class="number">10</span>);</span><br><span class="line">    <span class="built_in">parallel_odd_even_order_2</span>(thread_num, a, <span class="number">10</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">serial_odd_even_order</span><span class="params">(<span class="keyword">int</span> thread_count, <span class="keyword">int</span> a[], <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> phase;</span><br><span class="line">    <span class="keyword">for</span> (phase = <span class="number">0</span>; phase &lt; n; phase++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (phase % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i += <span class="number">2</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (a[i - <span class="number">1</span>] &gt; a[i]) </span><br><span class="line">                    <span class="built_in">swap</span>(a[i - <span class="number">1</span>], a[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n - <span class="number">1</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (a[i] &gt; a[i + <span class="number">1</span>]) &#123;</span><br><span class="line">                    <span class="built_in">swap</span>(a[i], a[i + <span class="number">1</span>]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// parallel 1.0</span></span><br><span class="line"><span class="comment">// 我们发现，最外层的for循环具有循环依赖，并不适合并行化</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">parallel_odd_even_order</span><span class="params">(<span class="keyword">int</span> thread_count, <span class="keyword">int</span> a[], <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> phase;</span><br><span class="line">    <span class="keyword">for</span> (phase = <span class="number">0</span>; phase &lt; n; phase++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (phase % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="meta">#           <span class="meta-keyword">pragma</span> omp parallel for num_threads(thread_count) \</span></span><br><span class="line"><span class="meta">                default(none) shared(a, n)</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i += <span class="number">2</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (a[i - <span class="number">1</span>] &gt; a[i]) </span><br><span class="line">                    <span class="built_in">swap</span>(a[i - <span class="number">1</span>], a[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="meta">#           <span class="meta-keyword">pragma</span> omp parallel for num_threads(thread_count) \</span></span><br><span class="line"><span class="meta">                default(none) shared(a, n)</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n - <span class="number">1</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (a[i] &gt; a[i + <span class="number">1</span>]) &#123;</span><br><span class="line">                    <span class="built_in">swap</span>(a[i], a[i + <span class="number">1</span>]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// parallel 2.0</span></span><br><span class="line"><span class="comment">// parallel每进行一次外部循环都会创建和合并线程，产生开销</span></span><br><span class="line"><span class="comment">// 每次执行内部循环都会使用相同数量的线程，因此我们希望只创建一次线程，并在每次内部循环执行中重用</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">parallel_odd_even_order_2</span><span class="params">(<span class="keyword">int</span> thread_count, <span class="keyword">int</span> a[], <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> phase;</span><br><span class="line"><span class="meta">#   <span class="meta-keyword">pragma</span> omp parallel num_threads(thread_count) \</span></span><br><span class="line"><span class="meta">        default(none) shared(a, n) private(phase)</span></span><br><span class="line">    <span class="keyword">for</span> (phase = <span class="number">0</span>; phase &lt; n; phase++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (phase % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="meta">#           <span class="meta-keyword">pragma</span> omp for</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i += <span class="number">2</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (a[i - <span class="number">1</span>] &gt; a[i]) </span><br><span class="line">                    <span class="built_in">swap</span>(a[i - <span class="number">1</span>], a[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="meta">#           <span class="meta-keyword">pragma</span> omp for</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n - <span class="number">1</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (a[i] &gt; a[i + <span class="number">1</span>]) &#123;</span><br><span class="line">                    <span class="built_in">swap</span>(a[i], a[i + <span class="number">1</span>]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="线程调度子句schedule"><a class="markdownIt-Anchor" href="#线程调度子句schedule"></a> 线程调度子句schedule</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> _OPENMP</span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">include</span><span class="meta-string">&lt;omp.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;math.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">function</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> j, start = i * (i + <span class="number">1</span>) / <span class="number">2</span>, finish = start + i;</span><br><span class="line">    <span class="keyword">double</span> return_val = <span class="number">0.0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (j = start; j &lt;= finish; j++) &#123;</span><br><span class="line">        return_val += <span class="built_in">sin</span>(j);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> return_val;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">    <span class="comment">// parallel for只是粗略的使用块分割，如果调用函数与需要时间成正比(function())</span></span><br><span class="line">    <span class="comment">// 这样的分配方式显然不佳。于是我们使用schedule子句实现好的迭代分配</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 下面是对于几种schedule的尝试</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 无调度</span></span><br><span class="line">    <span class="keyword">int</span> thread_count = <span class="built_in">strtol</span>(argv[<span class="number">1</span>], <span class="literal">NULL</span>, <span class="number">10</span>);</span><br><span class="line">    <span class="keyword">double</span> result_sum = <span class="number">0.0</span>;</span><br><span class="line">    <span class="keyword">int</span> n = <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">double</span> start_time = (<span class="keyword">double</span>) <span class="built_in">clock</span>();</span><br><span class="line"><span class="meta">#   <span class="meta-keyword">pragma</span> opt parallel for num_threads(thread_count) \</span></span><br><span class="line"><span class="meta">        reduction(+: result_sum) shared(n)</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        result_sum += <span class="built_in">function</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">double</span> end_time = (<span class="keyword">double</span>) <span class="built_in">clock</span>();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;No schedule, time is %.4lf, result is %.4lf\n&quot;</span>, end_time - start_time, result_sum);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// dynamic调度</span></span><br><span class="line">    result_sum = <span class="number">0.0</span>;</span><br><span class="line">    start_time = (<span class="keyword">double</span>) <span class="built_in">clock</span>();</span><br><span class="line">    <span class="meta">#   <span class="meta-keyword">pragma</span> opt parallel for num_threads(thread_count) \</span></span><br><span class="line"><span class="meta">        reduction(+: result_sum) shared(n) schedule(dynamic)</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        result_sum += <span class="built_in">function</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">     end_time = (<span class="keyword">double</span>) <span class="built_in">clock</span>();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Dynamic schedule, time is %.4lf, result is %.4lf\n&quot;</span>, end_time - start_time, result_sum);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// guided调度</span></span><br><span class="line">    result_sum = <span class="number">0.0</span>;</span><br><span class="line">    start_time = (<span class="keyword">double</span>) <span class="built_in">clock</span>();</span><br><span class="line">    <span class="meta">#   <span class="meta-keyword">pragma</span> opt parallel for num_threads(thread_count) \</span></span><br><span class="line"><span class="meta">        reduction(+: result_sum) shared(n) schedule(guided)</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        result_sum += <span class="built_in">function</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">     end_time = (<span class="keyword">double</span>) <span class="built_in">clock</span>();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Guided schedule, time is %.4lf, result is %.4lf\n&quot;</span>, end_time - start_time, result_sum);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// runtime调度</span></span><br><span class="line">    result_sum = <span class="number">0.0</span>;</span><br><span class="line">    start_time = (<span class="keyword">double</span>) <span class="built_in">clock</span>();</span><br><span class="line">    <span class="meta">#   <span class="meta-keyword">pragma</span> opt parallel for num_threads(thread_count) \</span></span><br><span class="line"><span class="meta">        reduction(+: result_sum) shared(n) schedule(runtime)</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        result_sum += <span class="built_in">function</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">     end_time = (<span class="keyword">double</span>) <span class="built_in">clock</span>();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Runtime schedule, time is %.4lf, result is %.4lf\n&quot;</span>, end_time - start_time, result_sum);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 自动调度</span></span><br><span class="line">    result_sum = <span class="number">0.0</span>;</span><br><span class="line">    start_time = (<span class="keyword">double</span>) <span class="built_in">clock</span>();</span><br><span class="line">    <span class="meta">#   <span class="meta-keyword">pragma</span> opt parallel for num_threads(thread_count) \</span></span><br><span class="line"><span class="meta">        reduction(+: result_sum) shared(n) schedule(auto)</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        result_sum += <span class="built_in">function</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">     end_time = (<span class="keyword">double</span>) <span class="built_in">clock</span>();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Auto schedule, time is %.4lf, result is %.4lf\n&quot;</span>, end_time - start_time, result_sum);</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// eg. 三个线程，12个任务</span></span><br><span class="line"><span class="comment">// 调度方式：</span></span><br><span class="line"><span class="comment">// 1. static: 以轮转方式分配chunksize个线程给每个线程（chunksize 默认近似为total_iterations / thread_count)</span></span><br><span class="line"><span class="comment">// chunksize = 2</span></span><br><span class="line"><span class="comment">// Thread0: 0 1 6 7</span></span><br><span class="line"><span class="comment">// Thread1: 2 3 8 9</span></span><br><span class="line"><span class="comment">// Thread2: 4 5 10 11</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. dynamic: 迭代被分为chunksize个连续块，每个线程执行一块，执行完再向系统申请(chunksize默认为1)</span></span><br><span class="line"><span class="comment">// 3. guided: 类似于dynamic, 每个线程执行完一块后，向系统请求另一块，但是新块会变小</span></span><br><span class="line"><span class="comment">// guided如下图</span></span><br><span class="line"><span class="comment">// 4. runtime: 需要自己配置环境变量指定</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 调度选择</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    系统开销: guided &gt; dynamic &gt; static</span></span><br><span class="line"><span class="comment">    1. 如果每次迭代计算量几乎相同，默认调度方式性能最好</span></span><br><span class="line"><span class="comment">    2. 若计算量线性递增或递减，采用比较小的chunksize的static比较好</span></span><br><span class="line"><span class="comment">    3. 如果每次迭代事先不确定，需要进行调参，可以通过配置环境变量来比较不同调度策略下性能</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p><img src="/image/openmp/1.png" alt="1" /></p><h2 id="小结"><a class="markdownIt-Anchor" href="#小结"></a> 小结</h2><p><img src="/image/openmp/2.png" alt="1" /></p><p><img src="/image/openmp/3.png" alt="1" /></p><p><img src="/image/openmp/4.png" alt="1" /></p><p><img src="/image/openmp/5.png" alt="1" /></p><p><img src="/image/openmp/6.png" alt="1" /></p>]]></content>
    
    
    <summary type="html">高性能计算的编程基础，基于C++语言，入门HPC的第一站。</summary>
    
    
    
    <category term="CS" scheme="http://aflyingsheep.github.io/categories/CS/"/>
    
    <category term="HPC" scheme="http://aflyingsheep.github.io/categories/HPC/"/>
    
    
    <category term="HPC" scheme="http://aflyingsheep.github.io/tags/HPC/"/>
    
  </entry>
  
  <entry>
    <title>中位数问题（对顶堆的应用）</title>
    <link href="http://aflyingsheep.github.io/2022/06/30/algorithm/median_problem(for_top_stack)/"/>
    <id>http://aflyingsheep.github.io/2022/06/30/algorithm/median_problem(for_top_stack)/</id>
    <published>2022-06-30T07:49:03.000Z</published>
    <updated>2023-02-11T13:44:25.556Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="leetcode295-数据流的中位数"><a class="markdownIt-Anchor" href="#leetcode295-数据流的中位数"></a> Leetcode295. 数据流的中位数</h1><ul><li>设计一个支持以下两种操作的数据结构：<ul><li>void addNum(int num) - 从数据流中添加一个整数到数据结构中。</li><li>double findMedian() - 返回目前所有元素的中位数。</li></ul></li><li>设计思路：维护两个堆：左侧大顶堆，用于维护比中位数小的元素；右侧小顶堆，用于维护比中位数大的元素；平均值：当两堆元素个数相同，则中位数为堆顶元素平均值；不同时为左侧大顶堆的堆顶值。插入元素时，两堆元素同样多则插入到左侧大顶堆（先插入右侧，弹出堆顶再插入左侧），不同时左侧多，插入到左侧弹出堆顶再插入到右侧。</li><li><strong>注，less是大顶堆，greater是小顶堆！！！</strong></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MedianFinder</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 维护大顶堆、小顶堆</span></span><br><span class="line">    priority_queue&lt;<span class="keyword">int</span>, vector&lt;<span class="keyword">int</span>&gt;, less&lt;<span class="keyword">int</span>&gt;&gt; p1;</span><br><span class="line">    priority_queue&lt;<span class="keyword">int</span>, vector&lt;<span class="keyword">int</span>&gt;, greater&lt;<span class="keyword">int</span>&gt;&gt; p2;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">MedianFinder</span>() &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addNum</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (p1.<span class="built_in">empty</span>()) p1.<span class="built_in">push</span>(num);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (p1.<span class="built_in">size</span>() == p2.<span class="built_in">size</span>()) &#123;</span><br><span class="line">                p2.<span class="built_in">push</span>(num);</span><br><span class="line">                <span class="keyword">int</span> x = p2.<span class="built_in">top</span>();</span><br><span class="line">                p2.<span class="built_in">pop</span>();</span><br><span class="line">                p1.<span class="built_in">push</span>(x);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                p1.<span class="built_in">push</span>(num);</span><br><span class="line">                <span class="keyword">int</span> x = p1.<span class="built_in">top</span>();</span><br><span class="line">                p1.<span class="built_in">pop</span>();</span><br><span class="line">                p2.<span class="built_in">push</span>(x);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">findMedian</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (p1.<span class="built_in">size</span>() == p2.<span class="built_in">size</span>()) <span class="keyword">return</span> (p1.<span class="built_in">top</span>() + p2.<span class="built_in">top</span>()) * <span class="number">1.0</span> / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> p1.<span class="built_in">top</span>() * <span class="number">1.0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="leetcode480-滑动窗口中位数"><a class="markdownIt-Anchor" href="#leetcode480-滑动窗口中位数"></a> Leetcode480. 滑动窗口中位数</h1><ul><li><p>给你一个数组 nums，有一个长度为 k 的窗口从最左端滑动到最右端。窗口中有 k 个数，每次窗口向右移动 1 位。你的任务是找出每次窗口移动后得到的新窗口中元素的中位数，并输出由它们组成的数组。</p></li><li><p>思路：对顶堆+延迟删除</p></li><li><p>具体讲解见<a href="https://leetcode.cn/problems/sliding-window-median/solution/hua-dong-chuang-kou-zhong-wei-shu-by-lee-7ai6/">滑动窗口中位数 - 滑动窗口中位数 - 力扣（LeetCode）</a></p></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DualHeap</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 大根堆，维护较小的一半元素</span></span><br><span class="line">    priority_queue&lt;<span class="keyword">int</span>&gt; small;</span><br><span class="line">    <span class="comment">// 小根堆，维护较大的一半元素</span></span><br><span class="line">    priority_queue&lt;<span class="keyword">int</span>, vector&lt;<span class="keyword">int</span>&gt;, greater&lt;<span class="keyword">int</span>&gt;&gt; large;</span><br><span class="line">    <span class="comment">// 哈希表，记录「延迟删除」的元素，key 为元素，value 为需要删除的次数</span></span><br><span class="line">    unordered_map&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; delayed;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> k;</span><br><span class="line">    <span class="comment">// small 和 large 当前包含的元素个数，需要扣除被「延迟删除」的元素</span></span><br><span class="line">    <span class="keyword">int</span> smallSize, largeSize;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">DualHeap</span>(<span class="keyword">int</span> _k): <span class="built_in">k</span>(_k), <span class="built_in">smallSize</span>(<span class="number">0</span>), <span class="built_in">largeSize</span>(<span class="number">0</span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 不断地弹出 heap 的堆顶元素，并且更新哈希表</span></span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function">    <span class="keyword">void</span> <span class="title">prune</span><span class="params">(T&amp; heap)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (!heap.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="keyword">int</span> num = heap.<span class="built_in">top</span>();</span><br><span class="line">            <span class="keyword">if</span> (delayed.<span class="built_in">count</span>(num)) &#123;</span><br><span class="line">                --delayed[num];</span><br><span class="line">                <span class="keyword">if</span> (!delayed[num]) &#123;</span><br><span class="line">                    delayed.<span class="built_in">erase</span>(num);</span><br><span class="line">                &#125;</span><br><span class="line">                heap.<span class="built_in">pop</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调整 small 和 large 中的元素个数，使得二者的元素个数满足要求</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">makeBalance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (smallSize &gt; largeSize + <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">// small 比 large 元素多 2 个</span></span><br><span class="line">            large.<span class="built_in">push</span>(small.<span class="built_in">top</span>());</span><br><span class="line">            small.<span class="built_in">pop</span>();</span><br><span class="line">            --smallSize;</span><br><span class="line">            ++largeSize;</span><br><span class="line">            <span class="comment">// small 堆顶元素被移除，需要进行 prune</span></span><br><span class="line">            <span class="built_in">prune</span>(small);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (smallSize &lt; largeSize) &#123;</span><br><span class="line">            <span class="comment">// large 比 small 元素多 1 个</span></span><br><span class="line">            small.<span class="built_in">push</span>(large.<span class="built_in">top</span>());</span><br><span class="line">            large.<span class="built_in">pop</span>();</span><br><span class="line">            ++smallSize;</span><br><span class="line">            --largeSize;</span><br><span class="line">            <span class="comment">// large 堆顶元素被移除，需要进行 prune</span></span><br><span class="line">            <span class="built_in">prune</span>(large);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (small.<span class="built_in">empty</span>() || num &lt;= small.<span class="built_in">top</span>()) &#123;</span><br><span class="line">            small.<span class="built_in">push</span>(num);</span><br><span class="line">            ++smallSize;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            large.<span class="built_in">push</span>(num);</span><br><span class="line">            ++largeSize;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">makeBalance</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">erase</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        ++delayed[num];</span><br><span class="line">        <span class="keyword">if</span> (num &lt;= small.<span class="built_in">top</span>()) &#123;</span><br><span class="line">            --smallSize;</span><br><span class="line">            <span class="keyword">if</span> (num == small.<span class="built_in">top</span>()) &#123;</span><br><span class="line">                <span class="built_in">prune</span>(small);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            --largeSize;</span><br><span class="line">            <span class="keyword">if</span> (num == large.<span class="built_in">top</span>()) &#123;</span><br><span class="line">                <span class="built_in">prune</span>(large);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">makeBalance</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">getMedian</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> k &amp; <span class="number">1</span> ? small.<span class="built_in">top</span>() : ((<span class="keyword">double</span>)small.<span class="built_in">top</span>() + large.<span class="built_in">top</span>()) / <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">double</span>&gt; <span class="title">medianSlidingWindow</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="function">DualHeap <span class="title">dh</span><span class="params">(k)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; ++i) &#123;</span><br><span class="line">            dh.<span class="built_in">insert</span>(nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        vector&lt;<span class="keyword">double</span>&gt; ans = &#123;dh.<span class="built_in">getMedian</span>()&#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = k; i &lt; nums.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            dh.<span class="built_in">insert</span>(nums[i]);</span><br><span class="line">            dh.<span class="built_in">erase</span>(nums[i - k]);</span><br><span class="line">            ans.<span class="built_in">push_back</span>(dh.<span class="built_in">getMedian</span>());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">关于新建可以get中位数的数据结构，和滑动窗口中的中位数问题，均用两个堆实现。</summary>
    
    
    
    <category term="Algorithm" scheme="http://aflyingsheep.github.io/categories/Algorithm/"/>
    
    
    <category term="Algorithm" scheme="http://aflyingsheep.github.io/tags/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>编译原理</title>
    <link href="http://aflyingsheep.github.io/2022/06/24/Review%20notes/compilation_principle/"/>
    <id>http://aflyingsheep.github.io/2022/06/24/Review%20notes/compilation_principle/</id>
    <published>2022-06-24T11:36:08.000Z</published>
    <updated>2023-02-11T13:28:32.024Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="文法和语言"><a class="markdownIt-Anchor" href="#文法和语言"></a> 文法和语言</h1><h2 id="文法的引入"><a class="markdownIt-Anchor" href="#文法的引入"></a> 文法的引入</h2><ol><li><p>终结符<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>V</mi><mi>T</mi></msub></mrow><annotation encoding="application/x-tex">V_T</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.22222em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.13889em;">T</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>，非终结符<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>V</mi><mi>N</mi></msub></mrow><annotation encoding="application/x-tex">V_N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.22222em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.10903em;">N</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>，语法规则<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>P</mi></mrow><annotation encoding="application/x-tex">P</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span></span></span></span>，开始符号<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>S</mi></mrow><annotation encoding="application/x-tex">S</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span></span></span></span></p></li><li><p>文法的EBNF表示：采用特殊的符号表示文法：</p><img src="/image/Compile/image-20220623115125197.png" alt="image-20220623115125197" style="zoom:50%;" /><p>如：&lt;无符号整数&gt;→{&lt;数字&gt;}<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msubsup><mrow></mrow><mn>1</mn><mn>3</mn></msubsup></mrow><annotation encoding="application/x-tex">_1^3</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0622159999999998em;vertical-align:-0.24810799999999997em;"></span><span class="mord"><span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-2.4518920000000004em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.24810799999999997em;"><span></span></span></span></span></span></span></span></span></span>与&lt;无符号整数&gt;→&lt;数字&gt;|&lt;数字&gt;&lt;数字&gt;|&lt;数字&gt;&lt;数字&gt;&lt;数字&gt;相同。</p></li></ol><h2 id="字母表和符号串"><a class="markdownIt-Anchor" href="#字母表和符号串"></a> 字母表和符号串</h2><ol><li>字母表<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">Σ</mi></mrow><annotation encoding="application/x-tex">\Sigma</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord">Σ</span></span></span></span>：元素的<strong>非空有穷</strong>集合。字母表每个元素称为符号。</li><li>符号串：由字母表上0个或多个符号组成的任何有穷序列。</li><li>空串：不包含任何符号的串，记作<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ε</mi></mrow><annotation encoding="application/x-tex">\varepsilon</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">ε</span></span></span></span></li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">Σ</mi></mrow><annotation encoding="application/x-tex">\Sigma</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord">Σ</span></span></span></span>上全部有穷长符号串的集合记作<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi mathvariant="normal">Σ</mi><mo>∗</mo></msup></mrow><annotation encoding="application/x-tex">\Sigma^*</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.688696em;vertical-align:0em;"></span><span class="mord"><span class="mord">Σ</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.688696em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">∗</span></span></span></span></span></span></span></span></span></span></span></li><li>集合的乘积运算</li><li>符号串的幂运算：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>x</mi><mn>0</mn></msup><mo>=</mo><mi>ε</mi><mo separator="true">,</mo><msup><mi>x</mi><mn>1</mn></msup><mo>=</mo><mi>x</mi><mo separator="true">,</mo><msup><mi>x</mi><mn>2</mn></msup><mo>=</mo><mi>x</mi><mi>x</mi><mo separator="true">,</mo><mo>…</mo></mrow><annotation encoding="application/x-tex">x^0=\varepsilon,x^1=x,x^2=xx,\dots</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.008548em;vertical-align:-0.19444em;"></span><span class="mord mathnormal">ε</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.008548em;vertical-align:-0.19444em;"></span><span class="mord mathnormal">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathnormal">x</span><span class="mord mathnormal">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner">…</span></span></span></span></li><li>正闭包<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>A</mi><mo>+</mo></msup><mo>=</mo><msup><mi>A</mi><mn>1</mn></msup><mo>∪</mo><msup><mi>A</mi><mn>2</mn></msup><mo>∪</mo><mo>⋯</mo><mo>∪</mo><msup><mi>A</mi><mi>n</mi></msup><mo>∪</mo><mo>…</mo></mrow><annotation encoding="application/x-tex">A^+=A^1\cup A^2\cup\dots\cup A^n\cup\dots</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.771331em;vertical-align:0em;"></span><span class="mord"><span class="mord mathnormal">A</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.771331em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">+</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord mathnormal">A</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∪</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord mathnormal">A</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∪</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.55556em;vertical-align:0em;"></span><span class="minner">⋯</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∪</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord"><span class="mord mathnormal">A</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∪</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.12em;vertical-align:0em;"></span><span class="minner">…</span></span></span></span></li><li>闭包<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>A</mi><mo>∗</mo></msup><mo>=</mo><msup><mi>A</mi><mn>0</mn></msup><mo>∪</mo><msup><mi>A</mi><mo>+</mo></msup></mrow><annotation encoding="application/x-tex">A^*=A^0\cup A^+</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.688696em;vertical-align:0em;"></span><span class="mord"><span class="mord mathnormal">A</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.688696em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">∗</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord mathnormal">A</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∪</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.771331em;vertical-align:0em;"></span><span class="mord"><span class="mord mathnormal">A</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.771331em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">+</span></span></span></span></span></span></span></span></span></span></span></li></ol><h2 id="文法和语言的形式定义"><a class="markdownIt-Anchor" href="#文法和语言的形式定义"></a> 文法和语言的形式定义</h2><ol><li><p>文法G为一个四元组<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>G</mi><mo>=</mo><mo stretchy="false">(</mo><msub><mi>V</mi><mi>N</mi></msub><mo separator="true">,</mo><msub><mi>V</mi><mi>T</mi></msub><mo separator="true">,</mo><mi>P</mi><mo separator="true">,</mo><mi>S</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">G=(V_N,V_T,P,S)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal">G</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.22222em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.10903em;">N</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.22222em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.13889em;">T</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="mclose">)</span></span></span></span></p></li><li><p>句型：若<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>S</mi><msup><mo>⇒</mo><mo>∗</mo></msup><mi>x</mi></mrow><annotation encoding="application/x-tex">S\Rightarrow^*x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.688696em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel"><span class="mrel">⇒</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.688696em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">∗</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">x</span></span></span></span>，且<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mo>∈</mo><mo stretchy="false">(</mo><msub><mi>V</mi><mi>N</mi></msub><mo>∪</mo><msub><mi>V</mi><mi>T</mi></msub><msup><mo stretchy="false">)</mo><mo>∗</mo></msup></mrow><annotation encoding="application/x-tex">x\in(V_N\cup V_T)^*</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.22222em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.10903em;">N</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∪</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.22222em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.13889em;">T</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.688696em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">∗</span></span></span></span></span></span></span></span></span></span></span>，则称x是文法G的句型。（文法开始符号推导出的任意字符串）</p></li><li><p>句子：仅由终极符组成的句型称为句子。</p></li><li><p>语言L(G)：由文法G的一切句子的集合。</p><p>给定一种文法，唯一确定一种语言；给定一种语言，能确定其文法，但不唯一。</p></li><li><p>若L(G1)=L(G2)，则称两文法等价。</p></li></ol><h2 id="文法和语言分类"><a class="markdownIt-Anchor" href="#文法和语言分类"></a> 文法和语言分类</h2><ol><li><p>0型文法：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>α</mi><mo>→</mo><mi>β</mi><mo separator="true">,</mo><mi>α</mi><mo>∈</mo><msup><mi>V</mi><mo>∗</mo></msup><msub><mi>V</mi><mi>N</mi></msub><msup><mi>V</mi><mo>∗</mo></msup><mo separator="true">,</mo><mi>β</mi><mo>∈</mo><msup><mi>V</mi><mo>∗</mo></msup><mo separator="true">,</mo><mi>V</mi><mo>=</mo><msub><mi>V</mi><mi>N</mi></msub><mo>∪</mo><msub><mi>V</mi><mi>T</mi></msub></mrow><annotation encoding="application/x-tex">\alpha→\beta,\alpha\in V^*V_NV^*,\beta\in V^*,V=V_N\cup V_T</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.0037em;">α</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathnormal" style="margin-right:0.05278em;">β</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.0037em;">α</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.688696em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">∗</span></span></span></span></span></span></span></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.22222em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.10903em;">N</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.688696em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">∗</span></span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.05278em;">β</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8831359999999999em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.688696em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">∗</span></span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.22222em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.10903em;">N</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∪</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.22222em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.13889em;">T</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></p></li><li><p>1型文法（上下文相关文法）：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>α</mi><mi>U</mi><mi>β</mi><mo>→</mo><mi>α</mi><mi>u</mi><mi>β</mi></mrow><annotation encoding="application/x-tex">\alpha U\beta→\alpha u\beta</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathnormal" style="margin-right:0.0037em;">α</span><span class="mord mathnormal" style="margin-right:0.10903em;">U</span><span class="mord mathnormal" style="margin-right:0.05278em;">β</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathnormal" style="margin-right:0.0037em;">α</span><span class="mord mathnormal">u</span><span class="mord mathnormal" style="margin-right:0.05278em;">β</span></span></span></span>，其中<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>U</mi><mo>∈</mo><msub><mi>V</mi><mi>N</mi></msub><mo separator="true">,</mo><mi>α</mi><mo separator="true">,</mo><mi>β</mi><mo>∈</mo><msup><mi>V</mi><mo>∗</mo></msup><mo separator="true">,</mo><mi>u</mi><mo>∈</mo><msup><mi>V</mi><mo>+</mo></msup><mo separator="true">,</mo><mi>V</mi><mo>=</mo><msub><mi>V</mi><mi>N</mi></msub><mo>∪</mo><msub><mi>V</mi><mi>T</mi></msub></mrow><annotation encoding="application/x-tex">U\in V_N,\alpha,\beta\in V^*,u\in V^+,V=V_N\cup V_T</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.72243em;vertical-align:-0.0391em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">U</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.22222em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.10903em;">N</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.0037em;">α</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.05278em;">β</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8831359999999999em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.688696em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">∗</span></span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">u</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.9657709999999999em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.771331em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">+</span></span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.22222em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.10903em;">N</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∪</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.22222em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.13889em;">T</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>，即只有在上下文为ab时，才把U替换为u</p><p>另一等价定义：一个0型文法G中所有产生式<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mo>→</mo><mi>b</mi></mrow><annotation encoding="application/x-tex">a→b</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">a</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal">b</span></span></span></span>都满足如下条件：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">∣</mi><mi>a</mi><mi mathvariant="normal">∣</mi><mo>≤</mo><mi mathvariant="normal">∣</mi><mi>b</mi><mi mathvariant="normal">∣</mi><mo stretchy="false">(</mo><mi>a</mi><mo separator="true">,</mo><mi>b</mi><mo>∈</mo><msup><mi>V</mi><mo>+</mo></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">|a|\le|b|(a,b\in V^+)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">∣</span><span class="mord mathnormal">a</span><span class="mord">∣</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">∣</span><span class="mord mathnormal">b</span><span class="mord">∣</span><span class="mopen">(</span><span class="mord mathnormal">a</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">b</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.021331em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.771331em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">+</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>，则称G为1型文法。</p></li><li><p>2型文法（上下文无关文法）：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mo>→</mo><mi>u</mi><mo separator="true">,</mo><mi>A</mi><mo>∈</mo><msub><mi>V</mi><mi>N</mi></msub><mo separator="true">,</mo><mi>u</mi><mo>∈</mo><msup><mi>V</mi><mo>∗</mo></msup><mo separator="true">,</mo><mi>V</mi><mo>=</mo><msub><mi>V</mi><mi>N</mi></msub><mo>∪</mo><msub><mi>V</mi><mi>T</mi></msub></mrow><annotation encoding="application/x-tex">A→u,A\in V_N,u\in V^*,V=V_N\cup V_T</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal">A</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class="mord mathnormal">u</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">A</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.22222em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.10903em;">N</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">u</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8831359999999999em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.688696em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">∗</span></span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.22222em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.10903em;">N</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∪</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.22222em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.13889em;">T</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></p></li><li><p>3型文法（正则文法）：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>U</mi><mo>→</mo><mi>a</mi></mrow><annotation encoding="application/x-tex">U→a</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">U</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">a</span></span></span></span>或<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>U</mi><mo>→</mo><mi>a</mi><mi>W</mi><mspace width="0.5em"/><mi>U</mi><mo separator="true">,</mo><mi>W</mi><mo>∈</mo><msub><mi>V</mi><mi>N</mi></msub><mo separator="true">,</mo><mi>a</mi><mo>∈</mo><msubsup><mi>V</mi><mi>T</mi><mo>∗</mo></msubsup></mrow><annotation encoding="application/x-tex">U→aW\enspace U,W\in V_N,a\in V_T^*</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">U</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class="mord mathnormal">a</span><span class="mord mathnormal" style="margin-right:0.13889em;">W</span><span class="mspace" style="margin-right:0.5em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">U</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">W</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.22222em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.10903em;">N</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">a</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.964027em;vertical-align:-0.275331em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.688696em;"><span style="top:-2.424669em;margin-left:-0.22222em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.13889em;">T</span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">∗</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.275331em;"><span></span></span></span></span></span></span></span></span></span></p><p>左线性文法和右线性文法都成为线性文法，两者等价。</p></li></ol><h2 id="上下文无关文法及其语法树"><a class="markdownIt-Anchor" href="#上下文无关文法及其语法树"></a> 上下文无关文法及其语法树</h2><ol><li>最左推导：在推导的任何一步都是对α中的最左非终结符进行替换。得到左句型。</li><li>最右推导（归约推导）：在推导的任何一步都是对α中的最右非终结符进行替换。得到右句型（归约句型）</li><li>左分析：由文法开始符号S到句子x的最左推导中所用规则序列。（语法树自顶向下生长，又称自顶向下分析）</li><li>右分析：最右推导的逆序列。（自底向上分析）</li><li>若一个句子无二义性，其各种推到得出的语法树是相同的。</li><li>短语：一棵子树所有叶子从左至右排列起来形成一个相对于子树根的短语。</li><li>直接短语：仅有父子两代的一棵子树的短语。</li><li>句柄：一个句型分析树中<strong>最左最下那棵只有父子两代的子树</strong>所有叶子自左至右排列</li></ol><h2 id="歧义文法及实用文法限制与扩充"><a class="markdownIt-Anchor" href="#歧义文法及实用文法限制与扩充"></a> 歧义文法及实用文法限制与扩充</h2><ol><li>一个文法存在某个句子，对应两棵以上不同的语法树，或两个不同的最左（右）推导，则称文法是歧义文法。</li><li>文法起义不等价于语言歧义。</li><li>简化文法<ol><li>不存在<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>P</mi><mo>→</mo><mi>P</mi><mo separator="true">,</mo><mi>P</mi><mo>∈</mo><msub><mi>V</mi><mi>T</mi></msub></mrow><annotation encoding="application/x-tex">P→P,P\in V_T</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.22222em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.13889em;">T</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></li><li>每个非终结符都是可达和可终止的。</li></ol></li><li>空规则：上下文无关文法中某些规则可具有形式<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mo>→</mo><mi>ε</mi></mrow><annotation encoding="application/x-tex">A→\varepsilon</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal">A</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">ε</span></span></span></span></li></ol><h1 id="词法分析"><a class="markdownIt-Anchor" href="#词法分析"></a> 词法分析</h1><h2 id="单词的描述工具"><a class="markdownIt-Anchor" href="#单词的描述工具"></a> 单词的描述工具</h2><ol><li><p>正规式中的符号</p><img src="/image/Compile/image-20220623145123467.png" alt="image-20220623145123467" style="zoom:50%;" /></li><li><p>对任一正则文法，存在一个定义同一个语言的正规式；每个正规式存在一个生成同一语言的正则文法。</p></li></ol><h2 id="有穷自动机"><a class="markdownIt-Anchor" href="#有穷自动机"></a> 有穷自动机</h2><p>分为确定的有穷自动机（DFA）和不确定的有穷自动机（NFA）。</p><h2 id="有穷自动机和正则文法的等价性"><a class="markdownIt-Anchor" href="#有穷自动机和正则文法的等价性"></a> 有穷自动机和正则文法的等价性</h2><ol><li><p>DFA：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi><mo>=</mo><mo stretchy="false">(</mo><mi>K</mi><mo separator="true">,</mo><mi mathvariant="normal">Σ</mi><mo separator="true">,</mo><mi>f</mi><mo separator="true">,</mo><mi>S</mi><mo separator="true">,</mo><mi>Z</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">M=(K,\Sigma,f,S,Z)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.07153em;">K</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">Σ</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">Z</span><span class="mclose">)</span></span></span></span>，其中K为状态的有穷非空集，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">Σ</mi></mrow><annotation encoding="application/x-tex">\Sigma</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord">Σ</span></span></span></span>为输入字母表，f为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>K</mi><mo>×</mo><mi mathvariant="normal">Σ</mi></mrow><annotation encoding="application/x-tex">K×\Sigma</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.76666em;vertical-align:-0.08333em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">K</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord">Σ</span></span></span></span>到K的一个映射（读入一个符号，转入一个状态），<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>S</mi><mo>∈</mo><mi>K</mi></mrow><annotation encoding="application/x-tex">S\in K</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.72243em;vertical-align:-0.0391em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">K</span></span></span></span>是开始状态，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>Z</mi><mo>⊆</mo><mi>K</mi></mrow><annotation encoding="application/x-tex">Z\subseteq K</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8193em;vertical-align:-0.13597em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">Z</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">⊆</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">K</span></span></span></span>为终止状态集。</p></li><li><p>NFA：任意时刻可属于多个状态，可以有多个开始状态，映射函数的值可以是多个状态或空集。</p></li><li><p>格局运动（表示FA识别正则句子的过程）</p><img src="/image/Compile/image-20220623152347194.png" alt="image-20220623152347194" style="zoom:50%;" /></li><li><p>NFA确定化（带空转换与不带空转换）</p></li><li><p>NFA构造等价正则式</p><ol><li><p>新增两个状态x, y：x为新的初态节点，用<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ε</mi></mrow><annotation encoding="application/x-tex">\varepsilon</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">ε</span></span></span></span>弧连接原来所有初态节点，y为终态节点，同样用<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ε</mi></mrow><annotation encoding="application/x-tex">\varepsilon</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">ε</span></span></span></span>弧连接。</p></li><li><p>转换</p><img src="/image/Compile/image-20220623160555925.png" alt="image-20220623160555925" style="zoom:50%;" /></li><li><p>重复，直到剩x和y</p></li></ol></li><li><p>正则式构造等价的NFA：机械的方法。</p></li></ol><h2 id="dfa最小化"><a class="markdownIt-Anchor" href="#dfa最小化"></a> DFA最小化</h2><p>不断划分，直到DFA没有等价状态。</p><h1 id="自顶向下语法分析"><a class="markdownIt-Anchor" href="#自顶向下语法分析"></a> 自顶向下语法分析</h1><img src="/image/Compile/image-20220623163839485.png" alt="image-20220623163839485" style="zoom:50%;" /><h2 id="自顶向下语法分析概述"><a class="markdownIt-Anchor" href="#自顶向下语法分析概述"></a> 自顶向下语法分析概述</h2><ol><li><p>带回溯的自顶向下语法分析：不断试探、左递归和间接左递归会导致分析过程无法终止。</p></li><li><p>上下文无关文法特性—自嵌入性：一个文法G是自嵌入的，若存在一个非终极符A，有<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><msup><mo>⇒</mo><mo>∗</mo></msup><mi>α</mi><mi>A</mi><mi>β</mi><mspace width="0.5em"/><mi>α</mi><mo separator="true">,</mo><mi>β</mi><mo>∈</mo><msup><mi>V</mi><mo>+</mo></msup></mrow><annotation encoding="application/x-tex">A\Rightarrow^*\alpha A\beta\enspace \alpha,\beta\in V^+</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.688696em;vertical-align:0em;"></span><span class="mord mathnormal">A</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel"><span class="mrel">⇒</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.688696em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">∗</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathnormal" style="margin-right:0.0037em;">α</span><span class="mord mathnormal">A</span><span class="mord mathnormal" style="margin-right:0.05278em;">β</span><span class="mspace" style="margin-right:0.5em;"></span><span class="mord mathnormal" style="margin-right:0.0037em;">α</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.05278em;">β</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.771331em;vertical-align:0em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.771331em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">+</span></span></span></span></span></span></span></span></span></span></span>非空。</p></li><li><p>自顶向下语法分析主要问题：回溯、消除左递归</p></li><li><p>消除回溯方法：每次选择确定，如LL(1)</p></li><li><p>消除左递归方法：</p><ul><li><p>重排规则顺序</p></li><li><p>左递归变为右递归</p><ol><li><p>消除直接左递归：</p><img src="/image/Compile/image-20220623170045720.png" alt="image-20220623170045720" style="zoom:50%;" /></li><li><p>消除间接左递归：代入法，直接带入然后利用消除直接左递归解决。</p></li></ol></li></ul></li></ol><h2 id="ll分析法"><a class="markdownIt-Anchor" href="#ll分析法"></a> LL分析法</h2><ol><li><p>LL(K)的含义：从<strong>左向右</strong>扫描字符串并建立<strong>最左推导</strong>，同一非终极符的不同规则通过向前看K个符号决定。</p></li><li><p>LL(1)文法</p><ol><li>定义1：设G是不带<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ε</mi></mrow><annotation encoding="application/x-tex">\varepsilon</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">ε</span></span></span></span>规则的文法，若对所有<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mo>→</mo><msub><mi>a</mi><mn>1</mn></msub><mi mathvariant="normal">∣</mi><msub><mi>a</mi><mn>2</mn></msub><mi mathvariant="normal">∣</mi><mo>…</mo><mi mathvariant="normal">∣</mi><msub><mi>a</mi><mi>n</mi></msub></mrow><annotation encoding="application/x-tex">A→a_1|a_2|\dots|a_n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal">A</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord">∣</span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord">∣</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner">…</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">∣</span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>的规则，有<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>F</mi><mi>I</mi><mi>R</mi><mi>S</mi><mi>T</mi><mo stretchy="false">(</mo><msub><mi>a</mi><mi>i</mi></msub><mo stretchy="false">)</mo><mo>∩</mo><mi>F</mi><mi>I</mi><mi>R</mi><mi>S</mi><mi>T</mi><mo stretchy="false">(</mo><msub><mi>a</mi><mi>j</mi></msub><mo stretchy="false">)</mo><mo>=</mo><mi>ϕ</mi></mrow><annotation encoding="application/x-tex">FIRST(a_i)\cap FIRST(a_j)=\phi</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mord mathnormal" style="margin-right:0.07847em;">I</span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∩</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.036108em;vertical-align:-0.286108em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mord mathnormal" style="margin-right:0.07847em;">I</span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathnormal">ϕ</span></span></span></span>，则G为LL(1)文法。</li><li>定义2：一个文法G是LL(1)文法，当且仅当对文法中形如<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mo>→</mo><msub><mi>a</mi><mn>1</mn></msub><mi mathvariant="normal">∣</mi><msub><mi>a</mi><mn>2</mn></msub><mi mathvariant="normal">∣</mi><mo>…</mo><mi mathvariant="normal">∣</mi><msub><mi>a</mi><mi>n</mi></msub></mrow><annotation encoding="application/x-tex">A→a_1|a_2|\dots|a_n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal">A</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord">∣</span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord">∣</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner">…</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">∣</span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>都满足LL(1)条件，即<ol><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>F</mi><mi>I</mi><mi>R</mi><mi>S</mi><mi>T</mi><mo stretchy="false">(</mo><msub><mi>a</mi><mi>i</mi></msub><mo stretchy="false">)</mo><mo>∩</mo><mi>F</mi><mi>I</mi><mi>R</mi><mi>S</mi><mi>T</mi><mo stretchy="false">(</mo><msub><mi>a</mi><mi>j</mi></msub><mo stretchy="false">)</mo><mo>=</mo><mi>ϕ</mi><mo separator="true">,</mo><mi>i</mi><mo mathvariant="normal">≠</mo><mi>j</mi></mrow><annotation encoding="application/x-tex">FIRST(a_i)\cap FIRST(a_j)=\phi,i\ne j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mord mathnormal" style="margin-right:0.07847em;">I</span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∩</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.036108em;vertical-align:-0.286108em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mord mathnormal" style="margin-right:0.07847em;">I</span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathnormal">ϕ</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel"><span class="mrel"><span class="mord vbox"><span class="thinbox"><span class="rlap"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="inner"><span class="mrel"></span></span><span class="fix"></span></span></span></span></span><span class="mrel">=</span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span></span></span></span></li><li>如果<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>a</mi><mi>i</mi></msub><msup><mo>⇒</mo><mo>∗</mo></msup><mi>ε</mi></mrow><annotation encoding="application/x-tex">a_i\Rightarrow^*\varepsilon</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.838696em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel"><span class="mrel">⇒</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.688696em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">∗</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">ε</span></span></span></span>，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>F</mi><mi>I</mi><mi>R</mi><mi>S</mi><mi>T</mi><mo stretchy="false">(</mo><msub><mi>a</mi><mi>j</mi></msub><mo stretchy="false">)</mo><mo>∩</mo><mi>F</mi><mi>O</mi><mi>L</mi><mi>L</mi><mi>O</mi><mi>W</mi><mo stretchy="false">(</mo><mi>A</mi><mo stretchy="false">)</mo><mo>=</mo><mi>ϕ</mi><mo separator="true">,</mo><mi>i</mi><mo mathvariant="normal">≠</mo><mi>j</mi></mrow><annotation encoding="application/x-tex">FIRST(a_j)\cap FOLLOW(A)=\phi,i\ne j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.036108em;vertical-align:-0.286108em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mord mathnormal" style="margin-right:0.07847em;">I</span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∩</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mord mathnormal">L</span><span class="mord mathnormal">L</span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mord mathnormal" style="margin-right:0.13889em;">W</span><span class="mopen">(</span><span class="mord mathnormal">A</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathnormal">ϕ</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel"><span class="mrel"><span class="mord vbox"><span class="thinbox"><span class="rlap"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="inner"><span class="mrel"></span></span><span class="fix"></span></span></span></span></span><span class="mrel">=</span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span></span></span></span></li></ol></li><li>对于相同左部的产生式，如果其SELECT集有交叉，则不为LL(1)文法。</li></ol></li><li><p>文法的变换：将非LL(1)文法转换为LL(1)文法</p><ol><li>左递归文法的变换，消除左递归</li><li>提取左公共因子变换</li><li>角替换：一规则右部的最左出现称位规则的角，对非终极符的角，用其规则右部替换。</li></ol></li><li><p>LL(1)分析器</p><img src="/image/Compile/image-20220624144442720.png" alt="image-20220624144442720" style="zoom:50%;" /></li></ol><h2 id="递归子程序法"><a class="markdownIt-Anchor" href="#递归子程序法"></a> 递归子程序法</h2><p>根据产生式各候选式的结构，为其编写递归函数。是一种<strong>确定的自顶向下的语法分析方法</strong>。</p><p>约定：文法必须为LL(1)文法。</p><h1 id="自底向上语法分析lr分析"><a class="markdownIt-Anchor" href="#自底向上语法分析lr分析"></a> 自底向上语法分析&amp;LR分析</h1><h2 id="自底向上语法分析"><a class="markdownIt-Anchor" href="#自底向上语法分析"></a> 自底向上语法分析</h2><ol><li>归约推导就是右推导，得到的句型是归约句型；归约归约是最左归约，是归约推导的逆过程，每次都对句柄归约成相应的非终结符号。</li><li>过程：对输入串压栈，栈顶符号串形成句柄则进行归约；最后栈中只剩开始符号则句子合法。</li><li>LR分析程序的实质：分析表+DFA</li><li>LR分析法无需消除左递归，也无需消除左公共因子。</li></ol><h2 id="lr分析器概述"><a class="markdownIt-Anchor" href="#lr分析器概述"></a> LR分析器概述</h2><ol><li>LR分析器组成：总控程序、分析表、分析栈<ul><li>分析表：动作表（状态S遇到输入符号a的动作）、状态转换表（状态S遇到<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>X</mi><mo>∈</mo><msub><mi>V</mi><mi>N</mi></msub></mrow><annotation encoding="application/x-tex">X\in V_N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.72243em;vertical-align:-0.0391em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.22222em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.10903em;">N</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>应进入的下一状态）</li><li>分析栈：文法符号栈、状态栈</li></ul></li><li>工作原理：任一时刻由栈顶状态和当前输入符号决定下一步动作。</li></ol><h2 id="lr0分析法"><a class="markdownIt-Anchor" href="#lr0分析法"></a> LR(0)分析法</h2><ol><li><p>拓广文法：在原文法的基础上，引入新的开始符号使得新的开始符号为单一规则的左部。</p></li><li><p>活前缀和可归前缀：</p><img src="/image/Compile/image-20220624155750848.png" alt="image-20220624155750848" style="zoom:50%;" /></li><li><p>并非所有句型都是规范句型，在CFG中，每个句子都有规范推导，但每个句型不一定具有规范推导。（比如非规范推导得出来的句型）</p></li><li><p>LR(0)项目类型：</p><img src="/image/Compile/image-20220624161418936.png" alt="image-20220624161418936" style="zoom:50%;" /></li><li><p>直接构造识别活前缀的DFA：把拓广文法的第一个项目作为初始状态集的核，通过求核的闭包核转换函数，求出LR(0)项目集规范族，可直接构造识别活前缀的DFA。</p></li><li><p>LR(0)文法存在冲突的项目集：</p><ol><li>移进—归约冲突</li><li>归约—归约冲突</li></ol><p><strong>注，在增广文法第一个项目中识别#的归约与其他移进不冲突。</strong></p></li><li><p>LR(0)文法定义：若一个文法的LR(0)项目集规范族不存在含移进归约和归约归约冲突的项目集，则成为LR(0)文法。</p></li></ol><h2 id="slr1分析法"><a class="markdownIt-Anchor" href="#slr1分析法"></a> SLR(1)分析法</h2><p>当不是LR(0)文法时，通过向前查看一个输入符号来协助解决冲突的分析方法，称位SLR(1)分析法。</p><ol><li><p>冲突解决：当对某句柄进行规约时，根据句柄后面符号判断规约是否正确。后面符号可由句柄对应的非终极符的Follow集求得。</p><img src="/image/Compile/image-20220624164218399.png" alt="image-20220624164218399" style="zoom:50%;" /></li><li><p>核心思想：在不是LR(0)的项目集中，对于冲突的位置判断冲突是否可以解决，即看Follow集，如能解决则为SLR(1)文法。</p></li></ol><h1 id="语法制导翻译和中间代码生成"><a class="markdownIt-Anchor" href="#语法制导翻译和中间代码生成"></a> 语法制导翻译和中间代码生成</h1><h2 id="语法制导翻译"><a class="markdownIt-Anchor" href="#语法制导翻译"></a> 语法制导翻译</h2><ol><li><p>在语法分析中，根据每个产生式所对应的语义子程序进行翻译的方法。描述语义动作时，需要赋予每个文法符号X(<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>V</mi><mi>T</mi></msub></mrow><annotation encoding="application/x-tex">V_T</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.22222em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.13889em;">T</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>和<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>V</mi><mi>N</mi></msub></mrow><annotation encoding="application/x-tex">V_N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.22222em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.10903em;">N</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>)以不同的值，统称为属性值。</p><p>属性分为综合属性和继承属性。</p></li><li><p>综合属性：从其子结点的综合属性值计算得来，用于自下而上信息传递</p></li><li><p>继承属性：由语法树中该结点的父结点和位于其左边的兄弟节点的属性值计算出来，用于自上而下传递信息。</p><ul><li>非终结符即可有综合属性也可由继承属性，但文法开始符号没有继承属性。</li><li>终结符只有综合属性，由词法分析程序提供。</li></ul></li><li><p>例：类型定义的语法制导定义</p><img src="/image/Compile/image-20220624182733725.png" alt="image-20220624182733725" style="zoom:50%;" /><p>例：生成变量说明的文法</p><img src="/image/Compile/image-20220624183145932.png" alt="image-20220624183145932" style="zoom:50%;" /></li></ol><h2 id="属性文法"><a class="markdownIt-Anchor" href="#属性文法"></a> 属性文法</h2><ol><li><p>属性文法是一个三元组<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mo>=</mo><mo stretchy="false">(</mo><mi>G</mi><mo separator="true">,</mo><mi>V</mi><mo separator="true">,</mo><mi>F</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">A=(G,V,F)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal">A</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal">G</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mclose">)</span></span></span></span>，其中：G是一个上下文无关文法；V是有穷的属性集；F关于属性的断言或一组属性的计算规则。例：</p><img src="/image/Compile/image-20220624183931114.png" alt="image-20220624183931114" style="zoom:50%;" /></li><li><p>对声明语句的文法进行改写：</p><img src="/image/Compile/image-20220624184847943.png" alt="image-20220624184847943" style="zoom:50%;" /><p>翻译文法如下：</p><img src="/image/Compile/image-20220624184916646.png" alt="image-20220624184916646" style="zoom:50%;" /><p>从文法上来看，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">@</mi><mi>S</mi><mi>E</mi><mi>T</mi><mi mathvariant="normal">_</mi><mi>T</mi><mi>Y</mi><mi>P</mi><mi>E</mi></mrow><annotation encoding="application/x-tex">@SET\_TYPE</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.00444em;vertical-align:-0.31em;"></span><span class="mord">@</span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="mord mathnormal" style="margin-right:0.05764em;">E</span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="mord" style="margin-right:0.02778em;">_</span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="mord mathnormal" style="margin-right:0.22222em;">Y</span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mord mathnormal" style="margin-right:0.05764em;">E</span></span></span></span>应有两个属性：Type和ID</p><img src="/image/Compile/image-20220624185019928.png" alt="image-20220624185019928" style="zoom:50%;" /><img src="/image/Compile/image-20220624185040175.png" alt="image-20220624185040175" style="zoom:50%;" /></li><li><p>属性文法的求值规则：当翻译文法的符号具有属性，并带有属性求职规则时，就成为属性文法。求值规则定义如下：</p><ol><li><p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>V</mi><mi>T</mi></msub><mo separator="true">,</mo><msub><mi>V</mi><mi>N</mi></msub><mo separator="true">,</mo></mrow><annotation encoding="application/x-tex">V_T,V_N,</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.22222em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.13889em;">T</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.22222em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.10903em;">N</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span></span></span></span>动作符号都可以有一个有穷的属性集</p></li><li><p>每个非终结符和动作符号的属性类型可分为综合属性和继承属性</p></li><li><p>继承属性求值规则</p><ol><li>产生式左部的非终结符，继承属性继承前面产生式该符号已有的继承属性值</li><li>产生式右部的符号，继承属性由产生式其他符号属性值进行计算。</li></ol></li><li><p>综合属性求职规则</p><ol><li>终结符号综合属性具有指定初始值，由词法分析提供。</li><li>产生式右部非终结符号综合属性值取自后面以该非终结符号为产生式左部时求得的综合属性</li><li>产生式左部非终结符号综合属性由产生式中左或右部某些符合属性值计算得到</li></ol></li></ol></li></ol><h2 id="s-属性文法的自底向上翻译"><a class="markdownIt-Anchor" href="#s-属性文法的自底向上翻译"></a> S-属性文法的自底向上翻译</h2><ol><li><p>文法符号仅使用综合属性的语法制导翻译称位S-属性定义。其翻译器可以借助LR语法分析器及生成器来实现。增加值栈（属性栈）用来存放综合属性值，即保存已经分析过的子树信息。</p></li><li><p>LR分析器分析S属性文法（对于移进、规约进行属性栈的扩充）</p><img src="/image/Compile/image-20220624190358518.png" alt="image-20220624190358518" style="zoom:50%;" /><img src="/image/Compile/image-20220624190410539.png" alt="image-20220624190410539" style="zoom:50%;" /></li></ol><h2 id="l-属性文法的自顶向下翻译"><a class="markdownIt-Anchor" href="#l-属性文法的自顶向下翻译"></a> L-属性文法的自顶向下翻译</h2><ol><li>一个语法制导定义是L-属性定义，如果对于属性文法中的任意产生式<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mo>→</mo><msub><mi>X</mi><mn>1</mn></msub><msub><mi>X</mi><mn>2</mn></msub><mo>…</mo><msub><mi>X</mi><mi>i</mi></msub><mo>…</mo><msub><mi>X</mi><mi>n</mi></msub></mrow><annotation encoding="application/x-tex">A→X_1X_2\dots X_i\dots X_n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal">A</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.07847em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.07847em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner">…</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.07847em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner">…</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.07847em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>，其每个语言规则每个属性都是<strong>综合属性</strong>，或是<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>X</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">X_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.07847em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>的一个继承属性，这一继承属性只依赖A的<strong>继承属性</strong>和<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>X</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">X_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.07847em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>的左面符号的属性。</li></ol><h2 id="中间代码形式"><a class="markdownIt-Anchor" href="#中间代码形式"></a> 中间代码形式</h2><ol><li>逆波兰表达式（后缀式）</li><li>三元式格式：OP, OP1, OP2。不必考虑临时变量的分配</li><li>树形表示（三元式的翻版，运算符为根，中序遍历为原表达式）</li><li>间接三元式</li><li><strong>四元式</strong>：OP, OP1, OP2, RESULT</li></ol><h2 id="语句翻译"><a class="markdownIt-Anchor" href="#语句翻译"></a> 语句翻译</h2><ol><li>赋值语句的翻译</li><li>布尔表达式翻译：回填拉链法</li><li>控制语句的翻译</li></ol><h1 id="符号表"><a class="markdownIt-Anchor" href="#符号表"></a> 符号表</h1><ol><li>符号表的作用<ol><li>保存各类标识符的属性</li><li>检查语义的正确性（先定义后使用、实参形参个数等）</li><li>作为目标代码生成阶段地址分配的依据</li></ol></li><li>建立和访问符号表的时机<ol><li>词法分析创建，只含有标识符名字，其他属性在语义分析阶段填入</li><li>语义分析时创建</li><li>语法分析阶段只检查源程序语法正确性，一般不适用符号表。</li></ol></li><li>符号表的组织和内容<ol><li>名字域</li><li>属性域</li><li>目标地址、类型、维数及参数个数</li></ol></li></ol><h1 id="目标程序运行时的存储组织"><a class="markdownIt-Anchor" href="#目标程序运行时的存储组织"></a> 目标程序运行时的存储组织</h1><h2 id="程序运行时的存储组织"><a class="markdownIt-Anchor" href="#程序运行时的存储组织"></a> 程序运行时的存储组织</h2><ol><li><p>从用途上来看，可以分为：目标代码区（存放目标代码）、静态数据区（存放编译时确定存储空间的数据）、运行栈区（用来存放运行时确定存储空间的数据）、运行堆区（用来存放运行时用户动态申请数据空间的数据）。</p><img src="C:\Users\赵阳\AppData\Roaming\Typora\typora-user-images\image-20220625132956198.png" alt="image-20220625132956198" style="zoom:50%;" /></li></ol><h2 id="静态存储分配"><a class="markdownIt-Anchor" href="#静态存储分配"></a> 静态存储分配</h2><ol><li>静态存储分配中，编译时就给它们分配固定的存储空间，目标程序运行时，总是使用这些在编译时分配好的存储单元作为其数据空间。</li><li>所需满足条件：不允许过程有递归调用；不允许有可变大小数据项；不允许用户动态建立数据实体。</li><li>静态存储分配把内存看成一个一维数组，一旦分配，运行期间一直被某个变量占用。</li></ol><h2 id="栈式动态存储分配"><a class="markdownIt-Anchor" href="#栈式动态存储分配"></a> 栈式动态存储分配</h2><ol><li><p>栈式动态存储分配中，一个程序运行时所需数据区大小未知，运行中进入一个程序模块，模块所需数据区必须已知。运行时，每当进入一个程序块就为其分配一个新的数据区。</p></li><li><p>栈式动态存储分配策略是将程序数据空间设计为一个栈：</p><ol><li>每当程序调用一个过程就在栈顶为被调过程分配一个新的数据空间：保留块开始地址、为当前块分配存储、为每个局部量分配相对地址</li><li>每当调用结束便释放栈顶空间。</li></ol></li><li><p>活动记录：一段连续的存储区，存放程序模块一次执行所需全部信息。进入一个程序模块就要在运行栈顶创建一个活动记录，包括模块内定义的局部变量所需的存储空间、全局数据区指针以及形参、隐参。</p></li><li><p>活动记录的结构：</p><img src="C:\Users\赵阳\AppData\Roaming\Typora\typora-user-images\image-20220625140243168.png" alt="image-20220625140243168" style="zoom:50%;" /><p>SP：基地址指针，指向最新活动记录的起点。</p><p>top：指向当前最新的活动记录的顶端。</p><p>动态链：老sp反映运行中模块间调用关系，子程序的动态链不唯一，Pi如果没有非正常出口，则会返回到Pi-1中。</p><p>display表：依次存放现行层、直接外层……直至最外层每个过程的最新活动记录起始地址。</p><img src="C:\Users\赵阳\AppData\Roaming\Typora\typora-user-images\image-20220625140927274.png" alt="image-20220625140927274" style="zoom:50%;" /><img src="C:\Users\赵阳\AppData\Roaming\Typora\typora-user-images\image-20220625140947960.png" alt="image-20220625140947960" style="zoom:50%;" /></li></ol><h2 id="过程调用-进入与返回"><a class="markdownIt-Anchor" href="#过程调用-进入与返回"></a> 过程调用、进入与返回</h2><img src="C:\Users\赵阳\AppData\Roaming\Typora\typora-user-images\image-20220625141358750.png" alt="image-20220625141358750" style="zoom:100%;" /><p><img src="C:%5CUsers%5C%E8%B5%B5%E9%98%B3%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20220625141432986.png" alt="image-20220625141432986" /></p>]]></content>
    
    
    <summary type="html">计算机专业课《编译原理》笔记。主讲教师：姚卫红。</summary>
    
    
    
    <category term="Courses" scheme="http://aflyingsheep.github.io/categories/Courses/"/>
    
    
    <category term="Courses" scheme="http://aflyingsheep.github.io/tags/Courses/"/>
    
  </entry>
  
  <entry>
    <title>计算机网络</title>
    <link href="http://aflyingsheep.github.io/2022/06/20/Review%20notes/computer_networking/"/>
    <id>http://aflyingsheep.github.io/2022/06/20/Review%20notes/computer_networking/</id>
    <published>2022-06-20T11:35:13.000Z</published>
    <updated>2023-02-11T13:31:09.705Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="计算机网络概述"><a class="markdownIt-Anchor" href="#计算机网络概述"></a> 计算机网络概述</h1><ol><li><p>协议：定义了格式、网络实体发送、接收的顺序以及信息传送、接收采取的动作。</p></li><li><p>网络核心</p><ol><li><p>分组交换</p><ul><li>数据包传输延迟：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle displaystyle="true" scriptlevel="0"><mfrac><mi>L</mi><mi>R</mi></mfrac></mstyle><mi>s</mi></mrow><annotation encoding="application/x-tex">\dfrac{L}{R}s</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:2.04633em;vertical-align:-0.686em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.36033em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.00773em;">R</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal">L</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mord mathnormal">s</span></span></span></span></li><li>存储转发：数据包必须全部到达路由器才能继续传输</li></ul><p>排队时延：路由器填满后会丢包</p></li><li><p>电路交换：专用资源、保证性能，常用于传统电话网络</p><ul><li>频分复用、时分复用</li></ul></li></ol></li><li><p>丢失、时延、吞吐率</p><ol><li>四种时延：处理时延、排队时延、传输时延（<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi><mi mathvariant="normal">/</mi><mi>R</mi></mrow><annotation encoding="application/x-tex">L/R</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">L</span><span class="mord">/</span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span></span></span></span>）（包发送）、传播时延（<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>d</mi><mi mathvariant="normal">/</mi><mi>S</mi></mrow><annotation encoding="application/x-tex">d/S</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">d</span><span class="mord">/</span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span></span></span></span>）（包在链路传输）</li><li>流量强度：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle displaystyle="true" scriptlevel="0"><mfrac><mrow><mi>L</mi><mo>∗</mo><mi>a</mi></mrow><mi>R</mi></mfrac></mstyle></mrow><annotation encoding="application/x-tex">\dfrac{L*a}{R}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:2.04633em;vertical-align:-0.686em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.36033em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.00773em;">R</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal">L</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathnormal">a</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span>，其中R为带宽，a为包平均到达速率，L为包的长度</li><li>丢包：队列缓冲区优先，到达满队列的包被丢弃</li><li>吞吐量：从发送方到接收方的吞吐量(bit/time)（短板效应）</li></ol></li></ol><h1 id="应用层"><a class="markdownIt-Anchor" href="#应用层"></a> 应用层</h1><h2 id="应用层概述"><a class="markdownIt-Anchor" href="#应用层概述"></a> 应用层概述</h2><img src="/image/ComputerNetwork/image-20220620144446452.png" alt="image-20220620144446452" style="zoom:60%;" /><h2 id="httpweb"><a class="markdownIt-Anchor" href="#httpweb"></a> HTTP&amp;Web</h2><img src="/image/ComputerNetwork/image-20220620144613034.png" alt="image-20220620144613034" style="zoom:70%;" /><p><img src="/image/ComputerNetwork/image-20220620144733127.png" alt="image-20220620144733127" /></p><img src="/image/ComputerNetwork/image-20220620144902373.png" alt="image-20220620144902373" style="zoom:60%;" /><h2 id="dns服务器"><a class="markdownIt-Anchor" href="#dns服务器"></a> DNS服务器</h2><img src="/image/ComputerNetwork/image-20220620145016636.png" alt="image-20220620145016636" style="zoom:67%;" /><img src="/image/ComputerNetwork/image-20220620145135714.png" alt="image-20220620145135714" style="zoom:67%;" /><img src="/image/ComputerNetwork/image-20220620145211848.png" alt="image-20220620145211848" style="zoom:67%;" /><img src="/image/ComputerNetwork/image-20220620145236568.png" alt="image-20220620145236568" style="zoom:67%;" /><h2 id="smtp"><a class="markdownIt-Anchor" href="#smtp"></a> SMTP</h2><img src="/image/ComputerNetwork/image-20220620145255564.png" alt="image-20220620145255564" style="zoom:80%;" /><h1 id="传输层"><a class="markdownIt-Anchor" href="#传输层"></a> 传输层</h1><h2 id="概述"><a class="markdownIt-Anchor" href="#概述"></a> 概述</h2><img src="/image/ComputerNetwork/image-20220620152959121.png" alt="image-20220620152959121" style="zoom:80%;" /><h2 id="udp"><a class="markdownIt-Anchor" href="#udp"></a> UDP</h2><img src="/image/ComputerNetwork/image-20220620153247681.png" alt="image-20220620153247681" style="zoom:80%;" /><h2 id="可靠数据传输"><a class="markdownIt-Anchor" href="#可靠数据传输"></a> 可靠数据传输</h2><ul><li>rdt2.0：停止等待—发送以后接收反馈，如果是NAK则再次发送，如果是ACK则等待下次发送。</li></ul><img src="/image/ComputerNetwork/image-20220620154810062.png" alt="image-20220620154810062" style="zoom:80%;" /><ul><li><p>rdt2.1：处理乱码的ACK和NAK：增加两个状态号</p><img src="/image/ComputerNetwork/image-20220620154901324.png" alt="image-20220620154901324" style="zoom:80%;" /></li><li><p>rdt2.2：进行改进，取消了NAK，在ACK中加入ACK了哪个分组</p><img src="/image/ComputerNetwork/image-20220620155118940.png" alt="image-20220620155118940" style="zoom:80%;" /></li><li><p>rdt3.0：比特差错和丢包同时存在：引入定时器，等待合理时间重传</p><img src="/image/ComputerNetwork/image-20220620155554234.png" alt="image-20220620155554234" style="zoom:80%;" /></li><li><p>回退N步：注意，接收方只维持当前期望的ACK序号，乱序到达的直接丢弃。</p></li></ul><img src="/image/ComputerNetwork/image-20220620155922128.png" alt="image-20220620155922128" style="zoom:80%;" /><ul><li><p>选择重传：注意，每个分组均有定时器</p><img src="/image/ComputerNetwork/image-20220620160055780.png" alt="image-20220620160055780" style="zoom:80%;" /><img src="/image/ComputerNetwork/image-20220620160158224.png" alt="image-20220620160158224" style="zoom:80%;" /></li></ul><h2 id="tcp"><a class="markdownIt-Anchor" href="#tcp"></a> TCP</h2><img src="/image/ComputerNetwork/image-20220620160338270.png" alt="image-20220620160338270" style="zoom:80%;" /><img src="/image/ComputerNetwork/image-20220620160505485.png" alt="image-20220620160505485" style="zoom:80%;" /><img src="/image/ComputerNetwork/image-20220620160541231.png" alt="image-20220620160541231" style="zoom:80%;" /><img src="/image/ComputerNetwork/image-20220620160613925.png" alt="image-20220620160613925" style="zoom:80%;" /><img src="/image/ComputerNetwork/image-20220620160623145.png" alt="image-20220620160623145" style="zoom:80%;" /><p><img src="/image/ComputerNetwork/image-20220620160838797.png" alt="image-20220620160838797" /></p><h2 id="tcp拥塞控制原理"><a class="markdownIt-Anchor" href="#tcp拥塞控制原理"></a> TCP拥塞控制原理</h2><img src="/image/ComputerNetwork/image-20220620160946683.png" alt="image-20220620160946683" style="zoom:80%;" /><p><img src="/image/ComputerNetwork/image-20220620161002885.png" alt="image-20220620161002885" /></p><ul><li>TCP拥塞控制和流量控制对比<ul><li>流量控制原因： TCP接收方和发送方都有一个发送缓存和接收缓存，如果接收方接收缓存满了，但是发送方还继续发送数据，就会导致数据溢出，丢包产生。由接收方告诉发送方。</li><li>拥塞控制原因：因为网络拥塞采取的手段，是发送方自己感知的。</li></ul></li></ul><h2 id="网络层控制平面"><a class="markdownIt-Anchor" href="#网络层控制平面"></a> 网络层——控制平面</h2><img src="/image/ComputerNetwork/image-20220620161613729.png" alt="image-20220620161613729" style="zoom:80%;" /><img src="/image/ComputerNetwork/image-20220620161724415.png" alt="image-20220620161724415" style="zoom:80%;" /><img src="/image/ComputerNetwork/image-20220620162051143.png" alt="image-20220620162051143" style="zoom:80%;" /><h2 id="ipv4"><a class="markdownIt-Anchor" href="#ipv4"></a> IPV4</h2><img src="/image/ComputerNetwork/image-20220620162249242.png" alt="image-20220620162249242" style="zoom:80%;" /><img src="/image/ComputerNetwork/image-20220620162329833.png" alt="image-20220620162329833" style="zoom:80%;" /><img src="/image/ComputerNetwork/image-20220620162411416.png" alt="image-20220620162411416" style="zoom:80%;" /><img src="/image/ComputerNetwork/image-20220620162710544.png" alt="image-20220620162710544" style="zoom:80%;" /><h2 id="nat"><a class="markdownIt-Anchor" href="#nat"></a> NAT</h2><img src="/image/ComputerNetwork/image-20220620162851604.png" alt="image-20220620162851604" style="zoom:80%;" /><h2 id="ipv6"><a class="markdownIt-Anchor" href="#ipv6"></a> IPV6</h2><img src="/image/ComputerNetwork/image-20220620163200121.png" alt="image-20220620163200121" style="zoom:80%;" /><h2 id="sdn"><a class="markdownIt-Anchor" href="#sdn"></a> SDN</h2><img src="/image/ComputerNetwork/image-20220620163257176.png" alt="image-20220620163257176" style="zoom:80%;" /><h1 id="网络层控制平面-2"><a class="markdownIt-Anchor" href="#网络层控制平面-2"></a> 网络层——控制平面</h1><h2 id="概述-2"><a class="markdownIt-Anchor" href="#概述-2"></a> 概述</h2><img src="/image/ComputerNetwork/image-20220620164041753.png" alt="image-20220620164041753" style="zoom:80%;" /><h2 id="路由选择算法"><a class="markdownIt-Anchor" href="#路由选择算法"></a> 路由选择算法</h2><img src="/image/ComputerNetwork/image-20220620164155045.png" alt="image-20220620164155045" style="zoom:80%;" /><img src="/image/ComputerNetwork/image-20220620164234558.png" alt="image-20220620164234558" style="zoom:80%;" /><h2 id="as内部选择rip"><a class="markdownIt-Anchor" href="#as内部选择rip"></a> AS内部选择——RIP</h2><p>利用<strong>跳数</strong>来作为到达某个网络的路由选择标准。</p><ol><li>主要适用于规模较小的网络（当跳数为16时表示目的网络不可达）、可靠性要求较低的网络，可以通过不断的交换信息让路由器动态的适应网络连接的变化，这些信息包括每个路由器可以到达哪些网络，这些网络有多远等。</li><li>当前路由器仅和相邻的路由器进行信息交换。</li><li>RIP更新过程<ol><li>刚开始每个路由器只知道到直接连接网络的距离(距离为1)，接着每个路由器会和它的邻居路由器进行交换信息，更新自己的路由表</li><li>当路由器1与它的邻居路由器2进行信息沟通时，会把自己的路由表封装成数据报发给路由器2，路由器2接收到数据报后，会根据<strong>对方的路由表中的信息</strong>和<strong>距离向量算法</strong>来更新自己的路由表项。</li><li>经过若干次更新后，所有的路由器都会知道在本自治系统中任何一个网络的最短距离和下一跳的路由器地址。即达到收敛状态。</li></ol></li><li>RIP缺点<ol><li>只适用于小规模网络，因为当目的网络的距离(跳数)大于等于16时，路由器认为网络不可达。</li><li>RIP协议在进行消息分享时，是把路由表中的所有表项都封装层RIP报文发送出去，占用的带宽比较大。</li><li>Good news travel fast and bad news travel slow.</li><li>RIP使用“跳数”作为最优距离并非总是最优路径</li></ol></li></ol><h2 id="as内部选择ospf"><a class="markdownIt-Anchor" href="#as内部选择ospf"></a> AS内部选择——OSPF</h2><p>对比于RIP，OSPF以<strong>链路</strong>状态为比较数值。</p><img src="/image/ComputerNetwork/image-20220620164451917.png" alt="image-20220620164451917" style="zoom:80%;" /><img src="/image/ComputerNetwork/image-20220620164600853.png" alt="image-20220620164600853" style="zoom:80%;" /><h2 id="as之间选择bgp"><a class="markdownIt-Anchor" href="#as之间选择bgp"></a> AS之间选择——BGP</h2><img src="/image/ComputerNetwork/image-20220620165536630.png" alt="image-20220620165536630" style="zoom:80%;" /><ul><li>热土豆：先在自己AS内部选取代价最小的，先让其离开自己的AS。</li></ul><h2 id="sdn控制平面"><a class="markdownIt-Anchor" href="#sdn控制平面"></a> SDN控制平面</h2><img src="/image/ComputerNetwork/image-20220620165842428.png" alt="image-20220620165842428" style="zoom:80%;" /><ul><li><p>OpenFlow协议</p><img src="/image/ComputerNetwork/image-20220620170542879.png" alt="image-20220620170542879" style="zoom:80%;" /></li></ul><h2 id="icmp因特网控制报文协议"><a class="markdownIt-Anchor" href="#icmp因特网控制报文协议"></a> ICMP——因特网控制报文协议</h2><img src="/image/ComputerNetwork/image-20220620170704682.png" alt="image-20220620170704682" style="zoom:80%;" /><ul><li>TTL用尽时，路由器向主机返回名称及IP地址指示本次传输失败。</li></ul><h2 id="网络管理协议和snmp"><a class="markdownIt-Anchor" href="#网络管理协议和snmp"></a> 网络管理协议和SNMP</h2><ul><li><p>使用UDP进行传输！</p><img src="/image/ComputerNetwork/image-20220620170824153.png" alt="image-20220620170824153" style="zoom:80%;" /></li></ul><h1 id="链路层和局域网"><a class="markdownIt-Anchor" href="#链路层和局域网"></a> 链路层和局域网</h1><h2 id="概述-3"><a class="markdownIt-Anchor" href="#概述-3"></a> 概述</h2><img src="/image/ComputerNetwork/image-20220620182502877.png" alt="image-20220620182502877" style="zoom:80%;" /><ul><li><p>TCP和链路层都提供了可靠数据传输，是否重复？</p><ul><li><p>不重复，数据帧在链路层传播时，链路层保证了主机到路由器或路由器到路由器之间传播无差错，而在路由器中对IP首部改变、对数据修改等操作都需要由TCP进行检测，链路层无法检测。</p></li><li><p>TCP</p><img src="/image/ComputerNetwork/image-20220620182857448.png" alt="image-20220620182857448" style="zoom:80%;" /></li><li><p>链路层</p><img src="/image/ComputerNetwork/image-20220620182913371.png" alt="image-20220620182913371" style="zoom:80%;" /></li></ul></li></ul><h2 id="差错检测crc校验码"><a class="markdownIt-Anchor" href="#差错检测crc校验码"></a> 差错检测——CRC校验码</h2><p>见计算机组成原理部分。</p><h2 id="多路访问链路及协议"><a class="markdownIt-Anchor" href="#多路访问链路及协议"></a> 多路访问链路及协议</h2><ul><li><p>协议要求：分布式、节点间交互必须使用此信道</p><img src="/image/ComputerNetwork/image-20220620183334094.png" alt="image-20220620183334094" style="zoom:80%;" /><img src="/image/ComputerNetwork/image-20220620183404704.png" alt="image-20220620183404704" style="zoom:80%;" /><img src="/image/ComputerNetwork/image-20220620183509647.png" alt="image-20220620183509647" style="zoom:80%;" /><img src="/image/ComputerNetwork/image-20220620183845739.png" alt="image-20220620183845739" style="zoom:80%;" /></li></ul><h2 id="交换局域网"><a class="markdownIt-Anchor" href="#交换局域网"></a> 交换局域网</h2><ul><li><p>MAC地址作用：用于标识一个帧从哪个端口发出，到达哪个物理相连的其他端口。</p><p>注意：ARP是网络层协议。</p><img src="/image/ComputerNetwork/image-20220620184859268.png" alt="image-20220620184859268" style="zoom:80%;" /><img src="/image/ComputerNetwork/image-20220620185128296.png" alt="image-20220620185128296" style="zoom:80%;" /></li></ul><h2 id="以太网"><a class="markdownIt-Anchor" href="#以太网"></a> 以太网</h2><img src="/image/ComputerNetwork/image-20220620185205698.png" alt="image-20220620185205698" style="zoom:80%;" /><h2 id="交换机"><a class="markdownIt-Anchor" href="#交换机"></a> 交换机</h2><img src="/image/ComputerNetwork/image-20220620185706740.png" alt="image-20220620185706740" style="zoom:80%;" /><img src="/image/ComputerNetwork/image-20220620185906475.png" alt="image-20220620185906475" style="zoom:80%;" /><h2 id="路由器与交换机比较"><a class="markdownIt-Anchor" href="#路由器与交换机比较"></a> 路由器与交换机比较</h2><ol><li><p>相同点</p><ol><li>存储转发——缓存并转发，路由器基于IP地址转发，而交换机通过MAC地址进行转发。</li><li>均有转发表——路由器转发表通过路由算法生成，交换机转发表通过自学习生成。</li></ol></li><li><p>不同点</p><ol><li><p>交换机更快，因为只到链路层；交换机更慢，因为实现到网络层</p></li><li><p>规模：交换机缺点：当规模大时，要浪费大量带宽资源，广播时对所有端口进行转发，占用大量资源。</p></li><li><p>广播域：</p><img src="/image/ComputerNetwork/image-20220620190332128.png" alt="image-20220620190332128" style="zoom:80%;" /><img src="/image/ComputerNetwork/image-20220620190514542.png" alt="image-20220620190514542" style="zoom:80%;" /></li></ol></li></ol><h2 id="虚拟局域网"><a class="markdownIt-Anchor" href="#虚拟局域网"></a> 虚拟局域网</h2><p>对物理设备进行虚拟划分。</p><img src="/image/ComputerNetwork/image-20220620190644200.png" alt="image-20220620190644200" style="zoom:80%;" /><h1 id="无线网络"><a class="markdownIt-Anchor" href="#无线网络"></a> 无线网络</h1><h2 id="概述-4"><a class="markdownIt-Anchor" href="#概述-4"></a> 概述</h2><img src="/image/ComputerNetwork/image-20220620191221002.png" alt="image-20220620191221002" style="zoom:80%;" /><h2 id="无线信道"><a class="markdownIt-Anchor" href="#无线信道"></a> 无线信道</h2><img src="/image/ComputerNetwork/image-20220620191315488.png" alt="image-20220620191315488" style="zoom:80%;" /><h2 id="80211"><a class="markdownIt-Anchor" href="#80211"></a> 802.11</h2><img src="/image/ComputerNetwork/image-20220620191436906.png" alt="image-20220620191436906" style="zoom:80%;" /><img src="/image/ComputerNetwork/image-20220620191637632.png" alt="image-20220620191637632" style="zoom:80%;" /><img src="/image/ComputerNetwork/image-20220620191900544.png" alt="image-20220620191900544" style="zoom:80%;" /><img src="/image/ComputerNetwork/image-20220620191932022.png" alt="image-20220620191932022" style="zoom:80%;" /><img src="/image/ComputerNetwork/image-20220620192554268.png" alt="image-20220620192554268" style="zoom:80%;" /><h2 id="其他网络"><a class="markdownIt-Anchor" href="#其他网络"></a> 其他网络</h2><img src="/image/ComputerNetwork/image-20220620192646075.png" alt="image-20220620192646075" style="zoom:80%;" /><img src="/image/ComputerNetwork/image-20220620192827477.png" alt="image-20220620192827477" style="zoom:80%;" /><img src="/image/ComputerNetwork/image-20220620192856465.png" alt="image-20220620192856465" style="zoom:80%;" /><h2 id="移动管理"><a class="markdownIt-Anchor" href="#移动管理"></a> 移动管理</h2><img src="/image/ComputerNetwork/image-20220620193213706.png" alt="image-20220620193213706" style="zoom:80%;" /><img src="/image/ComputerNetwork/image-20220620193332991.png" alt="image-20220620193332991" style="zoom:80%;" /><img src="/image/ComputerNetwork/image-20220620193438907.png" alt="image-20220620193438907" style="zoom:80%;" /><h1 id="附录"><a class="markdownIt-Anchor" href="#附录"></a> 附录</h1><img src="/image/ComputerNetwork/1.jpg" alt="1" style="zoom:100%;" /><img src="/image/ComputerNetwork/2.jpg" alt="2" style="zoom:100%;" /><img src="/image/ComputerNetwork/3.jpg" alt="3" style="zoom:100%;" /><img src="/image/ComputerNetwork/4.jpg" alt="4" style="zoom:100%;" /><img src="/image/ComputerNetwork/5.jpg" alt="5" style="zoom:100%;" /><img src="/image/ComputerNetwork/6.jpg" alt="6" style="zoom:100%;" /><img src="/image/ComputerNetwork/7.jpg" alt="7" style="zoom:100%;" /><img src="/image/ComputerNetwork/8.jpg" alt="8" style="zoom:100%;" /><img src="/image/ComputerNetwork/9.jpg" alt="9" style="zoom:100%;" /><img src="/image/ComputerNetwork/10.jpg" alt="10" style="zoom:100%;" /><img src="/image/ComputerNetwork/11.jpg" alt="11" style="zoom:100%;" /><img src="/image/ComputerNetwork/12.jpg" alt="12" style="zoom:100%;" />]]></content>
    
    
    <summary type="html">计算机专业课《计算机网络》笔记。主讲教师：申彦明。</summary>
    
    
    
    <category term="Courses" scheme="http://aflyingsheep.github.io/categories/Courses/"/>
    
    
    <category term="Courses" scheme="http://aflyingsheep.github.io/tags/Courses/"/>
    
  </entry>
  
  <entry>
    <title>离散数学</title>
    <link href="http://aflyingsheep.github.io/2022/06/18/Review%20notes/discrete_math/"/>
    <id>http://aflyingsheep.github.io/2022/06/18/Review%20notes/discrete_math/</id>
    <published>2022-06-18T14:06:13.000Z</published>
    <updated>2023-02-11T13:34:03.719Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="命题逻辑"><a class="markdownIt-Anchor" href="#命题逻辑"></a> 命题逻辑</h1><h2 id="命题与连结词"><a class="markdownIt-Anchor" href="#命题与连结词"></a> 命题与连结词</h2><h2 id="命题公式-翻译和真值表"><a class="markdownIt-Anchor" href="#命题公式-翻译和真值表"></a> 命题公式、翻译和真值表</h2><ol><li>可兼或<ul><li>例：张明正在睡觉或游泳：此处的或者是可兼或（不可以即在睡觉又在游泳）</li><li>令P：张明在睡觉，Q：张明在有用，转化为<span class='katex-error' title='ParseError: KaTeX parse error: Undefined control sequence: \and at position 3: (P\̲a̲n̲d̲\lnot Q)\or(\ln…'>(P\and\lnot Q)\or(\lnot P\and Q)</span></li></ul></li><li>“除非”是必要条件<ul><li>例：除非天气好，我才骑自行车上班</li><li>令P：天气好，Q：骑自行车上班，转化为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>Q</mi><mo>→</mo><mi>P</mi></mrow><annotation encoding="application/x-tex">Q\rightarrow P</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class="mord mathnormal">Q</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span></span></span></span></li></ul></li></ol><h2 id="公式分类与等价式"><a class="markdownIt-Anchor" href="#公式分类与等价式"></a> 公式分类与等价式</h2><ol><li>命题定律（部分）<ul><li>吸收律：<span class='katex-error' title='ParseError: KaTeX parse error: Undefined control sequence: \and at position 2: A\̲a̲n̲d̲(A\or B)\Leftri…'>A\and(A\or B)\Leftrightarrow A,\enspace A\or(A\and B)\Leftrightarrow A</span></li><li>归谬率：<span class='katex-error' title='ParseError: KaTeX parse error: Undefined control sequence: \and at position 17: …A\rightarrow B)\̲a̲n̲d̲(A\rightarrow\l…'>(A\rightarrow B)\and(A\rightarrow\lnot B)\Leftrightarrow\lnot A</span></li></ul></li><li>代入规则：在一个永真式A中，任何一个原子命题变元R出现的每一处，用另一个公式代入，所得公式B仍是永真式。</li></ol><h2 id="对偶式与蕴涵式"><a class="markdownIt-Anchor" href="#对偶式与蕴涵式"></a> 对偶式与蕴涵式</h2><ol><li><p>对偶式：在给定的仅使用连结词<span class='katex-error' title='ParseError: KaTeX parse error: Undefined control sequence: \and at position 7: \lnot,\̲a̲n̲d̲,\or'>\lnot,\and,\or</span>的命题公式A中，若把<span class='katex-error' title='ParseError: KaTeX parse error: Undefined control sequence: \and at position 1: \̲a̲n̲d̲'>\and</span>和<span class='katex-error' title='ParseError: KaTeX parse error: Undefined control sequence: \or at position 1: \̲o̲r̲'>\or</span>互换，F和T互换得到一个命题公式<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>A</mi><mo>∗</mo></msup></mrow><annotation encoding="application/x-tex">A^*</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.688696em;vertical-align:0em;"></span><span class="mord"><span class="mord mathnormal">A</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.688696em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">∗</span></span></span></span></span></span></span></span></span></span></span>，则称<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>A</mi><mo>∗</mo></msup></mrow><annotation encoding="application/x-tex">A^*</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.688696em;vertical-align:0em;"></span><span class="mord"><span class="mord mathnormal">A</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.688696em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">∗</span></span></span></span></span></span></span></span></span></span></span>是<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal">A</span></span></span></span>的对偶式。</p></li><li><p>对偶定理：设<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>A</mi><mo>∗</mo></msup></mrow><annotation encoding="application/x-tex">A^*</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.688696em;vertical-align:0em;"></span><span class="mord"><span class="mord mathnormal">A</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.688696em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">∗</span></span></span></span></span></span></span></span></span></span></span>和<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal">A</span></span></span></span>互为对偶式，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>P</mi><mn>1</mn></msub><mo separator="true">,</mo><mo>…</mo><mo separator="true">,</mo><msub><mi>P</mi><mi>n</mi></msub></mrow><annotation encoding="application/x-tex">P_1,\dots,P_n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner">…</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>是出现在<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>A</mi><mo>∗</mo></msup></mrow><annotation encoding="application/x-tex">A^*</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.688696em;vertical-align:0em;"></span><span class="mord"><span class="mord mathnormal">A</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.688696em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">∗</span></span></span></span></span></span></span></span></span></span></span>和<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal">A</span></span></span></span>的原子命题变元，则：</p><ul><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">¬</mi><mi>A</mi><mo stretchy="false">(</mo><msub><mi>P</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>P</mi><mn>2</mn></msub><mo separator="true">,</mo><mo>…</mo><mo separator="true">,</mo><msub><mi>P</mi><mi>n</mi></msub><mo stretchy="false">)</mo><mo>⇔</mo><msup><mi>A</mi><mo>∗</mo></msup><mo stretchy="false">(</mo><mi mathvariant="normal">¬</mi><msub><mi>P</mi><mn>1</mn></msub><mo separator="true">,</mo><mo>…</mo><mo separator="true">,</mo><mi mathvariant="normal">¬</mi><msub><mi>P</mi><mi>n</mi></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\lnot A(P_1,P_2,\dots,P_n)\Leftrightarrow A^*(\lnot P_1,\dots,\lnot P_n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">¬</span><span class="mord mathnormal">A</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner">…</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">⇔</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal">A</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.688696em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">∗</span></span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord">¬</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner">…</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">¬</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mo stretchy="false">(</mo><mi mathvariant="normal">¬</mi><msub><mi>P</mi><mn>1</mn></msub><mo separator="true">,</mo><mo>…</mo><mo separator="true">,</mo><mi mathvariant="normal">¬</mi><msub><mi>P</mi><mi>n</mi></msub><mo stretchy="false">)</mo><mo>⇔</mo><mi mathvariant="normal">¬</mi><msup><mi>A</mi><mo>∗</mo></msup><mo stretchy="false">(</mo><msub><mi>P</mi><mn>1</mn></msub><mo separator="true">,</mo><mo>…</mo><mo separator="true">,</mo><msub><mi>P</mi><mi>n</mi></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">A(\lnot P_1,\dots,\lnot P_n)\Leftrightarrow\lnot A^*(P_1,\dots,P_n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">A</span><span class="mopen">(</span><span class="mord">¬</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner">…</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">¬</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">⇔</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">¬</span><span class="mord"><span class="mord mathnormal">A</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.688696em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">∗</span></span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner">…</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></li></ul></li><li><p>设A和B为两个命题公式，若<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mo>⇔</mo><mi>B</mi></mrow><annotation encoding="application/x-tex">A\Leftrightarrow B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal">A</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">⇔</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span></span></span></span>则<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>A</mi><mo>∗</mo></msup><mo>⇔</mo><msup><mi>B</mi><mo>∗</mo></msup></mrow><annotation encoding="application/x-tex">A^*\Leftrightarrow B^*</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.688696em;vertical-align:0em;"></span><span class="mord"><span class="mord mathnormal">A</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.688696em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">∗</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">⇔</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.688696em;vertical-align:0em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.688696em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">∗</span></span></span></span></span></span></span></span></span></span></span></p></li><li><p>蕴涵式：设A和B是两个命题公式，若<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mo>→</mo><mi>B</mi></mrow><annotation encoding="application/x-tex">A\rightarrow B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal">A</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span></span></span></span>是永真式，则称A蕴涵B，记作<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mo>⇒</mo><mi>B</mi></mrow><annotation encoding="application/x-tex">A\Rightarrow B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal">A</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">⇒</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span></span></span></span>，称<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mo>⇒</mo><mi>B</mi></mrow><annotation encoding="application/x-tex">A\Rightarrow B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal">A</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">⇒</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span></span></span></span>为蕴涵式或永真条件式</p></li><li><p>蕴涵式证明方法：</p><ol><li>前件真推导后件真方法</li><li>后件假推导前件假方法</li></ol></li><li><p>基本蕴含式</p><p>待补充</p></li></ol><h2 id="联结词的扩充与功能完全组"><a class="markdownIt-Anchor" href="#联结词的扩充与功能完全组"></a> 联结词的扩充与功能完全组</h2><ol><li><span class='katex-error' title='ParseError: KaTeX parse error: Undefined control sequence: \and at position 34: …ghtarrow\lnot(P\̲a̲n̲d̲ ̲Q)'>P\uparrow Q\Leftrightarrow\lnot(P\and Q)</span></li><li><span class='katex-error' title='ParseError: KaTeX parse error: Undefined control sequence: \or at position 36: …ghtarrow\lnot(P\̲o̲r̲ ̲Q)'>P\downarrow Q\Leftrightarrow\lnot(P\or Q)</span></li></ol><h2 id="公式标准型范式"><a class="markdownIt-Anchor" href="#公式标准型范式"></a> 公式标准型——范式</h2><ol><li>命题变元和命题变元的否定，称为文字。</li><li>设<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>A</mi><mn>1</mn></msub><mo separator="true">,</mo><mo>…</mo><mo separator="true">,</mo><msub><mi>A</mi><mi>m</mi></msub></mrow><annotation encoding="application/x-tex">A_1,\dots,A_m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathnormal">A</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner">…</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathnormal">A</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">m</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>为简单合取式，称<span class='katex-error' title='ParseError: KaTeX parse error: Undefined control sequence: \or at position 4: A_1\̲o̲r̲ ̲A_2\or\dots A_m'>A_1\or A_2\or\dots A_m</span>为析取范式，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi><mo>≥</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">m\ge1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mord mathnormal">m</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≥</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span></li><li>设<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>A</mi><mn>1</mn></msub><mo separator="true">,</mo><mo>…</mo><mo separator="true">,</mo><msub><mi>A</mi><mi>n</mi></msub></mrow><annotation encoding="application/x-tex">A_1,\dots,A_n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathnormal">A</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner">…</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathnormal">A</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>为简单析取式，称<span class='katex-error' title='ParseError: KaTeX parse error: Undefined control sequence: \and at position 4: A_1\̲a̲n̲d̲ ̲A_2\and\dots A_…'>A_1\and A_2\and\dots A_n</span>为合取范式，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo>≥</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">n\ge1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≥</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span></li></ol><h2 id="公式的主范式"><a class="markdownIt-Anchor" href="#公式的主范式"></a> 公式的主范式</h2><ol><li>主析取范式<ol><li>小项：在含有n个命题变元的简单合取式中，若每个命题变元与其否定不同时存在，而二者之一出现一次且仅出现一次，则称该简单合取式为小项，或布尔积。</li><li>在给定公式的析取范式中，若其简单合取式都是小项，则称该范式为主析取范式。</li><li>任意含n个命题变元的非永假命题公式A，都存在与其等价的主析取范式。</li><li>任意含n个命题变元的非永假命题公式A，主析取范式惟一。</li></ol></li><li>主合取范式<ol><li>大项：在含有n个命题变元的简单析取式中，若每个命题变元与其否定不同时存在，而二者之一出现一次且仅出现一次，则称该简单合取式为大项，或布尔和。</li><li>在给定公式的合取范式中，若其简单合取式都是大项，则称该范式为主合取范式。</li><li>任意含n个命题变元的非永真命题公式A，都存在与其等价的主合取范式。</li><li>任意含n个命题变元的非永真命题公式A，主析取范式惟一。</li></ol></li><li>关系<ol><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">¬</mi><msub><mi>m</mi><mi>i</mi></msub><mo>⇔</mo><msub><mi>M</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">\lnot m_i\Leftrightarrow M_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord">¬</span><span class="mord"><span class="mord mathnormal">m</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">⇔</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10903em;">M</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.10903em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></li><li><span class='katex-error' title='ParseError: KaTeX parse error: Undefined control sequence: \or at position 13: \lnot(m_{j1}\̲o̲r̲ ̲m_{j2}\or\dots\…'>\lnot(m_{j1}\or m_{j2}\or\dots\or m_{j_{2^n-1}})\Leftrightarrow(M_{j1}\and M_{j2}\and\dots\and M_{j_{2^n-1}})</span></li><li>如一个命题的主析取范式为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>m</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>m</mi><mn>2</mn></msub><mo separator="true">,</mo><msub><mi>m</mi><mn>4</mn></msub></mrow><annotation encoding="application/x-tex">m_1,m_2,m_4</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathnormal">m</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathnormal">m</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathnormal">m</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">4</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>，那么它的主合取范式为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>m</mi><mn>3</mn></msub><mo separator="true">,</mo><msub><mi>m</mi><mn>5</mn></msub></mrow><annotation encoding="application/x-tex">m_3,m_5</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathnormal">m</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathnormal">m</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">5</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></li></ol></li></ol><h2 id="命题逻辑的推理理论"><a class="markdownIt-Anchor" href="#命题逻辑的推理理论"></a> 命题逻辑的推理理论</h2><ol><li>真值表法</li><li>演绎法（从前提演绎出结论）</li><li>间接证法（将结论的否定作为附加前提，与给定前提一起推证，若能推出矛盾，说明结论有效）</li></ol><h2 id="命题逻辑的归结推理"><a class="markdownIt-Anchor" href="#命题逻辑的归结推理"></a> 命题逻辑的归结推理</h2><p>欲证明<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>A</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>A</mi><mn>2</mn></msub><mo separator="true">,</mo><mo>…</mo><mo separator="true">,</mo><msub><mi>A</mi><mi>n</mi></msub><mo>⊢</mo><mi>C</mi></mrow><annotation encoding="application/x-tex">A_1,A_2,\dots,A_n\vdash C</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathnormal">A</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathnormal">A</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner">…</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathnormal">A</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">⊢</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span></span></span></span>，可采用如下步骤：</p><ol><li>将<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>A</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>A</mi><mn>2</mn></msub><mo separator="true">,</mo><mo>…</mo><mo separator="true">,</mo><msub><mi>A</mi><mi>n</mi></msub><mo separator="true">,</mo><mi mathvariant="normal">¬</mi><mi>C</mi></mrow><annotation encoding="application/x-tex">A_1,A_2,\dots,A_n,\neg C</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathnormal">A</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathnormal">A</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner">…</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathnormal">A</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">¬</span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span></span></span></span>分别化为合取范式</li><li>取S为上述各合取范式中所有简单析取式的子句集合，而简单析取式对应的子句是指该简单析取式中包含的文字的集合。</li><li>寻找S的一个反驳，若能找到，则<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>A</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>A</mi><mn>2</mn></msub><mo separator="true">,</mo><mo>…</mo><mo separator="true">,</mo><msub><mi>A</mi><mi>n</mi></msub><mo>⊢</mo><mi>C</mi></mrow><annotation encoding="application/x-tex">A_1,A_2,\dots,A_n\vdash C</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathnormal">A</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathnormal">A</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner">…</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathnormal">A</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">⊢</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span></span></span></span>，否则<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>A</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>A</mi><mn>2</mn></msub><mo separator="true">,</mo><mo>…</mo><mo separator="true">,</mo><msub><mi>A</mi><mi>n</mi></msub><mo>⊬</mo><mi>C</mi></mrow><annotation encoding="application/x-tex">A_1,A_2,\dots,A_n\nvdash C</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.88333em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathnormal">A</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathnormal">A</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner">…</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathnormal">A</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel amsrm">⊬</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span></span></span></span></li></ol><h1 id="谓词逻辑"><a class="markdownIt-Anchor" href="#谓词逻辑"></a> 谓词逻辑</h1><h2 id="谓词逻辑中基本概念与表示"><a class="markdownIt-Anchor" href="#谓词逻辑中基本概念与表示"></a> 谓词逻辑中基本概念与表示</h2><ol><li>个题、谓词和命题的谓词形式</li><li>原子谓词</li><li>量词</li></ol><h2 id="谓词公式与翻译"><a class="markdownIt-Anchor" href="#谓词公式与翻译"></a> 谓词公式与翻译</h2><h2 id="约束变元与自由变元"><a class="markdownIt-Anchor" href="#约束变元与自由变元"></a> 约束变元与自由变元</h2><ol><li>约束变元改名规则：将量词辖域中某个约束出现的个体变元及相应指导变元，改成本辖域中未曾出现过的个体变元，其他不变。</li><li>自由变元带入规则：对于某自由出现的个体变元可用个体常元或用与原子公式中所有个体变元不同的个体变元代入，且<strong>处处带入</strong>。</li></ol><h2 id="谓词逻辑的解释与其赋值"><a class="markdownIt-Anchor" href="#谓词逻辑的解释与其赋值"></a> 谓词逻辑的解释与其赋值</h2>]]></content>
    
    
    <summary type="html">计算机专业课《离散数学》笔记。主讲教师：李丽双、徐喜荣。</summary>
    
    
    
    <category term="Courses" scheme="http://aflyingsheep.github.io/categories/Courses/"/>
    
    
    <category term="Courses" scheme="http://aflyingsheep.github.io/tags/Courses/"/>
    
  </entry>
  
  <entry>
    <title>操作系统（二）</title>
    <link href="http://aflyingsheep.github.io/2022/06/07/Review%20notes/OS/"/>
    <id>http://aflyingsheep.github.io/2022/06/07/Review%20notes/OS/</id>
    <published>2022-06-07T15:06:08.000Z</published>
    <updated>2023-02-11T13:37:40.833Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="第四章-存储器管理"><a class="markdownIt-Anchor" href="#第四章-存储器管理"></a> 第四章 存储器管理</h1><h2 id="存储器的结构层次"><a class="markdownIt-Anchor" href="#存储器的结构层次"></a> 存储器的结构层次</h2><img src="/image/OS/image-20220608201406361.png" alt="image-20220608201406361" style="zoom:50%;" /><ol><li><p>主存储器与寄存器</p><p>CPU的控制部件只能从主存储器中取得指令和数据，数据能够从主存储器读取并将它们装入到寄存器中，或从寄存器存入到主存储器中</p></li><li><p>高速缓存和磁盘缓存</p><ol><li>高速缓存（Cache）：将主存中一些经常访问的信息存放在高速缓存中，减少访问主存储器的次数，可大幅度提高程序执行速度。</li><li>磁盘缓存：<strong>利用主存中的存储空间</strong>，暂存从磁盘中读出（或写入）的信息。</li></ol></li><li><p>内存管理的功能</p><ol><li>内存分配与回收<ul><li>根据分配时机的不同，可分为三种方式：<ul><li>直接分配：程序员采用物理内存地址编写程序</li><li>静态分配：作业运行之前各目标模块连接后，把整个作业一次性装入内存，并在作业运行过程中，不允许作业再申请其他内存，或在内存中移动位置。</li><li>动态分配：作业要求的基本内存空间是在模块装入内存时分配的，但在运行过程中允许作业申请附加的内存空间，或在内存中移动。即分配工作在作业运行前以及运行中逐步完成。</li></ul></li></ul></li><li>地址转换：逻辑地址-&gt;物理地址<ul><li>把用户程序装入内存时对有关指令的地址部分的修改定义为从程序地址到内存地址的地址转换，或称为地址重定位。</li><li>物理地址：内存地址，它是用于唯一标识一个内存单元的编号。所有的物理地址构成了物理空间。</li><li>逻辑地址:程序地址/相对地址/虚地址。它是指在源程序经过汇编或编译后形成的目标代码中，用于反映目标代码中指令或数据的相对位置关系的地址。逻辑地址都是以“0”为基址顺序进行编址的，这样生成的目标程序占据一定的地址空间，称为程序的逻辑地址空间，简称逻辑空间。</li><li>地址重定位原因：程序装入内存后，逻辑地址和内存地址不一致。</li></ul></li><li>内存保护：防止越界、非法访问</li><li>内存共享：多个进程共享内存中的同一段信息<ol><li>优点：节省内存空间，减少I/O量，提高性能。</li><li>实现：代码必须是可重入的（允许多个进程同时访问的代码）；必须设置共享的数据结构</li></ol></li><li>内存扩充：小内存运行大程序，逻辑扩充<ul><li>对内存进行逻辑上的扩充，现在普遍采用覆盖、对换和虚拟存储器技术。</li><li>虚拟存储器的理论基础是程序的局部性原理：时间局部性、空间局部性</li></ul></li></ol></li><li><p>覆盖</p><ol><li><p>引入：目标是在较小的可用内存中运行较大的程序。常用于<strong>多道程序系统</strong>，与<strong>分区存储管理</strong>配合使用。</p></li><li><p>原理：一个程序的几个代码段或数据段，按照时间先后来占用公共的内存空间。</p><ul><li>将程序的必要部分（常用功能）的代码和数据常驻内存</li><li>可选部分（不常用功能）在其他程序模块中实现，平时存放在外存中（覆盖文件），在需要用到时才装入到内存</li><li>不存在调用关系的模块不必同时装入到内存，从而可以相互覆盖。(即不同时用的模块可共用一个分区)</li></ul></li><li><p>缺点：编程时必须划分程序模块和确定程序模块之间的覆盖关系，增加编程复杂度，增加用户不透明性；外存转入覆盖文件，时间换空间。</p><img src="/image/OS/image-20220608210652286.png" alt="image-20220608210652286" style="zoom:50%;" /></li></ol></li><li><p>对换</p><ol><li><p>引入：多道程序环境下，某些进程由于事件尚未发生被阻塞，却占用大量内存；有着许多作业在外存上等待，<br />因无内存而不能进入内存运行的情况。</p></li><li><p>对换：将内存中暂时不能运行的进程或者暂时不用的程序和数据调到外村上，再把已经具备运行条件的进程或进程需要的数据调入内存。</p></li><li><p>对换类型：整体（进程）对换：以进程为单位；部分（页面、分段）对换。</p><p><em><strong>为实现进程对换，系统必须实现三方面的功能：对换空间的管理、进程换入与换出</strong></em></p></li><li><p><strong>对换空间的管理</strong>：OS将外存分为文件区（存放文件、离散分配）和对换区（存放从内存换出进程，连续分配以提高换入换出速度）</p></li><li><p><strong>进程的换入与换出：</strong></p><ul><li>换出：系统首先选择处于阻塞状态且优先级最低的进程作为换出进程</li><li>换入：查看所有进程状态，找出就绪状态但已被换出的进程，将换出时间最久的进程换入</li></ul></li></ol></li></ol><h2 id="程序的装入和链接"><a class="markdownIt-Anchor" href="#程序的装入和链接"></a> 程序的装入和链接</h2><ol><li><p>用户源程序变为可执行程序过程：编译（源代码-&gt;目标模块）、链接（目标模块 + 库函数-&gt;装入模块）、装入（装入模块装入内存）</p><img src="/image/OS/image-20220608212201750.png" alt="image-20220608212201750" style="zoom:50%;" /></li><li><p>程序的装入方式</p><ol><li><p>绝对装入方式：编译时知道程序驻留主存的位置，编译程序直接产生绝对地址的目标代码。所以程序中逻辑地址与内存地址相同，无需进行修改。多道程序环境下，编译程序不知道目标模块放入内存何处，故只适用于单道程序环境。</p></li><li><p>可重定位装入方式：多道程序环境下，目标模块起始地址为0，需要重定位。</p><ol><li><p>静态重定位（装入即确定）：优点为无需硬件支持，缺点为必须占用连续内存空间，装入后无法移动。</p></li><li><p>动态重定位（装入的为相对地址；相对地址转换为物理地址的工作，被推迟到程序指令）：优点为内存空间动态可变，移动只需修改寄存器；缺点为需要硬件支持，实现存储管理软件算法复杂。</p><p>寄存器BA：存放程序首地址，访问时地址位BA+相对偏移。</p></li></ol></li></ol></li><li><p>程序的链接方式</p><ol><li><p>静态链接：运行之前先将目标模块与库函数链接为完整的装入模块，以后不拆开。</p><ol><li><p>相对地址进行修改。</p></li><li><p>变换外部调用符号。</p><img src="/image/OS/image-20220608213746983.png" alt="image-20220608213746983" style="zoom:50%;" /></li></ol></li><li><p>装入时动态链接：用户源程序经编译后所得的目标模块，是在装入内存时边装入边链接的。即装入一个模块，如果发生一个外部模块调用事件，则引起装入程序找出外部模块并装入内存，并按静态链接的方式修改目标模块的相对地址。</p><p>优点：</p><ul><li>便于修改更新。目标模块分开存放，修改、更新目标模块容易。</li><li>便于目标模块共享。</li></ul></li><li><p>运行时动态链接（效率最高）：将对某些模块的链接推迟到程序执行时才进行链接。即在执行过程中，当发现一个被调用模块尚未装入内存时，立即由OS去找到该模块并将之装入内存，把它链接到调用者模块上。</p></li></ol></li></ol><p>下面的部分将解决如何为程序分配内存的问题</p><img src="/image/OS/image-20220608214245586.png" alt="image-20220608214245586" style="zoom:30%;" /><h2 id="连续分配方式"><a class="markdownIt-Anchor" href="#连续分配方式"></a> 连续分配方式</h2><ol><li><p>单一连续分配：只能用于单用户、单任务的操作系统中。采用这种存储管理方式时，可把内存分为系统区和用户区两部分</p><img src="/image/OS/image-20220608215806408.png" alt="image-20220608215806408" style="zoom:50%;" /></li><li><p>固定分区分配：将内存用户空间划分为若干个固定大小的区域，每个分区只装入一道作业。则允许几道作业并发进行。</p><ol><li><p>划分分区方法：</p><ul><li>所有内存分区大小相等。缺点：缺乏灵活性，程序太小浪费、太大装不下。</li><li>分区大小不等，内存区划分成含有多个较小的分区、适量的中等分区及少量的大分区。</li></ul></li><li><p>内存分配：将分区按照大小排队，并建立一张分区使用表，包含每个分区起始地址、大小、状态。</p><img src="/image/OS/image-20220608220300307.png" alt="image-20220608220300307" style="zoom:50%;" /></li><li><p>优点：相对于单一分区，存储利用率高，可实现多道</p></li><li><p>缺点：内存利用率低，区经常未填满，存在碎片；存在分区过小无法装入情况；程序度数受到分区数所限；动态扩充需要付出移动代价；程序间不可共享。</p></li></ol></li><li><p>动态分区分配：根据进程的实际需要，动态地为之分配内存空间。</p><ol><li><p>分区分配中的数据结构</p><ol><li><p>空闲分区表：每个空闲分区占一个表目，表目中包括分区序号、分区始址及分区的大小等数据项。</p><img src="/image/OS/image-20220608224021870.png" alt="image-20220608224021870" style="zoom:33%;" /></li><li><p>空闲分区链：将所有的空闲分区链接成一个双向链；分区尾部重复设置状态位和分区大小表目。当分区被分配出去以后，把状态位由“0”改为“1”</p><img src="/image/OS/image-20220608224333318.png" alt="image-20220608224333318" style="zoom:33%;" /></li></ol></li><li><p>分区分配算法</p><ol><li>首次适应算法：要求空闲分区链以地址递增的次序链接。分配内存时，从链首开始顺序查找，直至找到一个大小能满足要求的空闲分区为止；然后再按照作业的大小，从该分区中划出一块内存空间分配给请求者，余下的空闲分区仍留在空闲链中。<ul><li>倾向于优先利用内存中低址部分的空闲分区</li><li>每次都从头找起，查找开销大，适合较大作业</li></ul></li><li>循环首次适应算法：从上次找到的空闲分区的下一个空闲分区开始查找，直至找到一个能满足要求的空闲分区<ul><li>使内存中的空闲分区分布得更均匀，但缺乏大的空闲分区</li></ul></li><li>最佳适应算法：每次为作业分配内存时，总是把能满足要求、又是最小的空闲分区分配给作业<ul><li>将所有的空闲分区按其容量以从小到大的顺序形成一空闲分区链</li><li>存储器中会留下许多难以利用的小空闲区</li></ul></li><li>最坏适应算法：挑选一个最大的空闲区分割给作业使用<ul><li>产生碎片几率小</li><li>使存储器中缺乏大的空闲分区</li></ul></li></ol></li><li><p>分区回收算法：将相邻的空闲分区合并成一个空闲分区。</p><ol><li>上邻空闲区：与上空闲区合并，修改长度</li><li>下邻空闲区：与下空闲区合并，修改其长度和首址。</li><li>上、下邻空闲区：与上、下空闲区合并，修改其长度和首址，从空闲区表中或空闲链表中删除下接的空闲项。</li><li>上下都不相邻空闲区：在空闲区表中或空闲链表中添加新项，添上被回收分区长度和首址。</li></ol></li></ol></li><li><p>可重定位分区分配：动态重定位分区分配算法与动态分区分配算法基本上相同，差别仅在于：<strong>在这种分配算法中，增加了紧凑的功能，通常，在找不到足够大的空闲分区来满足用户需求时进行紧凑</strong>。</p><p>在每次“紧凑”后，都<strong>必须对移动了的程序或数据进行重定位</strong>。</p><img src="/image/OS/image-20220608230318460.png" alt="image-20220608230318460" style="zoom:40%;" /><img src="/image/OS/image-20220608230427978.png" alt="image-20220608230427978" style="zoom:40%;" /></li></ol><h2 id="基本分页存储管理方式"><a class="markdownIt-Anchor" href="#基本分页存储管理方式"></a> 基本分页存储管理方式</h2><ol><li><p>页面</p><ol><li>页面实现：内存分为等长页面，称之为块/页帧；进程的地址空间划分成等长页，页与页面通常等长；程序在内存中存放时，页内连续、页见不一定连续。</li><li>页内碎片：进程的最后一页经常装不满一块而形成了不可利用的碎片</li></ol><img src="/image/OS/image-20220608231119512.png" alt="image-20220608231119512" style="zoom:40%;" /><ol start="3"><li>页面大小：应是2的幂，通常为512 B～8 KB</li></ol></li><li><p>地址结构：分页地址中的地质结构如下：</p><img src="/image/OS/image-20220608231305512.png" alt="image-20220608231305512" style="zoom:40%;" /><p>它含有两部分：前一部分为页号P，后一部分为位移量W（或称为页内地址d）。图中的地址长度为32位，其中0～11位为页内地址，即每页的大小为4 KB；12～31位为页号，地址空间最多允许有1M页。</p></li><li><p>页表：记录了相应页在内存中对应的物理块号，进程执行时，通过查找该表，即可找到每页在内存中的物理块号。</p><ul><li>作用：实现从页号到物理块号的地址映射。</li></ul></li><li><p>地址变换机构</p><ol><li><p>页表大多<strong>驻留在内存中</strong>，系统中只设置一个页表寄存器PTR，在其中存放页表在内存的始址和页表的长度。进程未执行，页表始址和长度存放在PCB中，调用时装入PTR</p><img src="/image/OS/image-20220608231913037.png" alt="image-20220608231913037" style="zoom:50%;" /></li><li><p>快表（联想寄存器）：具有<strong>并行查寻能力</strong>的特殊<strong>高速缓冲寄存器</strong></p><img src="/image/OS/image-20220608232205639.png" alt="image-20220608232205639" style="zoom:50%;" /></li></ol></li><li><p>两级和多级页表：解决页表过大问题</p><ol><li><p>解决页表过大两种方法：</p><ul><li>离散分配方式解决难以找到一块连续大内存问题</li><li>只将需要部分页表调入内存，不需要则驻留在硬盘上，需要再调入</li></ul></li><li><p>二级页表：将页表分页并离散分配到物理块中，并为离散分配的页表建立外层页表（存放下层页表的物理地址），于是逻辑地址变为：外层页号+外层页内地址+页内地址</p><p>需为外层页表增加寄存器存放外层页表始址，并利用逻辑地址的外层页号作为外层页表的索引</p></li><li><p>多级页表：对外层页表再进行分页。</p></li></ol></li><li><p>页表特点：</p><ol><li>优点：分配和回收简单、消除“碎片”问题、可实现虚存、共享；</li><li>缺点：页面划分不考虑程序逻辑结构、共享受限、二次访内，慢。</li></ol></li></ol><h2 id="基本分段存储管理方式"><a class="markdownIt-Anchor" href="#基本分段存储管理方式"></a> 基本分段存储管理方式</h2><ol><li><p>分段方式满足的需求：</p><ol><li>方便编程：用户把作业按<strong>逻辑关系</strong>划分为若干段，每段都是从0开始编址。</li><li>信息共享：对程序和数据共享都是以信息的逻辑单位为基础的。</li><li>信息保护：对信息的逻辑单位进行保护。</li><li>动态增长：其他存储方式难以应付数据段的增长，分段存储管理可以实现。</li><li>动态链接：动态链接要求以段作为管理的单位。</li></ol></li><li><p>基本原理</p><ol><li><p>分段：将用户程序空间按逻辑划分为几段，每个<strong>段内连续编址</strong>，每个<strong>程序段</strong>都有一个<strong>段名</strong>，且有一个<strong>段号</strong>。段号从0开始，每一段段内也从0开始编址，<strong>段内地址是连续的，而段间是不一定连续编址的</strong></p><p>分段地址结构：<img src="/image/OS/image-20220608233800589.png" alt="image-20220608233800589" style="zoom:50%;" /></p></li><li><p>以段为单位分配内存，段内连续完整，但各段之间可以不连续存放</p></li><li><p>段式逻辑地址二维：段号+段内地址</p></li><li><p>每个进程一张段表，实现地址转换、信息保护、共享、扩充、动态链接等</p></li></ol></li><li><p>段表：为使程序能正常运行，要能从物理内存中找出每个逻辑段所对应的位置，系统中为每个进程建立一张段映射表，常见的是将段表放在内存中。</p><img src="/image/OS/image-20220608233937900.png" alt="image-20220608233937900" style="zoom:50%;" /></li><li><p>地址变换机构：</p><ol><li><p>段表寄存器，用于存放段表始址和段表长度TL</p></li><li><p>检测段号越界中断、段内地址越界中断</p><img src="/image/OS/image-20220608234114792.png" alt="image-20220608234114792" style="zoom:50%;" /></li><li><p>联想寄存器：保存最近常用的段表项，类似于快表</p></li></ol></li><li><p>段式特点：</p><ol><li>优点：符合用户观点和程序逻辑，易于保护、共享、动态链接和动态扩充</li><li>缺点：分配回收类似可变式分区策略，复杂；存在二次访内，慢；有外部碎片，可能需要移动开销</li></ol></li><li><p>分段的信息共享</p><img src="/image/OS/image-20220608234710453.png" alt="image-20220608234710453" style="zoom:50%;" /><img src="/image/OS/image-20220608234721852.png" alt="image-20220608234721852" style="zoom:50%;" /></li></ol><h2 id="分页-分段主要区别"><a class="markdownIt-Anchor" href="#分页-分段主要区别"></a> 分页、分段主要区别</h2><ol><li>页是信息的<strong>物理单位</strong>，分页仅仅是由于<strong>系统管理的需要</strong>而不是用户的需要。段则是信息的<strong>逻辑单位</strong>，它含有一组其意义相对完整的信息。分段的目的是为了能<strong>更好地满足用户的需要</strong>。</li><li>页的大小固定且由系统决定，段的长度却不固定，决定于用户所编写的程序，通常由编译程序在对源程序进行编译时，根据信息的性质来划分。</li><li>分页作业地址空间为1维，分段标住地址为二维，即段名+段内地址</li></ol><h2 id="段页式存储管理方式"><a class="markdownIt-Anchor" href="#段页式存储管理方式"></a> 段页式存储管理方式</h2><ol><li><p>段页式引入：</p><ul><li>段式优点：便于共享和保护，动态伸缩和链接</li><li>页式优点：消除碎片问题，分配和回收简单</li><li>段页式：结合两者优点</li></ul></li><li><p>段页式存储管理实现</p><ol><li><p>基本原理：先将用户程序分为若干个段（<strong>每个进程都有段表</strong>），再把每个段分成若干个页（<strong>每个段都有一张自己的页表</strong>），并为每一个段赋予段名。</p></li><li><p>内存分页面、存储管理的分配单位是页</p></li><li><p>逻辑地址：&lt;段号 S，页号 P，页内偏移 W&gt;</p><img src="/image/OS/image-20220609102538297.png" alt="image-20220609102538297" style="zoom:50%;" /></li><li><p>段表基址寄存器：保存正在运行程序的段表首址</p><p>段表限长寄存器：保存正在运行程序的段表长度</p><p>快表：一组联想寄存器（快段表+快页表）</p><img src="/image/OS/image-20220609102806368.png" alt="image-20220609102806368" style="zoom:50%;" /></li></ol></li><li><p>地址变换过程（须配置一个段表寄存器，其中存放段表始址和段表长TL）</p><img src="/image/OS/image-20220609102943298.png" alt="image-20220609102943298" style="zoom:50%;" /><ol><li>先通过逻辑地址的段号查段表，需要越界检查；</li><li>通过段表查出页表首址，在使用页号获取块号，并与块内地址组成物理地址。</li></ol><ul><li>注：为了获取一条指令或数据，需要三次访存：段表、页表、取指令/数据。故地址变换机构设高速缓冲寄存器，需同时利用段号和页号检索高速缓存。</li></ul></li><li><p>段页式特点：</p><ol><li>分配与回收（同页式）</li><li>共享与保护、动态伸缩、动态链接（同段式）</li><li>三次访内，必须提供联想寄存器支持</li><li>碎片n倍于页式（n为程序段数）</li></ol></li></ol><h2 id="虚拟存储器的基本概念"><a class="markdownIt-Anchor" href="#虚拟存储器的基本概念"></a> 虚拟存储器的基本概念</h2><ol><li>出现原因：<ul><li>有的作业很大，超过了内存总量，作业不能全部装入内存导致作业无法运行</li><li>大量作业要求运行但内存容量不足，只能将少数作业装入内存先运行</li></ul></li><li>常规存储器管理方式的特征：一次性（作业运行前需要一次性装入）、驻留性（作业装入后一直驻留直至结束）</li><li>虚拟存储器定义：基于局部性原理，应用程序在运行之前，没有必要全部装入内存，仅须将那些当前要运行的少数页面或段先装入内存便可运行，其余部分暂留在盘上。<ul><li>请求调页（段）：如果程序所要访问的页(段)尚未调入内存(称为缺页或缺段)，此时程序应利用OS所提供的请求调页(段)功能，将它们调入内存，以使进程能继续执行下去。</li><li>页面置换：如果此时内存已满，无法再装入新的页(段)，则还须再利用页(段)的置换功能，将内存中暂时不用的页(段)调至盘上，腾出足够的内存空间后，再将要访问的页(段)调入内存，使程序继续执行下去。</li></ul></li><li>虚拟存储器的实现方法<ol><li>分页请求系统：在分页系统的基础上，增加了请求调页功能和页面置换功能所形成的页式虚拟存储系统。<ol><li>硬件支持：请求分页的页表机制、缺页中断机构、地址变换机构</li><li>软件支持：实现请求调页的软件和实现页面置换的软件</li></ol></li><li>分段请求系统：在分段系统的基础上，增加了请求调段及分段置换功能后所形成的段式虚拟存储系统<ol><li>硬件支持：请求分段的段表机制、缺段终端机构、地址变换机构</li></ol></li></ol></li><li>虚拟存储器的特征：多次性（一个作业被分成多次调入内存运行，虚拟存储器最重要的特征）、对换性（允许在作业的运行过程中进行换进、换出）、虚拟性（从逻辑上扩充内存容量）</li><li>离散分配 -&gt; 多次性和对换性 -&gt; 虚拟性</li></ol><h2 id="请求分页存储管理方式"><a class="markdownIt-Anchor" href="#请求分页存储管理方式"></a> 请求分页存储管理方式</h2><ol><li><p>页表机制：应用程序的一部分调入内存，还有一部分仍在盘上，故须在页表中再增加若干项，供程序(数据)在换进、换出时参考。</p><img src="/image/OS/image-20220609105956281.png" alt="image-20220609105956281" style="zoom:50%;" /><p>当没有虚存时只存页号和物理页号。</p><p>P：是否已经调入内存；A：本页在一段时间内访问了几次；M：本页调入后是否修改</p><img src="/image/OS/image-20220609110134843.png" alt="image-20220609110134843" style="zoom:33%;" /></li><li><p>缺页中断机构：访问的页面不在内存时，便产生一缺页中断</p><ul><li><p>缺页中断是在指令执行期间，发现所要访问的指令或数据不在内存时所产生和处理的。</p></li><li><p>一条指令在执行期间，可能产生多次缺页中断。</p><p>涉及6次缺页中断的指令：</p><img src="/image/OS/image-20220609110401161.png" alt="image-20220609110401161" style="zoom:33%;" /></li></ul></li><li><p>地址变换机构：在分页系统地址变换机构的基础上，再为实现虚拟存储器而增加了某些功能而形成的，如产生和处理缺页中断，以及从内存中换出一页的功能</p><ul><li><p>地址变换时，先检索快表，找到则修改表项中的访问位，对于写指令还要设置修改位；</p></li><li><p>然后利用页表项中给出的物理块号和页内地址形成物理地址</p><img src="/image/OS/image-20220609110803086.png" alt="image-20220609110803086" style="zoom:50%;" /></li></ul></li><li><p>内存分配策略和分配算法</p><p>在为进程分配内存时，涉及到三个问题：最小物理块数确定、物理块的分配策略、物理块分配算法</p><ol><li>最小物理块确定：<ul><li>单地址指令 + 直接寻址，最少需要两块（一块指令、一块数据）</li><li>间接寻址，最少三块</li><li>指令多于两个字节，需要更多</li></ul></li><li>物理块分配策略<ol><li>固定分配局部置换：每个进程分配一定数目的物理块，置换从其中选择。困难：难以确定每个进程分配多少。</li><li>可变分配全局置换：某进程缺页时，系统从空闲物理块队列中取出一个物理块分配给该进程，并将调入的页装入。当空闲块用完后，OS从内存中选择一页调出，该页可能是任一进程的页。</li><li>可变分配局部置换：置换时只允许从该进程的页面中调出。缺页率过高时分配额外的块。</li></ol></li><li>物理块分配算法<ol><li>平均分配：将可供分配的物理块平均分配给各进程</li><li>按比例分配：根据进程大小按比例分配物理块</li><li>考虑优先权的分配：把内存中可供分配的所有物理块分成两部分：一部分按比例地分配给各进程；另一部分则根据各进程的优先权，适当地增加其相应份额后，分配给各进程。</li></ol></li></ol></li><li><p>调页策略</p><ol><li><p>调入页面时机：预调页策略、请求调页策略</p></li><li><p>确定从何处调入页面</p><ul><li>系统拥有足够对换区，则全部从对换区调入</li><li>缺少足够的对换区时，不会被修改的文件全从文件区调入，可能被修改的部分换出时换到对换区</li></ul></li><li><p>页面调入过程</p><p>访问页面未在内存→向CPU发出缺页中断→中断处理程序保留CPU环境→转入缺页中断处理程序→查页表调入（如已满需要置换）</p><p>整个页面的调入过程对用户是透明的。</p></li></ol></li></ol><h2 id="页面置换算法"><a class="markdownIt-Anchor" href="#页面置换算法"></a> 页面置换算法</h2><ol><li>最佳置换算法：不可能实现，用于评价其他算法</li><li>FIFO置换算法（会产生Belady现象，即物理块越多，缺页率越高）</li><li>LRU置换算法：需要硬件支持（寄存器或栈）</li><li>Clock置换算法：设置一访问位，访问则置1，当置换时循环检查，如为1则置0，如为0则置换。</li><li>改进Clock置换算法：不但考虑使用情况，也考虑置换代价。由访问位A和修改位M共同决定。</li></ol><h2 id="请求分段存储管理方式"><a class="markdownIt-Anchor" href="#请求分段存储管理方式"></a> 请求分段存储管理方式</h2><ol><li><p>段表机制：应用程序的一部分调入内存，还有一部分仍在盘上，故须在段表中再增加若干项，供程序(数据)在换进、换出时参考。</p><img src="/image/OS/image-20220609113537014.png" alt="image-20220609113537014" style="zoom:50%;" /><img src="/image/OS/image-20220609113736640.png" alt="image-20220609113736640" style="zoom:50%;" /></li><li><p>缺段中断机构：在一条指令的执行期间，产生和处理中断，以及在一条指令执行期间，可能产生多次缺段中断。但由于分段是信息的逻辑单位，因而不可能出现一条指令被分割在两个分段中和一组信息被分割在两个分段中的情况。</p><img src="/image/OS/image-20220609113854325.png" alt="image-20220609113854325" style="zoom:50%;" /></li><li><p>地址变换机构：<strong>请求分段系统中的地址变换机构是在分段系统地址变换机构的基础上形成的</strong>。因为被访问的段并非全在内存，所以在地址变换时，若发现所要访问的段不在内存，必须先<strong>将所缺的段调入内存</strong>，并<strong>修改段表</strong>，然后才能<strong>再利用段表进行地址变换</strong>。为此，在地址变换机构中又增加了某些功能，如缺段中断的请求及处理等。</p><img src="/image/OS/image-20220609114101180.png" alt="image-20220609114101180" style="zoom:50%;" /></li><li><p>分段的共享与保护：</p><ol><li><p>共享段表：为了实现分段共享，可在系统中配置一张共享段表，所有各共享段都在共享段表中占有一表项。</p><img src="/image/OS/image-20220609114312540.png" alt="image-20220609114312540" style="zoom:50%;" /></li><li><p>共享段的分配：由于共享段是供多个进程所共享的，因此，对共享段的内存分配方法与非共享段的内存分配方法有所不同。</p><ul><li>第一个请求使用该共享段进程，由系统为该共享段分配一物理区，再把共享段调入。同时填写共享段表。</li><li>其他使用该共享段的进程，在调用进程的段表增加一表项，填写共享段的物理地址；共享段的段表中增加一表项并修改进程计数</li></ul></li><li><p>共享段的回收：撤销该进程段表中共享段对应的表项；修改进程计数，若为0则系统回收物理内存。</p></li><li><p>分段保护：</p><ul><li>越界检查：段号是否大于段表长度；段内地址是否大于段长</li><li>存取控制检查</li></ul></li></ol></li></ol><h2 id="总结与习题"><a class="markdownIt-Anchor" href="#总结与习题"></a> 总结与习题</h2><p><img src="/image/OS/image-20220609114823870.png" alt="image-20220609114823870" /></p><ol><li><p>静态重定位是在作业的(A)中进行的，动态重定位是在作业的(B)中进行的。</p></li><li><p>静态链接是在(A)中进行的，动态链接是在作业的(B)或©中进行的，且(B)进行链接，可以使内存利用率最高。</p></li><li><p>对重定位存储管理方式，应(A)，当程序执行时，是(B)与(A)中的©相加得到(D)。</p><p>A. (1) 在整个系统中设置一个重定位寄存器 (2) 为每道程序设置 (3) 为每道程序设置两个 (4) 为每个程序段和数据段都设置一个</p><p>B, C, D (1) 物理地址 (2) 有效地址 (3) 间接地址 (4) 起始地址</p></li><li><p>段页式虚拟地址空间是(A)维的。</p></li><li><p>一个计算机系统的虚拟存储器的最大容量是由(A)确定的，实际容量是由(B)确定的。</p><p>A, B (1)计算机字长 (2)内容容量 (3)硬盘容量 (4)内存容量与硬盘容量之和</p></li><li><p>在请求调页系统中，内存分配有(A)和(B)两种策略，(A)的缺点是可能导致频繁出现缺页中断造成CPU性能下降。</p><p>A, B (1) 首次适应 (2) 最佳适应 (3) 固定分配 (4) 可变分配</p></li><li><p>在虚拟存储器中，采用(A)提高(B)的速度。</p><p>A (1) 高速辅助存储器 (2) 高速光盘存储器 (3) 快速通道 (4) 高速缓冲存储器</p><p>B (1) 连接编辑 (2) 虚空间分配 (3) 动态地址翻译 (4) 动态链接</p></li></ol><p>答案：</p><ol><li><p>装入过程 执行过程 2. A.装入程序之前 B.装入某段程序 C.调用某段程序</p></li><li><p>A.(1) B.(2) C.(4) D. (1) 4. A.2 5.A.(1) B.(4) 6.A.(3)B.(4) 7.A.(4) B.(3)</p></li></ol><h1 id="第五章-设备管理"><a class="markdownIt-Anchor" href="#第五章-设备管理"></a> 第五章 设备管理</h1><h2 id="io系统"><a class="markdownIt-Anchor" href="#io系统"></a> I/O系统</h2><ol><li><p>I/O系统的功能：设备分配与回收、设备启动、设备事件处理、设备缓冲区管理、实现虚拟设备、磁盘调度</p></li><li><p>外设分类图例</p><img src="/image/OS/image-20220608100626373.png" alt="image-20220608100626373" style="zoom:50%;" /></li><li><p>设备的分类：</p><ol><li><p>按设备使用类型分类：存储设备、输入输出设备</p></li><li><p>按传输速率分类：低速、中速（打印机）、高速（磁盘）设备</p></li><li><p>按信息交换单位：字符设备、块设备</p></li><li><p>按共享属性：独占设备、共享设备、虚拟设备</p></li><li><p>单通路I/O系统、多通路I/O系统</p><img src="/image/OS/image-20220608100909455.png" alt="image-20220608100909455" style="zoom:33%;" /><img src="/image/OS/image-20220608100920567.png" alt="image-20220608100920567" style="zoom:33%;" /></li></ol></li></ol><h2 id="io控制方式"><a class="markdownIt-Anchor" href="#io控制方式"></a> I/O控制方式</h2><ol><li>程序I/O方式（忙-等待方式）</li><li>中断驱动I/O控制方式</li><li>直接存储器访问（DMA）I/O控制方式</li><li>I/O通道控制方式</li></ol><h2 id="缓冲管理"><a class="markdownIt-Anchor" href="#缓冲管理"></a> 缓冲管理</h2><ol><li><p>目的：为了解决CPU与I/O设备速度不匹配的矛盾；减少对CPU的中断频率，放宽CPU中断响应时间的限制；提高CPU与I/O设备之间的并行性。</p></li><li><p>单缓冲：每当用户进程发出一I/O请求时，操作系统便在主存中为之分配一缓冲区，在块设备输入时，从磁盘把一块数据输入到缓冲区，之后操作系统将该缓冲区中的数据传送到用户区。</p><img src="/image/OS/image-20220608102225992.png" alt="image-20220608102225992" style="zoom:50%;" /></li><li><p>双缓冲：在设备输入时，先将数据送入第一缓冲区，装满后便转向第二缓冲区。此时操作系统可以从第一缓冲区中移出数据，并送入用户进程。接着由CPU对数据进行计算。</p><img src="/image/OS/image-20220608102234576.png" alt="image-20220608102234576" style="zoom:50%;" /></li><li><p>双机通讯时如果仅配置单缓冲，则同一时刻只能单方向数据传输。为实现双向数据传输，必须在两台机器中设置两个缓冲区，一个用来发送，一个用来接受。</p><img src="/image/OS/image-20220608102400568.png" alt="image-20220608102400568" style="zoom:50%;" /></li><li><p>循环缓冲的组成</p><ol><li><p>多个缓冲区。在循环缓冲中包括多个缓冲区，其每个缓冲区的大小相同。作为输入的多缓冲区可分为三种类型：用于装输入数据的空缓冲区R、已装满数据的缓冲区G以及计算进程正在使用的现行工作缓冲区C</p><img src="/image/OS/image-20220608102524425.png" alt="image-20220608102524425" style="zoom:50%;" /></li><li><p>多个指针。作为输入的缓冲区可设置三个指针：用于指示计算进程下一个可用缓冲区G的指针Nextg、指示输入进程下次可用的空缓冲区R的指针Nexti，以及用于指示计算进程正在使用的缓冲区C的指针Current。</p></li></ol></li><li><p>缓冲池</p><ol><li><p>组成：三个缓冲队列：空缓冲队列emq、输入队列inq和输出队列outq；四个工作缓冲区：用于收容输入数据的工作缓冲区hin、用于提取输入数据的工作缓冲区sin、用于收容输出数据的工作缓冲区hout、用于提取输出数据的工作缓冲区sout</p><img src="/image/OS/image-20220608103053606.png" alt="image-20220608103053606" style="zoom:50%;" /></li><li><p>收容输入：输入进程需要输入数据时，调用Getbuf(emq)过程，从空缓冲队列emp队首摘下缓冲区作为收容输入工作缓冲区hin,然后输入数据，装满后调用Putbuf(inq, hin)过程，将缓冲区挂载在输入队列inq上。</p></li><li><p>收容输出、提取输出、提取输入略。</p></li></ol></li></ol><h2 id="io软件"><a class="markdownIt-Anchor" href="#io软件"></a> I/O软件</h2><ol><li><p>目标：与具体设备无关；统一命名（所有软件都以逻辑名称访问设备）、对错误处理（低层软件能够解决的错误不让高层软件感知）、缓冲技术、设备分配和释放、I/O控制方式（屏蔽DMA等不同I/O控制方式的差异，向高层软件提供统一接口）</p></li><li><p>I/O软件四个层次：</p><ol><li><p>用户层软件（连接用户层）：实现用户交互接口，可以直接调用库函数（不在操作系统）</p></li><li><p>设备独立性软件（将具体设备隔离）：应用程序独立于具体使用的物理设备。为了实现设备独立性而引入了逻辑设备（应用程序使用）和物理设备（实际执行使用）这两个概念。</p><ol><li><p>实现设备独立性的好处：设备分配灵活、易于实现I/O重定向（I/O操作设备可以更还而不必改变应用程序）</p></li><li><p>设备独立性软件的主要功能：执行所有设备的公有操作、向用户层（或文件层）软件提供统一接口</p></li><li><p>逻辑设备名到物理设备名映射实现：逻辑设备表（LUT），左为系统使用，右为用户使用</p><img src="/image/OS/image-20220608111947847.png" alt="image-20220608111947847" style="zoom:50%;" /></li></ol></li><li><p>设备驱动程序</p><ol><li><p>主要任务：接受上层软件发来的I/O要求并转化为具体要求，发送给设备控制器，启动设备并执行</p></li><li><p>功能：</p><ol><li>接受由设备独立性软件发来的命令和参数，将抽象要求转化为具体要求</li><li>检查用户I/O请求合法性</li><li>发出I/O命令</li><li>及时响应由控制器或通道发来的中断请求</li><li>自动构建通道程序</li></ol></li><li><p>设备驱动程序（属于<strong>低级的系统例程</strong>）的特点：</p><ol><li>驱动程序主要是在请求I/O的进程与设备管理器之间的一个通信、转换程序</li><li>不同类型设备配置不同的驱动程序</li><li>驱动程序与I/O设备采用的I/O控制方式紧密相关</li><li>其中一部分必须用汇编语言书写</li></ol></li><li><p>设备驱动程序处理过程</p><ol><li>将抽象要求转换为具体要求</li><li>检查I/O请求的合法性</li><li>读出和检查设备状态</li><li>传递必要参数</li><li>工作方式设置</li><li>启动I/O设备</li></ol></li></ol><ul><li>注：驱动程序发出I/O命令以后，基本I/O操作是在设备控制器控制下完成的，需要一定时间，此时驱动程序将自己阻塞起来，直到中断到来唤醒。</li></ul></li><li><p>中断处理程序</p><ol><li><p>处理过程：</p><ol><li><p>唤醒被阻塞的驱动（程序）进程</p></li><li><p>保护被中断进程的CPU环境</p><ul><li>硬件自动将被中断进程的CPU现场信息(包括处理机状态字PSW、程序计数器(PC)和所有的CPU寄存器，如通用寄存器、段寄存器等内容)都压入中断栈中</li><li><img src="/image/OS/image-20220608113408468.png" alt="image-20220608113408468" style="zoom:50%;" /></li></ul></li><li><p>转入相应设备处理程序</p></li><li><p>中断处理</p></li><li><p>恢复被中断进程的现场</p><img src="/image/OS/image-20220608113548495.png" alt="image-20220608113548495" style="zoom:50%;" /></li></ol></li></ol></li></ol></li></ol><h2 id="设备分配"><a class="markdownIt-Anchor" href="#设备分配"></a> 设备分配</h2><ol><li><p>设备分配中的数据结构</p><ol><li><p>系统设备表（SDT，整个系统一张）</p></li><li><p>设备控制表（DCT，每个设备一张）：记录本设备的情况，除指示设备类型与设备标识字段外，还包括：</p><ol><li>设备队列队首指针：记录请求本设备但未得到满足的进程</li><li>设备状态</li><li>与设备连接的控制器表指针</li><li>重复执行次数（最大传送失败次数）</li></ol></li><li><p>控制器控制表（COCT，每个控制器一张）</p></li><li><p>通道控制表（CHCT，每个通道一张）</p><img src="/image/OS/image-20220608113910228.png" alt="image-20220608113910228" style="zoom:33%;" /></li></ol></li><li><p>设备的固有属性</p><ol><li>独占性（临界资源）</li><li>共享性</li><li>可虚拟设备（设备本身是独占设备，经过某种技术处理后改造成虚拟设备）</li></ol></li><li><p>设备分配算法：先来先服务、优先级高者优先</p><img src="/image/OS/image-20220608114702583.png" alt="image-20220608114702583" style="zoom:50%;" /></li><li><p>独占设备的分配程序</p><ol><li>分配设备：根据I/O请求中的物理设备名，查找SDT，找出该设备的DCT，根据DCT状态字段，判断是否忙：忙则将进程PCB挂载到设备队列上；不忙则判断安全性。</li><li>分配控制器</li><li>分配通道</li></ol><ul><li>改进：欲增加设备独立性，进程使用逻辑设备名请求I/O，这样首先从SDT中找出第一个该类的DCT，若忙则找第二个。</li><li>改进：采用多通路I/O系统结构。</li></ul></li><li><p>SPOOLing技术</p><ol><li><p>SPOOLing技术可将一台物理I/O设备虚拟为多台逻辑I/O设备，允许多个用户共享一台物理I/O设备。</p></li><li><p>SPOOLing系统三个组成部分</p><ol><li><p>输入井和输出井：在磁盘上开辟的两个大存储空间。输入井是模拟脱机输入时的磁盘设备，用于暂存I/O设备输入的数据；输出井是模拟脱机输出时的磁盘，用于暂存用户程序的输出数据。</p></li><li><p>输入缓冲区和输出缓冲区：缓和CPU和磁盘之间速度不匹配矛盾，在<strong>内存</strong>中开辟的两个缓冲区。</p></li><li><p>输入进程和输出进程：利用两个进程来模拟脱机I/O时的外围控制机。</p><img src="/image/OS/image-20220608115521042.png" alt="image-20220608115521042" style="zoom:50%;" /></li></ol></li><li><p>共享打印机</p><ol><li>打印机是经常要用到的输出设备，属于独占设备。利用SPOOLing技术，可将之改造为一台可供多个用户共享的设备，从而提高设备的利用率，也方便了用户。</li><li>用户进程请求打印输出时，SPOOLing系统同意为它打印输出，但并不真正立即把打印机分配给该用户进程，而只为它做两件事：<ol><li>由输出进程在输出井中为之申请一个空闲磁盘块区，并将要打印的数据送入其中；</li><li>输出进程再为用户进程申请一张空白的用户请求打印表，并将用户的打印要求填入其中，再将该表挂到请求打印队列上。</li><li>如果还有进程要求打印输出，系统仍可接受该请求，也同样为该进程做上述两件事。</li></ol></li><li>如果打印机空闲，输出进程将从请求打印队列的队首取出一张请求打印表，根据表中的要求将要打印的数据，从输出井传送到内存缓冲区，再由打印机进行打印。</li></ol></li><li><p>SPOOLing技术的特点</p><ol><li>提高了I/O的速度：从低速I/O设备进行的I/O操作，演变为对输入输出井中的数据存取。</li><li>将独占设备改造为共享设备。</li><li>实现了虚拟设备的功能。</li></ol></li></ol></li></ol><h2 id="磁盘存储器的管理"><a class="markdownIt-Anchor" href="#磁盘存储器的管理"></a> 磁盘存储器的管理</h2><img src="/image/OS/image-20220608120318223.png" alt="image-20220608120318223" style="zoom:33%;" /><ol><li>磁盘地址转换：三维地址（c 柱面号, h 磁头号, s 扇区号）↔ 一维地址（b 块号）</li><li>磁盘的类型：固定头磁盘（每条磁道都有读写头）、移动头磁盘（仅能以串行方式读/写）</li><li>磁盘访问时间：<ol><li>寻道时间<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>T</mi><mi>s</mi></msub></mrow><annotation encoding="application/x-tex">T_s</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">s</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>：约几十毫秒</li><li>旋转延迟时间<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>T</mi><mi>r</mi></msub></mrow><annotation encoding="application/x-tex">T_r</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.02778em;">r</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>：约十几毫秒</li><li>数据传输时间<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>T</mi><mi>t</mi></msub></mrow><annotation encoding="application/x-tex">T_t</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.2805559999999999em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">t</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>：约几毫秒</li></ol></li><li>对寻道时间进行优化：<ol><li>FCFS</li><li>SSTF（每次找最近的）</li><li>SCAN（不但考虑最近的，还考虑方向）</li></ol></li><li>磁盘高速缓存（一组在<strong>逻辑上属于磁盘</strong>，而<strong>物理上是驻留在内存</strong>中的盘块）<ol><li>数据交付方式：先查磁盘高速缓冲器，若未命中则查看磁盘</li><li>置换算法：<ol><li>考虑因素：访问频率、可预见性、一致性</li><li>对于那些会严重影响到数据一致性的盘块数据和很久都可能不再使用的盘块数据，都放在LRU链的头部，使它们能被优先写回磁盘</li></ol></li><li>周期性写回磁盘：每隔一段时间强制写回磁盘</li></ol></li><li>提高I/O速度的其他方法<ol><li>提前读：读当前块的同时，还要求将下一个盘块(提前读的块)中的数据也读入缓冲区</li><li>延迟写：不立即将该缓冲区A中的数据写入磁盘，而是将它挂在空闲缓冲区队列的末尾</li><li>优化物理块分布：先以磁道为单位进行写，连续分配读的快。</li></ol></li></ol><h2 id="习题"><a class="markdownIt-Anchor" href="#习题"></a> 习题</h2><ol><li><img src="/image/OS/image-20220612222538017.png" alt="image-20220612222538017" style="zoom:50%;" /></li><li><img src="/image/OS/image-20220612222601333.png" alt="image-20220612222601333" style="zoom:50%;" /></li><li><img src="/image/OS/image-20220612222617677.png" alt="image-20220612222617677" style="zoom:50%;" /></li><li><img src="/image/OS/image-20220612222733171.png" alt="image-20220612222733171" style="zoom:50%;" /></li><li><img src="/image/OS/image-20220612222834703.png" alt="image-20220612222834703" style="zoom:50%;" /></li><li></li></ol><h1 id="第六章-文件管理"><a class="markdownIt-Anchor" href="#第六章-文件管理"></a> 第六章 文件管理</h1><h2 id="文件及文件系统"><a class="markdownIt-Anchor" href="#文件及文件系统"></a> 文件及文件系统</h2><ol><li>文件的三大特点：可保存、具有标识名、逻辑相关且有完整意义</li><li>文件系统：OS中负责处理文件相关事宜的程序和数据结构。</li><li>文件的结构<ol><li>逻辑结构（用户的观点）：连续存储、独立实体</li><li>物理结构（实现的观点）：驻存在存储介质上的文件结构，未必连续</li></ol></li></ol><h2 id="逻辑结构"><a class="markdownIt-Anchor" href="#逻辑结构"></a> 逻辑结构</h2><ol><li><p>文件逻辑结构的类型</p><ol><li><p>有结构文件（记录文件）：由一个以上的记录类构成的文件。</p><ul><li>定长记录，所有记录长度相同，处理方便，但浪费空间</li><li>不定长记录：记录长度不相同，节约空间</li></ul></li><li><p>无结构文件（流式文件）：无需多余的说明信息，长度以字节为单位。</p><p>有结构文件：字节—&gt;记录—&gt;文件</p><p>无结构文件：字节—&gt;文件</p></li></ol></li><li><p>逻辑结构下的文件存取方法：</p><ol><li>顺序存取：严格按照文件信息单位排列顺序存取</li><li>随机存取：每次操作必须确定存取的位置，对于流式文件或定长记录文件容易确定，不定长不好确定。</li><li>按键存取：根据记录关键字的值存取，常用于记录式文件。</li></ol></li></ol><h2 id="物理结构"><a class="markdownIt-Anchor" href="#物理结构"></a> 物理结构</h2><ol><li><p>物理结构：文件在文件存储器中的存储方式</p><ol><li><p>连续结构：文件的全部信息存放在外存的一片连续编号的物理块中，也称连续文件。</p><ol><li><p>优点：简单，支持顺序、随机存取，速度快，磁盘寻道速度时间最少；</p></li><li><p>缺点：不易动态增长，预留空间浪费；不利于文件插入删除；存在外部碎片问题。</p><img src="/image/OS/image-20220607231532776.png" alt="image-20220607231532776" style="zoom:50%;" /></li></ol></li><li><p>串联结构（链接结构）：存放文件信息的每一物理块中有一个指针，指向下一个物理块，这个指针的长度由物理设备的容量决定，通常放在该物理块的开头或结尾。</p><ol><li><p>优点：提高磁盘空间利用率，不存在外部碎片问题；有利于文件插入删除和动态扩充；</p></li><li><p>缺点：存取速度慢，不适合随机存取；指针占用空间；可靠性问题，如指针出错。</p><img src="/image/OS/image-20220607231735683.png" alt="image-20220607231735683" style="zoom:65%;" /></li></ol></li><li><p>索引结构：一个文件的信息存放在若干不连续物理块中，系统为每个文件建立一个专用数据结构－索引表，一个索引表就是磁盘块地址数组,其中第i个条目指向文件的第i块。</p><ol><li><p>优点：保持链接结构优点，解决了缺点，能顺序和随机存取；</p></li><li><p>缺点：索引表本身带来开销。</p><img src="/image/OS/image-20220607231910716.png" alt="image-20220607231910716" style="zoom:65%;" /></li><li><p>多级索引</p><img src="/image/OS/image-20220607231938923.png" alt="image-20220607231938923" style="zoom:65%;" /></li></ol></li></ol></li></ol><h2 id="文件目录管理"><a class="markdownIt-Anchor" href="#文件目录管理"></a> 文件目录管理</h2><ol><li><p>目录管理要求：按名存取；提高目录检索速度；文件共享；允许重名（树状结构）。</p></li><li><p>目录项（文件控制块，FCB）：操作系统为管理文件而设置的数据结构，存放了为管理文件所需的所有有关信息。所有的目录项就构成了文件目录。</p><img src="/image/OS/image-20220607232320427.png" alt="image-20220607232320427" style="zoom:50%;" /></li><li><p>目录结构</p><ol><li><p>单级目录结构</p><p>缺点：查找速度慢、不允许重名、不便于文件共享</p></li><li><p>二级目录：为每一个用户建立单独用户文件目录UFD</p><ol><li><p>优点：简单，解决重名问题</p></li><li><p>缺点：缺乏灵活性，不能反映现实世界多层次关系</p><img src="/image/OS/image-20220607232620669.png" alt="image-20220607232620669" style="zoom:50%;" /></li></ol></li><li><p>多级目录结构（树形目录结构）：由根目录和各级目录组成，为管理上的方便，除根目录外，其它各级目录均以文件的形式组成目录文件。</p><p>根目录中的每个目录项可以对应一个目录文件，也可以对应一个数据文件，同样目录文件中的每个目录项可以对应一个目录文件。也可以对应一个数据文件。如此类推，就形成多级目录结构。</p><img src="/image/OS/image-20220607232756149.png" alt="image-20220607232756149" style="zoom:50%;" /></li></ol></li></ol><h2 id="文件存储空间管理"><a class="markdownIt-Anchor" href="#文件存储空间管理"></a> 文件存储空间管理</h2><ol><li><p>解决重要问题：如何为新创建文件分配存储空间。分配方式：连续分配、离散分配</p></li><li><p>空闲表法：属于连续分配方式，每个文件分配一块连续的存储空间，外存的所有空闲区建立一张空闲表。</p><img src="/image/OS/image-20220607232946354.png" alt="image-20220607232946354" style="zoom:50%;" /></li><li><p>空闲链表法</p><ol><li><p>空闲盘块链：每一个空闲物理块上都有一个指针，把所有的空闲块通过该指针链接起来，形成一个链表，文件系统只需记住该链表的首结点指针；分配：从链首摘下空闲块分配；删除：插入末尾</p><img src="/image/OS/image-20220607233215283.png" alt="image-20220607233215283" style="zoom:50%;" /></li><li><p>空闲盘区链：把所有的空闲盘区（每个盘区可包含多个盘块）链接起来。</p></li></ol></li><li><p>位示图法</p><ul><li><p>适合于小磁盘，适合找连续的空间</p><img src="/image/OS/image-20220607233156614.png" alt="image-20220607233156614" style="zoom:65%;" /></li></ul></li><li><p>文件的存取控制</p><ol><li><p>存取控制矩阵</p><ul><li>逻辑简单，实现困难，二维矩阵大且验证耗时，可以按行或列分解</li></ul><img src="/image/OS/image-20220607233437726.png" alt="image-20220607233437726" style="zoom:50%;" /></li><li><p>存取控制表：把用户分成三类：文件主、同组用户和其它用户，每类用户的存取权限为可读、可写、可执行以及它们的组合；每个文件一张表存放在文件FCB中，列出所有用户对文件的访问权限。大部分系统采用。</p></li></ol></li></ol><h2 id="文件共享"><a class="markdownIt-Anchor" href="#文件共享"></a> 文件共享</h2><ol><li>外存共享（用户）<ol><li>同名共享：通过权限表（ACL）实现</li><li>不同名共享：通过符号连接计数（如不同名文件实际指向统一文件）</li></ol></li><li>内存共享（进程）<ol><li>共享内存中的文件FCB</li><li>共享文件的读写指针</li></ol></li></ol><h2 id="习题-2"><a class="markdownIt-Anchor" href="#习题-2"></a> 习题</h2><ol><li><img src="/image/OS/image-20220612232146470.png" alt="image-20220612232146470" style="zoom:50%;" /></li><li><img src="/image/OS/image-20220612231858150.png" alt="image-20220612231858150" style="zoom:50%;" /></li><li><img src="/image/OS/image-20220612231938987.png" alt="image-20220612231938987" style="zoom:50%;" /></li></ol><p>答案：1 A(1) B(2) C(4) 2 A(2) B(3) C(4) 3 (3)</p>]]></content>
    
    
    <summary type="html">计算机专业课《操作系统》笔记，包括第四~六章。主讲教师：杨志豪.</summary>
    
    
    
    <category term="Courses" scheme="http://aflyingsheep.github.io/categories/Courses/"/>
    
    
    <category term="Courses" scheme="http://aflyingsheep.github.io/tags/Courses/"/>
    
  </entry>
  
  <entry>
    <title>操作系统（一）</title>
    <link href="http://aflyingsheep.github.io/2022/06/07/Review%20notes/OS1/"/>
    <id>http://aflyingsheep.github.io/2022/06/07/Review%20notes/OS1/</id>
    <published>2022-06-07T15:06:07.000Z</published>
    <updated>2023-02-11T13:38:06.412Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="操作系统引论"><a class="markdownIt-Anchor" href="#操作系统引论"></a> 操作系统引论</h1><h2 id="操作系统的定义"><a class="markdownIt-Anchor" href="#操作系统的定义"></a> 操作系统的定义</h2><ol><li>从资源管理的观点：操作系统是控制和管理计算机的软、硬件资源，合理组织计算机的工作流程，以方便用户的程序集合</li><li>从用户的观点：操作系统是配置计算机硬件上的第一层软件，是对硬件系统的第一次扩充</li><li>操作系统的目标：<ol><li>有效性：提高系统资源利用率、提高系统吞吐量</li><li>方便性：方便用户通过OS操纵计算机系统</li><li>可扩充性：适应计算机硬件、体系结构以及应用的发展</li><li>开放性：遵循世界标准规范</li></ol></li><li>操作系统的作用<ol><li>作为用户与计算机硬件系统之间的接口<ul><li>用户可通过三种方式使用计算机：命令方式、系统调用方式、图形窗口方式</li></ul></li><li>作为计算机系统资源的管理者<ul><li>四类资源：处理机管理、存储器管理、I/O设备管理、文件管理</li><li>处理机可执行的指令分为：特权指令（只能由操作系统使用）、非特权指令</li><li>处理机状态划分为：管态、目态</li><li>处理机状态保证了特权指令的正确使用，把OS与用户程序区分开来</li></ul></li><li>实现了计算机资源的抽象<ul><li>裸机上覆盖上一层I/O设备管理软件，隐藏I/O设备操作的细节</li></ul></li></ol></li><li>操作系统发展的主要动力：<ol><li>不断提高计算机资源的利用率</li><li>方便用户</li><li>器件的不断更新迭代</li><li>计算机体系结构的不断发展</li></ol></li></ol><h2 id="操作系统的发展过程"><a class="markdownIt-Anchor" href="#操作系统的发展过程"></a> 操作系统的发展过程</h2><ol><li><p>无操作系统的计算机系统</p><ol><li><p>人工操作方式：打孔纸带</p><p>缺点：用户独占全机、CPU等待人工操作</p></li><li><p>脱机输入输出：解决人机矛盾及CPU和I/O设备速度不匹配的矛盾。将装有用户程序和数据的纸带(或卡片)装入纸带输入机(或卡片机)，在一台外围机的控制下，把纸带(卡片)上的数据(程序)输入到磁带上。当CPU需要这些程序和数据时，再从磁带上将其高速地调入内存。</p><p>减少了CPU空闲时间，提高了I/O速度。</p></li></ol></li><li><p>单道批处理系统</p><ul><li>把一批作业以脱机方式输入到磁带上，并在系统中配上监督程序(Monitor)，在它的控制下使这批作业能一个接一个地连续处理。</li></ul><img src="/image/OS/image-20220610174529383.png" alt="image-20220610174529383" style="zoom:50%;" /><ul><li>特征：自动性、顺序性、单道性</li></ul></li><li><p>多道批处理系统</p><ul><li><p>在该系统中，用户所提交的作业都先存放在外存上并排成一个队列，称为“后备队列”；然后，由作业调度程序按一定的算法从后备队列中选择若干个作业调入内存，使它们共享CPU和系统中的各种资源。</p><img src="/image/OS/image-20220610174938219.png" alt="image-20220610174938219" style="zoom:40%;" /></li><li><p>优点：提高CPU利用率、提高内存和I/O设备利用率、增加系统吞吐量</p></li><li><p>特点：资源利用率高、系统吞吐量大、平均周转时间长、五交互能力</p></li><li><p>需要解决的问题：处理机管理问题、内存管理问题、I/O管理问题、文件管理问题、作业管理问题</p></li></ul></li><li><p>分时系统</p><ol><li>概念<ol><li>分时：CPU时间分段处理</li><li>时间片：CPU的时间段</li><li>响应时间：从终端发出请求到系统给予回答所经历的时间</li></ol></li><li>分时系统的产生：分时系统(Time Sharing System)与多道批处理系统之间有着截然不同的性能差别，它能很好地将一台计算机提供给多个用户同时使用，提高计算机的利用率。用户的需求具体表现在以下几个方面：<ol><li>人机交互</li><li>共享主机</li><li>便于用户上机</li></ol></li><li>分时系统实现中的关键问题<ol><li>及时接收：配备多路卡，用于主机同时接受各用户从终端输入的数据。配置缓冲区缓存用户键入指令</li><li>及时处理：人机交互关键，使用户键入命令后能及时控制自己作业运行。所以各个用户作业都必须在内存中。</li></ol></li><li>分时系统特征：多路性、独立性、及时性、交互性</li></ol></li><li><p>实时系统</p><p>实时系统是指系统能及时(或即时)响应外部事件的请求，在规定的时间内完成对该事件的处理，并控制所有实时任务协调一致地运行。</p><ol><li><p>实时任务</p><ol><li>按任务执行时是否呈现周期性来划分：周期性实时任务、非周期性实时任务</li><li>根据对截止时间的要求来划分：硬实时任务、软实时任务</li></ol></li><li><p>实时系统与分时系统特征比较</p><ol><li>多路性：实时控制系统的多路性则主要表现在<strong>系统周期性地对多路现场信息进行采集，以及对多个对象或多个执行机构进行控制</strong>。而分时系统中的多路性则<strong>与用户情况有关</strong>，时多时少。</li><li>独立性</li><li>交互性：实时信息处理系统虽然也具有交互性，但这里人与系统的交互仅限于访问系统中某些特定的专用服务程序。它不像分时系统那样能向终端用户提供数据处理和资源共享等服务</li><li>及时性</li><li>可靠性：实时系统要求较高</li></ol><img src="/image/OS/image-20220610181108184.png" alt="image-20220610181108184" style="zoom:50%;" /></li></ol></li></ol><h2 id="操作系统的基本特性"><a class="markdownIt-Anchor" href="#操作系统的基本特性"></a> 操作系统的基本特性</h2><p>并发性、共享性、虚拟性、异步性。并发和共享是操作系统两个最基本的特征。</p><ol><li>并发性<ol><li>并行性是指两个或多个事件在同一时刻发生；而并发性是指两个或多个事件在同一时间间隔内发生。</li><li>多道程序环境下，并发性指在一段时间内，宏观上多个程序同时执行，但微观上每一时刻只有一个程序执行</li><li>进程：是指在系统中能独立运行并作为资源分配的基本单位。引入进程的目的：使多个程序能够并发执行</li><li>线程：在一个进程中可以包含若干个线程，可以利用进程拥有的资源。</li><li>OS中，将进程作为资源分配的基本单位，将线程作为独立运行、调度的基本单位。</li></ol></li><li>共享性<ol><li>互斥共享方式：一段时间只允许一个进程（线程）访问资源，如打印机。</li><li>同时访问方式：进程可以交替对该资源进行访问，如磁盘设备。</li></ol></li><li>虚拟性<ol><li>时间复用技术<ol><li>虚拟处理机技术：利用多道程序设计技术，为每道程序建立一个进程，多道程序并发执行，以此分时使用一台处理机。</li><li>虚拟设备技术：将一台I/O设备虚拟为多台逻辑上的I/O设备，允许每个用户占用一台逻辑上的I/O设备。</li></ol></li><li>空分复用技术：将一个频率范围非常宽的信道，划分成多个频率范围较窄的信道，其中的任何一个频带都只供一对用户通话。在计算机中也使用了空分复用技术来<strong>提高存储空间的利用率</strong>。<ol><li>虚拟磁盘技术：一台磁盘虚拟为多台虚拟磁盘</li><li>虚拟存储器技术：空分复用可以利用存储器的空闲空间来存放其它的程序，以提高内存的利用率。虚拟存储技术本质上是内存分时使用，通过时分复用方式，在远小于程序的内存空间中运行。</li></ol></li></ol></li><li>异步性：在单处理机环境下，由于系统中只有一台处理机，因而每次只允许一个进程执行，其余进程只能等待。由于资源等因素的限制，使进程的执行通常都不是“一气呵成”，而是以“停停走走”的方式运行。</li></ol><h2 id="操作系统的主要功能"><a class="markdownIt-Anchor" href="#操作系统的主要功能"></a> 操作系统的主要功能</h2><ol><li>处理机管理功能：进程控制、进程同步（互斥、同步）、进程通信、进程与作业调度</li><li>存储器管理功能：内存分配、内存保护、地址映射、内存扩充（虚拟技术）</li><li>设备管理功能：缓冲管理、设备分配、设备处理、I/O控制、磁盘调度</li><li>文件管理：文件存储空间的管理、目录管理、文件读写管理和保护</li><li>操作系统与用户之间的接口：命令接口（联机命令接口、脱机命令接口、图形用户界面）、程序接口（也称系统调用）</li></ol><h2 id="操作系统设计"><a class="markdownIt-Anchor" href="#操作系统设计"></a> 操作系统设计</h2><ol><li><p>传统操作系统结构</p><ol><li><p>无结构操作系统</p></li><li><p>模块化结构OS：将OS按其功能精心地划分为若干个具有一定独立性和大小的模块；每个模块具有某方面的管理功能。仔细地规定好各模块间的接口，使各模块之间能通过该接口实现交互；进一步将各模块细分为若干个具有一定功能的子模块。</p><p>优点：提高OS设计的正确性、可理解性和可维护性；增强OS适应性、加速OS开发过程</p><p>缺点：模块间接口难满足实际需求；开发无序。</p><img src="/image/OS/image-20220610185210097.png" alt="image-20220610185210097" style="zoom:50%;" /></li><li><p>分层式结构OS：为了将模块-接口法中“决定顺序”的无序性变为有序性，引入了有序分层法。</p><p>在目标系统An和裸机系统A0之间铺设若干层次软件，最终能在A0上运行。常采用自底向上法铺设。</p><p>优点：易证明正确性、易扩充和维护；缺点：系统效率降低。</p><img src="/image/OS/image-20220610185623932.png" alt="image-20220610185623932" style="zoom:50%;" /></li></ol></li><li><p>客户/服务器模式（C/S模式）</p><ol><li>组成：客户机（在一个LAN网络上连接多台网络工作站）、服务器（规模较大的机器）、网络系统（用于连接所有客户机和服务器）</li><li>C/S模式优点：数据的分布处理和存储；便于集中管理；灵活性和可扩充性；易于改编应用软件</li></ol></li><li><p>面向对象的程序设计</p></li><li><p>微内核OS结构</p><ol><li>足够小的内核：微内核并非是一个完整的OS，而只是操作系统中最基本的部分，它通常用于：① 实现与硬件紧密相关的处理；② 实现一些较基本的功能；③ 负责客户和服务器之间的通信。它们只是为构建通用OS提供一个重要基础，这样就可以确保把操作系统内核做得很小。</li><li>基于客户/服务器模式</li><li>应用机制与策略分离原理</li><li>采用面向对象技术</li></ol><p>微内核的基本功能：进程管理、低级存储器管理、中断和陷入处理</p><img src="/image/OS/image-20220610190801483.png" alt="image-20220610190801483" style="zoom:50%;" /></li></ol><h2 id="习题"><a class="markdownIt-Anchor" href="#习题"></a> 习题</h2><ol><li><p>在计算机系统中配置操作系统的主要目的是(A)，操作系统的主要功能是管理计算机系统中的(B)，包括©和(D)，以及文件和设备。这里©的管理主要是对进程进行管理。</p><p>A (1) 增强计算机系统的功能 (2) 提高系统资源的利用率 (3) 提高系统运行速度 (4) 合理组织系统的工作流程以提高吞吐量</p><p>B (1) 程序和数据 (2) 进程 (3) 资源 (4) 作业 (5) 软件 (6) 硬件</p><p>C, D (1) 存储器 (2) 虚拟存储器 (3) 运算器 (4) 处理机 (5) 控制器</p></li><li><p>操作系统是一种系统软件，它负责为用户和用户程序完成(A)的工作。</p><p>A (1) 与硬件无关并与应用无关 (2) 与硬件相关而与应用无关 (3) 与硬件无关而与应用相关 (4) 与硬件相关并与应用相关</p></li><li><p>在多道批处理系统中，为了充分利用各种资源，系统总是优先选择(A)多个作业投入运行；为了提高吞吐量，系统总是想方设法缩短用户作业的(B)</p><p>A (1) 适应于内存容量的 (2) 计算量大的 (3) I/O量大的 (4) 计算型和I/O型均衡的</p><p>B (1) 周转时间 (2) 运行时间 (3) 提交时间 (4) 阻塞时间</p></li><li><p>分时系统响应时间（及时性）主要是根据(A)确定的，而实时系统的响应时间则是由(B)确定的。</p><p>A, B (1) 时间片大小 (2) 用户数目 (3) 计算机运行速度 (4) 用户所能接受的等待时间 (5) 控制对象所能接受的时延 (6) 实时调度</p></li><li><p>分时系统和实时系统都有交互性，实时系统的交互性允许用户访问(A)，分时系统的交互性允许用户请求系统提供(B)。</p><p>A (1) 文字编辑程序 (2) 专用服务程序 (3) 专用硬件 (4) 数据处理程序</p><p>B (1) 数据处理服务 (2) 资源共享服务 (3) 数据通信服务 (4) 多方面的服务</p></li></ol><p>答案：1. A(2) B(3) C(4) D(1) 2. A(2) 3. A(4) B(1) 4. A(4) B(5) 5. A(2) B(4)</p><h1 id="进程管理"><a class="markdownIt-Anchor" href="#进程管理"></a> 进程管理</h1><h2 id="进程的基本概念"><a class="markdownIt-Anchor" href="#进程的基本概念"></a> 进程的基本概念</h2><ol><li><p>程序的顺序执行：在各程序段之间，必须按照某种先后次序顺序执行</p><p>程序顺序执行的特征：顺序性、封闭性（程序一旦开始，执行结果不受外界影响）、可再现性</p></li><li><p>程序的并发执行</p><ol><li>并发程序：是指两道或两道以上程序同时装入内存中运行，这些程序的执行在时间上互相有重叠，即在一个程序执行结束之前，另一个程序已经开始执行。</li><li>特征：间断性、失去封闭性、不可再现性</li></ol></li><li><p>进程的特征和定义</p><p>在多道程序环境下，程序的执行属于并发执行，此时它们将失去其封闭性，并具有间断性及不可再现性的特征。为使程序能并发执行，且为了对并发执行的程序加以描述和控制，人们引入了“进程”的概念。</p><ol><li><p>进程的定义</p><ul><li>进程是程序的一次执行</li><li>进程是一个程序及其数据在处理机上顺序执行所发生的活动</li><li>进程是程序在一个数据集合上运行的过程，它是系统进行资源分配和调度的一个独立单位</li></ul></li><li><p>进程的特征：</p><ul><li>结构性：通常程序无法并行执行，为使程序能独立运行，应配置一个进程控制块（PCB）；由程序段、相关数据和PCB构成了进程实体。创建进程：创建进程实体中的PCB。撤销便是撤销进程的PCB。</li><li>动态性</li><li>并发性</li><li>独立性</li><li>异步性</li></ul></li><li><p>进程的基本状态：就绪、执行（单处理机系统只有一个进程处于执行状态）、阻塞</p><img src="/image/OS/image-20220611101211062.png" alt="image-20220611101211062" style="zoom:50%;" /></li><li><p>挂起状态：某进程在计算机操作系统中暂时被调离出内存的状况。</p><ol><li><p>引入挂起状态的原因：终端用户的请求；父进程请求；负荷调节的需要；操作系统的需要</p><img src="/image/OS/image-20220611101436073.png" alt="image-20220611101436073" style="zoom:50%;" /></li></ol></li><li><p>创建状态和终止状态</p><ol><li><p>创建状态：创建一个进程一般要通过两个步骤：首先，为一个新进程创建PCB，并填写必要的管理信息；其次，把该进程转入就绪状态并插入就绪队列之中。</p><p>当一个新进程被创建时，系统已为其分配了PCB，填写了进程标识等信息，但由于该进程所必需的资源或其它信息，如主存资源尚未分配等，一般而言，此时的进程已拥有了自己的PCB，但进程自身还未进入主存，<strong>即创建工作尚未完成</strong>，<strong>进程还不能被调度运行</strong>，其所处的状态就是创建状态。</p></li><li><p>终止状态：当一个进程到达了自然结束点，或是出现了无法克服的错误，或是被操作系统所终结，或是被其他有终止权的进程所终结，它将进入终止状态。</p><p>进程的终止也要通过两个步骤：首先等待操作系统进行善后处理，然后将其PCB清零，并将PCB空间返还系统。</p><p>进入终止态的进程以后不能再执行，但在操作系统中依然保留一个记录，其中保存状态码和一些计时统计数据，供其它进程收集。一旦其它进程完成了对终止状态进程的信息提取之后，操作系统将删除该进程。</p><img src="/image/OS/image-20220611101850019.png" alt="image-20220611101850019" style="zoom:50%;" /><img src="/image/OS/image-20220611101900085.png" alt="image-20220611101900085" style="zoom:50%;" /><p>当系统资源足够时，进程创建后便给其分配资源，进入活动就绪状态；当系统资源和性能不足时，并不分配给新建进程所需资源（特别是主存），进程状态为静止就绪状态，换到外存，不参与调度。</p></li></ol></li><li><p>进程控制块PCB</p><ol><li><p>作用：为了描述和控制进程的运行，系统为每个进程定义了一个数据结构——进程控制块PCB，它是进程实体的一部分，是操作系统中最重要的记录型数据结构。作用是使一个在多道程序环境下不能独立运行的程序(含数据)，成为一个能独立运行的基本单位，一个能与其它进程并发执行的进程。</p></li><li><p>系统总是通过PCB对进程进行控制：</p><ul><li>OS调度某进程执行时，要从该进程PCB中查出先行状态及优先级</li><li>调度到某进程后，要根据其PCB中所保存的处理及状态信息，设置该进程恢复运行的现场，根据PCB中程序和数据的内存始址，找出其程序和数据</li><li>进程执行过程中，需要和与之合作的进程同步、通信或访问文件时，也需要访问PCB</li><li>进程由于某种原因暂停执行时，需将断点的处理机环境保存在PCB中</li></ul></li><li><p>进程常驻内存，放在OS专门开辟的PCB区内。</p></li><li><p>进程控制块中的信息</p><ol><li>进程标识信息：内部标识符（PID）、外部标识符</li><li>处理机状态信息：通用寄存器、PC、PSW、用户栈指针</li><li>进程调度信息：进程状态、优先级、调度所需其他信息</li><li>进程控制信息：程序和数据地址、进程同步和通信机制、资源清单、链接指针</li></ol></li><li><p>PCB的组织方式</p><ol><li><p>链接方式：把具有同一状态的PCB，用其中的链接字链接成一个队列。这样，可以形成就绪队列、若干个阻塞队列和空白队列等。</p><img src="/image/OS/image-20220611103320670.png" alt="image-20220611103320670" style="zoom:50%;" /></li><li><p>索引方式：系统根据所有进程的状态建立几张索引表，并把各索引表在内存的首地址记录在内存的一些专用单元中。</p><img src="/image/OS/image-20220611103400450.png" alt="image-20220611103400450" style="zoom:50%;" /></li></ol></li></ol></li></ol></li></ol><h2 id="进程控制"><a class="markdownIt-Anchor" href="#进程控制"></a> 进程控制</h2><p>进程控制是进程管理中最基本的功能。它用于<strong>创建一个新进程</strong>，<strong>终止一个已完成的进程</strong>，或<strong>终止一个因出现某事件而使其无法运行下去的进程</strong>，还可负责进程运行中的状态转换。</p><ol><li><p>原语：机器语言编写、常驻内存、不可中断（下图为四个控制原语）</p><img src="/image/OS/image-20220611104308381.png" alt="image-20220611104308381" style="zoom:33%;" /></li><li><p>进程控制</p><ol><li><p>进程图：用于描述一个进程的家族关系的有向树</p><img src="/image/OS/image-20220611104350316.png" alt="image-20220611104350316" style="zoom:33%;" /></li><li><p>引起创建进程的事件：用户登录、作业调度（批处理系统，调度到某作业时，装入内存、分配资源、创建线程、插入到就绪队列）、提高服务（用户程序提出某种请求）、应用请求</p><p>进程创建原语：Create():申请空白PCB、为新进程分配资源、初始化PCB、插入到就绪队列</p></li><li><p>引起进程终止的事件：正常结束、异常结束（越界错误、保护错-访问不允许访问或不适当方式访问、非法指令等）、外界干预</p><p>进程终止原语：termination():根据被终止进程的标识符，取出PCB读出状态、若处于执行态立刻终止、终止子孙进程、归还被终止进程资源、将被终止进程PCB从队列移除</p></li><li><p>引起进程阻塞或唤醒事件：请求系统服务（阻塞）、启动某种操作（阻塞）、新数据尚未到达（阻塞）、无新工作可做（阻塞）</p><p>进程阻塞原语：Block() 进程唤醒原语：Wakeup()</p><ul><li>Block(): 1. 进程停止执行 2. PCB现行状态执行变为阻塞 3. PCB插入阻塞队列 4. 调用调度程序重新调度</li><li>Wakeup(): 1. 将被阻塞进程从阻塞队列移除 2. PCB现行状态变为就绪 3. PCB插入就绪队列</li><li>Suspend() 1. 检查被挂起进程状态，若处于活动就绪则改为静止就绪；若处于活动阻塞则改为静止阻塞 2. PCB复制到内存区域 3. 若被挂起进程正在执行则重新调度</li></ul></li></ol></li></ol><h2 id="进程同步"><a class="markdownIt-Anchor" href="#进程同步"></a> 进程同步</h2><ol><li><p>进程同步基本概念</p><ol><li><p>并发进程之间的制约关系：间接制约关系（共享某种资源）、直接制约关系（进程间合作）</p><img src="/image/OS/image-20220611110140013.png" alt="image-20220611110140013" style="zoom:50%;" /></li><li><p>临界资源：一次只允许一个进程使用的资源</p></li><li><p>临界区：包含临界资源的程序段。每个进程在进入临界区之前，应先对欲访问的临界资源进行检查，看它是否正被访问。必须在临界区前面增加一段用于进行上述检查的代码，把这段代码称为进入区(entry section)。相应地，在临界区后面也要加上一段称为退出区(exit section)的代码，用于将临界区正被访问的标志恢复为未被访问的标志。</p></li><li><p><strong>同步机制遵循原则（临界区调度原则）</strong></p><ol><li>空闲让进</li><li>忙则等待</li><li>有限等待：对要求访问临界资源的进程应保证在有限时间内进入</li><li>让权等待：不能进入自己临界区时应立即释放</li></ol></li><li><p>信号量机制</p><ol><li><p>整形信号量：一个用于表示资源数目的整型量S，仅能通过原语Wait(s)和signal(s)操作。</p><p>wait操作当S≤0时会一直测试，不遵循让权等待。</p></li><li><p>记录形信号量：增加进程链表L，链接所有等待进程。</p><p>S.value初值表示系统中某类资源的数目。每次Wait操作都意味着进程请求一个单位的该类资源，当S.value＜0时，表示该类资源已分配完毕，应调用block()自我阻塞。</p><p>每次signal代表释放一个，当释放以后S.value仍然≤0，应该wakeup唤醒S.L第一个等待的进程。</p><p>当初值为1代表互斥信号量。</p></li><li><p>AND型信号量：将进程在整个运行过程中需要的所有资源，一次性全部地分配给进程，待进程使用完后再一起释放。只要尚有一个资源未能分配给进程，其它所有可能为之分配的资源也不分配给它。</p><p>Swait(Dmutex, Emutex)和Ssignal(Dmutex, Emutex)</p></li><li><p>信号量集：Swait(S1，t1，d1，…，Sn，tn，dn)操作可描述如下，其中S为信号量，d为需求值，而t为下限值。</p><ul><li>Swait(S，d，d)。此时，在信号量集中只有一个信号量S，但允许它每次申请d个资源，当现有资源数少于d时，不予分配。</li><li>Swait(S，1，1)。此时的信号量集已蜕化为一般的记录型信号量(S&gt;1时)或互斥信号量(S=1时)。</li><li>Swait(S，1，0)。这是一种很特殊且很有用的信号量操作。当S≥1时，允许多个进程进入某特定区；当S变为0后，将阻止任何进程进入特定区。换言之，它相当于一个可控开关。</li></ul></li></ol></li><li><p>管程：代表共享资源的数据结构，以及由对该共享数据结构实施操作的一组过程所组成的资源管理程序，共同构成了一个操作系统的资源管理模块。</p><ol><li><p>管程的组成：管程名称、局部于管程内部的共享数据结构说明、对该数据结构进行操作的一组过<br />程、对局部于管程内部的共享数据设置初始值的语句。</p><img src="/image/OS/image-20220611112957353.png" alt="image-20220611112957353" style="zoom:50%;" /></li><li><p>管程特性：模块化、抽象数据类型、信息掩蔽</p></li><li><p>管程和进程的区别</p><ul><li>进程定义的是私有数据结构PCB，管程定义公有数据结构</li><li>进程是由顺序程序执行有关操作，管程主要进行进程同步和初始化操作</li><li>设置进程目的：实现系统并发行；设置管程目的：解决共享资源互斥使用</li><li>管程：被动工作；进程：主动工作</li><li>进程之间并发执行；管程不可与调用者并发</li><li>进程具有动态性，创建、撤销；管程是OS中资源管理模块，供进程使用。</li></ul></li><li><p>条件变量：</p><ol><li>x.wait：正在调用管程的进程因x条件需要被阻塞或挂起，则调用x.wait将自己插入到x条件的等待队列上，并释放管程，直到x条件变化。此时其它进程可以使用该管程。</li><li>x.signal：正在调用管程的进程发现x条件发生了变化，则调用x.signal，唤醒一个因x条件而阻塞或挂起的进程。如果存在多个这样的进程，则选择其中的一个，如果没有，则继续执行原进程，而不产生任何结果。（这与信号量机制中的signal操作不同，因为后者总是要执行s:=s+1操作，因而总会改变信号量的状态。）</li></ol></li></ol></li></ol></li></ol><h2 id="经典进程同步问题"><a class="markdownIt-Anchor" href="#经典进程同步问题"></a> 经典进程同步问题</h2><p>生产者消费者、读者写者、哲学家吃饭</p><h2 id="进程通信"><a class="markdownIt-Anchor" href="#进程通信"></a> 进程通信</h2><p>进程之间有两种信息需要交换：低级通信（传递控制信息）、高级信息（传递数据）</p><p>目前，高级通信机制归结为三大类：共享存储器系统、信息传递系统和管道通信系统</p><ol><li><p>共享存储器系统：相互通信的进程共享某些数据结构或共享存储区，进程便可以通过这些空间通信。</p><ol><li>基于共享数据结构的通信方式：要求进程公用某些数据结构，借以实现诸进程间的信息交换。如在生产者—消费者问题中，就是用有界缓冲区这种数据结构来实现通信的。低效、只适合传递少量数据。</li><li>基于共享存储区的通信方式。为了传输大量数据，在存储器中划出了一块共享存储区，进程可通过对共享存储区中数据的读写来实现通信。需要程序员自己设置同步和互斥措施才能保证实现正确的通信。</li></ol></li><li><p>消息传递系统：进程间的数据交换是以格式化的消息为单位的；程序员直接利用操作系统提供的一组通信命令(原语)。</p><ol><li>直接通信方式：原语——Send(Receiver, message), Receive(Sender, message)</li><li>间接通信方式：利用邮箱通信方式，可实现实时和非实时通信。提供若干原语：<ol><li>创建、撤销邮箱</li><li>发送、接受消息 Send(mailbox, message), Receive(mailbox, message)</li><li>三种信箱：私用信箱（单向）、公用信箱（双向，操作系统创建）、共享信箱（创建时期指明共享，同时指出共享进程）</li></ol></li></ol></li><li><p>管道通信</p><ol><li><p>所谓“管道”，是指用于连接一个读进程和一个写进程以实现它们之间通信的一个共享文件，又名pipe文件。</p></li><li><p>写进程以<strong>字符流</strong>形式将大量数据送入管道，读数据读走。</p></li><li><p>管道机制必须提供以下三方面协调能力：</p><ol><li>互斥：一个进程对管道读写，另一进程须等待</li><li>同步：写进程写入pipe后去睡眠等待，直至读进程取走在唤醒；读进程读空pipe后也应等待，写进程写入管道后再唤醒。</li><li>确定对方是否存在：确定已存在才能进行通信。</li></ol><img src="/image/OS/image-20220611161200234.png" alt="image-20220611161200234" style="zoom:50%;" /></li></ol></li><li><p>信息传递的实现</p><ol><li>通信链路：<ol><li>两种方式建立：显式建立（建立连接原语请求建立，需要显示拆除）、自动建立（利用系统发送原语，系统自动建立，主要用于单机）</li><li>根据连接方式分为两类：点对点、多点连接链路</li><li>根据通信方式分为两类：单向、双向链路</li><li>根据链路容量分为两类：无容量（没有缓冲区）、有容量链路</li></ol></li><li>消息格式<ol><li>可以分为消息头+消息正文。</li><li>定长消息格式、变长消息格式</li></ol></li><li>进程同步方式<ol><li>发送进程阻塞，接收进程阻塞</li><li>发送进程不阻塞，接受进程阻塞（常用）</li><li>发送和接收进程均不阻塞（较常见）</li></ol></li></ol></li><li><p>消息缓冲队列通信机制</p><ol><li>消息缓冲区</li><li>PCB中有关通信的数据项：增加消息队列首指针，用于对消息队列进行操作</li><li>发送、接受原语</li></ol><h2 id="线程"><a class="markdownIt-Anchor" href="#线程"></a> 线程</h2></li></ol><img src="/image/OS/image-20220611161354461.png" alt="image-20220611161354461" style="zoom:40%;" /><ol><li><p>线程的基本概念：</p><ol><li>调度：引入线程的OS中，把<strong>线程</strong>作为<strong>调度和分派</strong>的基本单位，把<strong>进程</strong>作为<strong>资源拥有</strong>的基本单位。</li><li>并发性：引入线程的OS中，不仅进程之间可以并发执行，一个进程内的<strong>多个线程之间也可以并发执行</strong></li><li>拥有资源：线程自己不拥有系统资源，但它可以访问其隶属进程的资源</li><li>系统开销：线程切换的代价远低于进程</li><li>此外，一个进程中的多个线程具有相同的地址空间，在同步和通信的实现方面线程也比进程容易。</li></ol></li><li><p>线程的属性</p><ol><li>轻型实体：不拥有系统资源，只有必不可少、能保证其独立运行的资源（如TCB）</li><li>独立调度和分配的基本单位</li><li>可并发执行</li><li>共享进程资源</li></ol></li><li><p>线程的状态</p><ol><li>状态参数：寄存器状态、堆栈、线程运行状态、优先级、线程专有存储器、信号屏蔽</li><li>运行状态：执行、就绪、阻塞状态</li></ol></li><li><p>线程的创建和终止</p><ol><li>应用程序在启动时，通常仅有一个线程在执行，该线程被人们称为“初始化线程”。它可根据需要再去创建若干个线程。</li></ol></li><li><p>多线程OS中的进程</p><ol><li>作为系统资源分配的基本单位</li><li>可包含多个线程</li><li>进程不是一个可执行的实体</li></ol></li><li><p>线程实现方式</p><ol><li><p>内核支持线程：不论什么进程，都是在操作系统内核支持下运行的，与内核紧密相关。内核支持线程中，无论是系统还是用户进程中的线程，创建、撤销、切换均由内核完成。</p><p>优点：内核能够同时调度同一进程的多个线程并行执行；进程中一个线程被阻塞了，内核可以调度当前进程或其他进程的线程执行；线程切换快；可采用多线程技术。</p><p>缺点：用户的线程切换开销较大。（需要在管态和目态切换）</p></li><li><p>用户级线程：对于这种线程的创建、撤消、线程之间的同步与通信等功能，都无须利用系统调用来实现。</p><p>优点：线程切换不需要转到内核空间；调度算法可以是进程专用的；用户级线程的实现与操作系统无关。</p><p>缺点：系统调用的阻塞问题（线程执行一个系统调用后，该线程所属进程的全部线程均被阻塞）；多线程应用不能利用多处理机进行多重处理。</p></li><li><p>组合方式：内核支持KST线程建立、调度和管理，也允许用户应用程序建立、调度和管理用户级线程；同一个进程内的多个线程可以同时在多处理器上并行执行，而且在阻塞一个线程时，并不需要将整个进程阻塞。</p><img src="/image/OS/image-20220611163842026.png" alt="image-20220611163842026" style="zoom:50%;" /></li><li><p>用户级线程与内核控制线程的连接</p><ol><li><p>一对一模型：为每一个用户线程都设置一个内核控制线程与之连接，当一个线程阻塞时，允许调度另一个线程运行。在多处理机系统中，则有多个线程并行执行。</p></li><li><p>多对一模型：将多个用户线程映射到一个内核控制线程，为了管理方便，这些用户线程一般属于一个进程，运行在该进程的用户空间，对这些线程的调度和管理也是在该进程的用户空间中完成。当用户线程需要访问内核时，才将其映射到一个内核控制线程上，但每次只允许一个线程进行映射。</p><p>线程管理开销小、效率高，但一个线程访问内核阻塞，整个进程都阻塞。同时在多处理机系统中，一个进程的多个线程无法实现并行。</p></li><li><p>多对多模型：该模型结合上述两种模型的优点，将多个用户线程映射到多个内核控制线程，内核控制线程的数目可以根据应用进程和系统的不同而变化，可以比用户线程少，也可以与之相同。</p></li></ol></li></ol></li></ol><h2 id="习题-2"><a class="markdownIt-Anchor" href="#习题-2"></a> 习题</h2><ol><li><p>若进程正处于执行状态时，因终端请求而停下来以便研究其运行状况，此时进程应转变为(A)状态。</p></li><li><img src="/image/OS/image-20220611234353131.png" alt="image-20220611234353131" style="zoom:50%;" /></li><li><p>批处理系统中，导致进程创建的典型事件是(A)</p><p>A (1) 作业录入 (2) 作业调度 (3) 进程调度 (4) 中级调度</p></li><li><img src="/image/OS/image-20220611234632211.png" alt="image-20220611234632211" style="zoom:50%;" /></li></ol><p>答案：1. 静止就绪 2. A(1) B(3) C(5) D 中断 3. A(2) 4. A.(4) B. (3) C.(2) D.(5) E.(5)</p><h1 id="处理机调度与死锁"><a class="markdownIt-Anchor" href="#处理机调度与死锁"></a> 处理机调度与死锁</h1><h2 id="处理机调度的层次"><a class="markdownIt-Anchor" href="#处理机调度的层次"></a> 处理机调度的层次</h2><p>调度分为三个层次：高级调度（作业调度）、中级调度（交换调度）、低级调度（进程调度）</p><ol><li><p>高级调度</p><ol><li><p>作业：比程序更广泛的概念，作业 = JCB + 作业说明书 + 程序 + 数据。批处理系统中以作业为基本单位从外存调入内存。</p><p>作业步：每个作业在运行期间都会经过若干独立的加工步骤，我们将每一个加工步骤成为作业步。</p><p>典型的作业分为三个作业步：编译作业步、连结装配作业步、运行作业步</p></li><li><p>作业控制块PCB：多道批处理系统中为每个作业设置了一个作业控制块，它是作业在系统中存在的标志，其中保存了系统对作业进行管理和调度所需的全部信息。</p><p>每个作业进入系统时，系统为每个作业建立一个JCB，根据作业类型将它插入相应的<strong>后备队列</strong>中。</p><p><strong>作业调度程序</strong>依据一定的调度算法来调度它们，被调度到的作业将会装入内存。在作业运行期间，系统就按照JCB中的信息对作业进行控制。当一个作业执行结束进入完成状态时，系统负责回收分配给它的资源，撤消它的作业控制块。</p></li><li><p>作业状态</p><img src="/image/OS/image-20220611191420351.png" alt="image-20220611191420351" style="zoom:50%;" /><ul><li><p>作业提交：作业的输入（从输入设备到外存）；</p></li><li><p>作业收容（就绪）：作业输入（到外存）完成，系统为其建立JCB，等待调度运行；</p></li><li><p>作业执行：分配资源，送入内存，被调度运行；</p></li><li><p>作业完成：释放资源，完成作业输出；</p><img src="/image/OS/image-20220611191733863.png" alt="image-20220611191733863" style="zoom:50%;" /></li></ul></li><li><p>作业调度</p><ol><li>作业调度的主要功能：<strong>根据作业控制块中的信息，审查系统能否满足用户作业的资源需求，以及按照一定的算法，从外存的后备队列中选取某些作业调入内存，并为它们创建进程、分配必要的资源。然后再将新创建的进程插入就绪队列，准备执行。</strong></li><li>周转时间 = 完成时间 - 提交时间 =  等待时间 + 运行时间</li><li>四种调度模型：FIFO、短作业优先、响应比高优先、基于作业优先级</li></ol></li></ol></li><li><p>低级调度</p><p>通常也把低级调度(Low Level Scheduling)称为进程调度或短程调度，它所调度的对象是<strong>进程(或内核级线程)</strong>。进程调度是最基本的一种调度，在多道批处理、分时和实时三种类型的OS中，都必须配置这级调度。</p><ol><li>低级调度的功能：保存处理机现场信息、按某种算法选取进程、把处理机分配给进程</li><li>低级调度三个基本机制：排队器、分派器、上下文切换机制（切换的主要开销）</li><li>进程调度方式：<ol><li>非抢占式方式：实时要求比较严格的实时系统中，不宜采用这种调度方式。</li><li>抢占方式：优先权原则、短作业优先原则、时间片原则</li></ol></li></ol></li><li><p>中级调度</p><p>选择在外存上的那些具备运行条件的就绪进程，将它们重新调入内存，并修改其状态为就绪状态，挂在就绪队列上等待进程调度。</p><ol><li><p>中级调度实际上就是存储器管理中的对换功能。</p></li><li><p>引入目的：提高内存利用率和吞吐量。</p><img src="/image/OS/image-20220611194114021.png" alt="image-20220611194114021" style="zoom:50%;" /></li></ol></li></ol><h2 id="调度队列模型和调度准则"><a class="markdownIt-Anchor" href="#调度队列模型和调度准则"></a> 调度队列模型和调度准则</h2><ol><li><p>调度队列模型</p><ol><li><p>仅有进程调度的调度队列模型：时间片</p><img src="/image/OS/image-20220611194539240.png" alt="image-20220611194539240" style="zoom:50%;" /></li><li><p>具有高级和低级调度的调度队列模型</p><ul><li>作业调度按一定的作业调度算法，从外存的后备队列中选择一批作业调入内存，并为它们建立进程，送入就绪队列，然后才由进程调度按照一定的进程调度算法选择一个进程，把处理机分配给该进程。</li><li>就绪队列的形式。在批处理系统中，最常用的是最高优先权优先调度算法，相应地，最常用的就绪队列形式是优先权队列。</li></ul><img src="/image/OS/image-20220611194635546.png" alt="image-20220611194635546" style="zoom:50%;" /></li><li><p>具有三级调度的调度队列模型</p><img src="/image/OS/image-20220611194916457.png" alt="image-20220611194916457" style="zoom:50%;" /></li></ol></li><li><p>面向用户的准则：周转时间短、响应时间快、截止时间保证、优先权准则</p><ul><li>平均周转时间  <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>T</mi><mo>=</mo><mstyle displaystyle="true" scriptlevel="0"><mfrac><mn>1</mn><mi>n</mi></mfrac></mstyle><mo stretchy="false">[</mo><msubsup><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>n</mi></msubsup><msub><mi>T</mi><mi>i</mi></msub><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">T=\dfrac{1}{n}[\sum_{i=1}^nT_i]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.00744em;vertical-align:-0.686em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.32144em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal">n</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mopen">[</span><span class="mop"><span class="mop op-symbol small-op" style="position:relative;top:-0.0000050000000000050004em;">∑</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.804292em;"><span style="top:-2.40029em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.2029em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.29971000000000003em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">]</span></span></span></span></li><li>带权周转时间 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>W</mi><mo>=</mo><mstyle displaystyle="true" scriptlevel="0"><mfrac><mi>T</mi><msub><mi>T</mi><mi>s</mi></msub></mfrac></mstyle></mrow><annotation encoding="application/x-tex">W=\dfrac{T}{T_s}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">W</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.19633em;vertical-align:-0.8360000000000001em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.36033em;"><span style="top:-2.3139999999999996em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">s</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">T</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.8360000000000001em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></li><li>平均带权周转时间 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>W</mi><mo>=</mo><mstyle displaystyle="true" scriptlevel="0"><mfrac><mn>1</mn><mi>n</mi></mfrac></mstyle><mo stretchy="false">[</mo><msubsup><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>n</mi></msubsup><mstyle displaystyle="true" scriptlevel="0"><mfrac><msub><mi>T</mi><mi>i</mi></msub><msub><mi>T</mi><mi>s</mi></msub></mfrac></mstyle><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">W=\dfrac{1}{n}[\sum_{i=1}^n\dfrac{T_i}{T_s}]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">W</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.19633em;vertical-align:-0.8360000000000001em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.32144em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal">n</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mopen">[</span><span class="mop"><span class="mop op-symbol small-op" style="position:relative;top:-0.0000050000000000050004em;">∑</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.804292em;"><span style="top:-2.40029em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.2029em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.29971000000000003em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.36033em;"><span style="top:-2.3139999999999996em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">s</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.8360000000000001em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mclose">]</span></span></span></span></li></ul></li><li><p>面向系统的准则：系统吞吐量高、处理机利用率好、各类资源的平衡利用</p></li></ol><h2 id="调度算法"><a class="markdownIt-Anchor" href="#调度算法"></a> 调度算法</h2><ol><li><p>先来先服务：适合作业调度和进程调度。有利于长作业，不适合短作业。</p></li><li><p>短作业优先调度：可以用于作业调度和进程调度。对长作业不利，无法保证紧迫性作业。服务时间由用户估计，无法保证真正的短作业优先。</p></li><li><p>高优先权优先调度算法</p><ol><li><p>优先权调度算法类型：非抢占式优先权算法（用于批处理系统、对实时性要求不高的系统）、抢占式优先权调度算法（常用于比较严格的实时系统中，以及对性能要求较高的批处理和分时处理系统中）</p></li><li><p>优先权类型：静态优先权、动态优先权</p></li><li><p>高响应比优先调度算法：</p><p><span class='katex-error' title='ParseError: KaTeX parse error: Undefined control sequence: \mbox at position 1: \̲m̲b̲o̲x̲{优先权}=\dfrac{\m…'>\mbox{优先权}=\dfrac{\mbox{等待时间}+\mbox{要求服务时间}}{\mbox{要求服务时间}}=\dfrac{\mbox{响应时间}}{\mbox{要求服务时间}}</span></p></li></ol></li><li><p>基于时间片的轮转调度算法</p><ol><li><p>时间片轮转法（分时系统）</p><p>每个时刻，先把到来的任务插入队尾，然后再把这一时刻执行完的任务放到队尾。</p></li><li><p>多级反馈队列调度算法</p><img src="/image/OS/image-20220611203143858.png" alt="image-20220611203143858" style="zoom:50%;" /><p>设置多个就绪队列，每次时间片到没执行完就放入优先级低的队列（时间片更长）。</p><p>仅当前一个队列空闲时，调度程序才调度下一队列的进程运行。</p></li></ol></li></ol><h2 id="实时调度"><a class="markdownIt-Anchor" href="#实时调度"></a> 实时调度</h2><p>实时系统中调度提出某些特殊的要求，前面的算法不能很好满足。</p><ol><li><p>实现实时调度的基本条件</p><ol><li>系统提供必要信息：就绪时间；开始和完成的截止时间；处理时间；资源要求；优先级。</li><li>系统处理能力强：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msubsup><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>m</mi></msubsup><mstyle displaystyle="true" scriptlevel="0"><mfrac><msub><mi>C</mi><mi>i</mi></msub><msub><mi>P</mi><mi>i</mi></msub></mfrac></mstyle><mo>≤</mo><mi>N</mi></mrow><annotation encoding="application/x-tex">\sum_{i=1}^m\dfrac{C_i}{P_i}\le N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:2.19633em;vertical-align:-0.8360000000000001em;"></span><span class="mop"><span class="mop op-symbol small-op" style="position:relative;top:-0.0000050000000000050004em;">∑</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.804292em;"><span style="top:-2.40029em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.2029em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">m</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.29971000000000003em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.36033em;"><span style="top:-2.3139999999999996em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.07153em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.8360000000000001em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span></span>，其中<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>C</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">C_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.07153em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>为处理时间，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>P</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">P_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>为周期时间，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span></span>为处理机数。</li><li>采取抢占式调度机制</li><li>具有快速切换机制：对外部中断快速响应、快速的任务分派能力</li></ol></li><li><p>非抢占式调度算法：非抢占式轮转/优先调度算法</p></li><li><p>抢占式调度算法：基于时钟中断的抢占式优先权调度算法（抢占需等待时钟到来）、立即抢占的优先权调度算法</p><img src="/image/OS/image-20220611205410899.png" alt="image-20220611205410899" style="zoom:70%;" /></li></ol><h2 id="产生死锁的原因和必要条件"><a class="markdownIt-Anchor" href="#产生死锁的原因和必要条件"></a> 产生死锁的原因和必要条件</h2><ol><li><p>产生死锁的原因：竞争资源、进程间推进顺序非法</p></li><li><p>产生死锁的必要条件</p><ul><li>互斥条件：某资源只能由一个进程占用，其他进程请求该资源只能等待，直至占有该资源的进程释放</li><li>请求和保持条件：进程已经保持了至少一个资源，又提出了新的资源请求，而该资源又被其他进程占有，此时请求进程阻塞但对占有资源不放。</li><li>不剥夺条件：进程已获得的资源，在未使用完前不能被剥夺。</li><li>环路等待条件：发生死锁时，必然存在一个进程-资源的环形链。</li></ul><img src="/image/OS/image-20220611211049820.png" alt="image-20220611211049820" style="zoom:50%;" /></li><li><p>处理死锁的基本方法</p><ol><li>预防死锁：设置限制条件去防止，但是可能会导致系统资源利用率和系统吞吐量降低。</li><li>避免死锁：资源动态分配过程中，用某种方法防止系统进入不安全状态。实现上有一定难度。</li><li>检测死锁：不采用任何措施，在运行过程中发现死锁。</li><li>解除死锁：与检测死锁相配套。实施方法：撤销或挂起一些进程回收资源。</li></ol></li></ol><h2 id="预防死锁的方法"><a class="markdownIt-Anchor" href="#预防死锁的方法"></a> 预防死锁的方法</h2><ol><li><p>预防死锁</p><ol><li>摒弃”请求和保持“条件：必须一次性申请整个运行过程中的全部资源。缺点：资源严重浪费、进程延迟运行。</li><li>摒弃”不剥夺“条件：当一个已经保持了某些资源的进程，再提出新的资源请求而不能立即得到满足时，必须释放它已经保持了的所有资源，待以后需要时再重新申请。实现起来比较复杂，且要付出很大的代价。</li><li>摒弃”环路等待“条件：资源有序分配。</li></ol></li><li><p>系统安全状态：安全状态，是指系统能按某种进程顺序(P1，P2，…，Pn)(称〈P1，P2，…，Pn〉序列为安全序列)，来为每个进程Pi分配其所需资源，直至满足每个进程对资源的最大需求，使每个进程都可顺利地完成。如果系统无法找到这样一个安全序列，则称系统处于不安全状态。</p><p><strong>不安全不一定死锁，死锁必定不安全</strong>。</p></li><li><p>银行家算法：略</p></li></ol><h2 id="死锁的检测与解除"><a class="markdownIt-Anchor" href="#死锁的检测与解除"></a> 死锁的检测与解除</h2><ol><li><p>死锁的检测：允许死锁发生；保存有关资源的请求和分配信息；提供检测算法。检测时机也很重要。</p></li><li><p>资源分配图：</p><img src="/image/OS/image-20220611212934686.png" alt="image-20220611212934686" style="zoom:50%;" /><p>r1已经将资源分配给P1、P2各一个，P2想要一个r1但尚未满足；P1想要一个r2尚未满足；r2已经将资源分配给P2一个。</p></li><li><p>死锁定理：把资源分配图加以简化的方法，检测系统处于S状态时是否处于死锁状态。</p><ol><li>找出一个既<strong>不阻塞又非孤立</strong>的进程结点Pi，释放所占有的全部资源</li><li>重复释放，最后若能消去所有的边，则说明没有死锁；否则说明存在死锁。</li></ol></li><li><p>死锁的解除：</p><ol><li><p>剥夺资源：从其它进程剥夺足够数量的资源给死锁进程，以解除死锁状态。</p></li><li><p>撤销进程：最简单的撤消进程的方法是使全部死锁进程都夭折掉；稍微温和一点的方法是按照某种顺序逐个地撤消进程，直至有足够的资源可用，使死锁状态消除为止。</p><p>同样可以采用策略撤销，如撤销进程付出代价最小等。</p></li></ol></li></ol><h2 id="调度算法小结以及习题"><a class="markdownIt-Anchor" href="#调度算法小结以及习题"></a> 调度算法小结以及习题</h2><img src="/image/OS/image-20220611213512833.png" alt="image-20220611213512833" style="zoom:50%;" /><img src="/image/OS/image-20220611213521570.png" alt="image-20220611213521570" style="zoom:50%;" /><ol><li><img src="/image/OS/image-20220611235910274.png" alt="image-20220611235910274" style="zoom:50%;" /></li><li><p>为了使作业的平均周转时间最短，应采用(A)算法。</p></li><li><img src="/image/OS/image-20220612000005412.png" alt="image-20220612000005412" style="zoom:50%;" /></li></ol><p>答案：1. A(3) B(2) C(4) D(5) 2. A(3) B(1) C(2) D(4) 3. A.短作业优先 4. A(2) B(1)</p>]]></content>
    
    
    <summary type="html">计算机专业课《操作系统》笔记，包括第一~三章。主讲教师：杨志豪。</summary>
    
    
    
    <category term="Courses" scheme="http://aflyingsheep.github.io/categories/Courses/"/>
    
    
    <category term="Courses" scheme="http://aflyingsheep.github.io/tags/Courses/"/>
    
  </entry>
  
</feed>
